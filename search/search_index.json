{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Ethereum Proof-of-Stake Consensus Specifications","text":"<p>To learn more about proof-of-stake and sharding, see the PoS documentation, sharding documentation and the research compendium.</p> <p>This repository hosts the current Ethereum proof-of-stake specifications. Discussions about design rationale and proposed changes can be brought up and discussed as issues. Solidified, agreed-upon changes to the spec can be made through pull requests.</p>"},{"location":"#specs","title":"Specs","text":"<p>Core specifications for Ethereum proof-of-stake clients can be found in specs. These are divided into features. Features are researched and developed in parallel, and then consolidated into sequential upgrades when ready.</p>"},{"location":"#stable-specifications","title":"Stable Specifications","text":"Seq. Code Name Fork Epoch Specs 0 Phase0 <code>0</code> <ul><li>Core</li><ul><li>The beacon chain</li><li>Deposit contract</li><li>Beacon chain fork choice</li></ul><li>Additions</li><ul><li>Honest validator guide</li><li>P2P networking</li><li>Weak subjectivity</li></ul></ul> 1 Altair <code>74240</code> <ul><li>Core</li><ul><li>Beacon chain changes</li><li>Altair fork</li></ul><li>Additions</li><ul><li>Light client sync protocol (full node, light client, networking)</li><li>Honest validator guide changes</li><li>P2P networking</li></ul></ul> 2 Bellatrix  (\"The Merge\") <code>144896</code> <ul><li>Core</li><ul><li>Beacon Chain changes</li><li>Bellatrix fork</li><li>Fork choice changes</li></ul><li>Additions</li><ul><li>Honest validator guide changes</li><li>P2P networking</li></ul></ul> 3 Capella <code>194048</code> <ul><li>Core</li><ul><li>Beacon chain changes</li><li>Capella fork</li></ul><li>Additions</li><ul><li>Light client sync protocol changes (fork, full node, networking)</li></ul><ul><li>Validator additions</li><li>P2P networking</li></ul></ul> 4 Deneb <code>269568</code> <ul><li>Core</li><ul><li>Beacon Chain changes</li><li>Deneb fork</li><li>Polynomial commitments</li><li>Fork choice changes</li></ul><li>Additions</li><ul><li>Light client sync protocol changes (fork, full node, networking)</li></ul><ul><li>Honest validator guide changes</li><li>P2P networking</li></ul></ul>"},{"location":"#in-development-specifications","title":"In-development Specifications","text":"Code Name or Topic Specs Notes Electra <ul><li>Core</li><ul><li>Beacon Chain changes</li><li>EIP-6110 fork</li></ul><li>Additions</li><ul><li>Honest validator guide changes</li></ul></ul> Sharding (outdated) <ul><li>Core</li><ul><li>Beacon Chain changes</li></ul><li>Additions</li><ul><li>P2P networking</li></ul></ul> Custody Game (outdated) <ul><li>Core</li><ul><li>Beacon Chain changes</li></ul><li>Additions</li><ul><li>Honest validator guide changes</li></ul></ul> Dependent on sharding Data Availability Sampling (outdated) <ul><li>Core</li><ul><li>Core types and functions</li><li>Fork choice changes</li></ul><li>Additions</li><ul><li>P2P Networking</li><li>Sampling process</li></ul></ul> <ul><li> Dependent on sharding</li><li>Technical explainer</li></ul>"},{"location":"#accompanying-documents-can-be-found-in-specs-and-include","title":"Accompanying documents can be found in specs and include:","text":"<ul> <li>SimpleSerialize (SSZ) spec</li> <li>Merkle proof formats</li> <li>General test format</li> </ul>"},{"location":"#additional-specifications-for-client-implementers","title":"Additional specifications for client implementers","text":"<p>Additional specifications and standards outside of requisite client functionality can be found in the following repos:</p> <ul> <li>Beacon APIs</li> <li>Engine APIs</li> <li>Beacon Metrics</li> </ul>"},{"location":"#design-goals","title":"Design goals","text":"<p>The following are the broad design goals for the Ethereum proof-of-stake consensus specifications: * to minimize complexity, even at the cost of some losses in efficiency * to remain live through major network partitions and when very large portions of nodes go offline * to select all components such that they are either quantum secure or can be easily swapped out for quantum secure counterparts when available * to utilize crypto and design techniques that allow for a large participation of validators in total and per unit time * to allow for a typical consumer laptop with <code>O(C)</code> resources to process/validate <code>O(1)</code> shards (including any system level validation such as the beacon chain)</p>"},{"location":"#useful-external-resources","title":"Useful external resources","text":"<ul> <li>Design Rationale</li> <li>Phase 0 Onboarding Document</li> <li>Combining GHOST and Casper paper</li> </ul>"},{"location":"#for-spec-contributors","title":"For spec contributors","text":"<p>Documentation on the different components used during spec writing can be found here: * YAML Test Generators * Executable Python Spec, with Py-tests</p>"},{"location":"#online-viewer-of-the-latest-release-latest-master-branch","title":"Online viewer of the latest release (latest <code>master</code> branch)","text":"<p>Ethereum Consensus Specs</p>"},{"location":"#consensus-spec-tests","title":"Consensus spec tests","text":"<p>Conformance tests built from the executable python spec are available in the Ethereum Proof-of-Stake Consensus Spec Tests repo. Compressed tarballs are available in releases.</p>"},{"location":"docs/new-feature/","title":"How to add a new feature proposal in consensus-specs","text":""},{"location":"docs/new-feature/#table-of-contents","title":"Table of Contents","text":"<ul> <li>A. Make it executable for linter checks</li> <li>1. Create a folder under <code>./specs/_features</code></li> <li>2. Choose the \"previous fork\" to extend: usually, use the scheduled or the latest mainnet fork version.</li> <li>3. Write down your proposed <code>beacon-chain.md</code> change</li> <li>4. Add <code>fork.md</code></li> <li>5. Make it executable</li> <li>B: Make it executable for pytest and test generator</li> <li>1. [Optional] Add <code>light-client/*</code> docs if you updated the content of <code>BeaconBlock</code></li> <li>2. Add the mainnet and minimal presets and update the configs</li> <li>3. Update <code>context.py</code></li> <li>4. Update <code>constants.py</code></li> <li>5. Update <code>genesis.py</code>:</li> <li>6. Update CI configurations</li> <li>Others</li> <li>Bonus</li> <li>Need help?</li> </ul>"},{"location":"docs/new-feature/#a-make-it-executable-for-linter-checks","title":"A. Make it executable for linter checks","text":""},{"location":"docs/new-feature/#1-create-a-folder-under-specs_features","title":"1. Create a folder under <code>./specs/_features</code>","text":"<p>For example, if it's an <code>EIP-9999</code> CL spec, you can create a <code>./specs/_features/eip9999</code> folder.</p>"},{"location":"docs/new-feature/#2-choose-the-previous-fork-to-extend-usually-use-the-scheduled-or-the-latest-mainnet-fork-version","title":"2. Choose the \"previous fork\" to extend: usually, use the scheduled or the latest mainnet fork version.","text":"<p>For example, if the latest fork is Capella, use <code>./specs/capella</code> content as your \"previous fork\".</p>"},{"location":"docs/new-feature/#3-write-down-your-proposed-beacon-chainmd-change","title":"3. Write down your proposed <code>beacon-chain.md</code> change","text":"<ul> <li>You can either use Beacon Chain Spec Template, or make a copy of the latest fork content and then edit it.</li> <li>Tips:<ul> <li>We use <code>doctoc</code> tool to generate the table of content.     <pre><code>cd consensus-specs\ndoctoc specs\n</code></pre></li> <li>The differences between \"Constants\", \"Configurations\", and \"Presets\":<ul> <li>Constants: The constant that should never be changed.</li> <li>Configurations: The settings that we may change for different networks.</li> <li>Presets: The settings that we may change for testing.</li> </ul> </li> <li>Readability and simplicity are more important than efficiency and optimization.<ul> <li>Use simple Python rather than the fancy Python dark magic.</li> </ul> </li> </ul> </li> </ul>"},{"location":"docs/new-feature/#4-add-forkmd","title":"4. Add <code>fork.md</code>","text":"<p>You can refer to the previous fork's <code>fork.md</code> file.</p>"},{"location":"docs/new-feature/#5-make-it-executable","title":"5. Make it executable","text":"<ul> <li>Update Pyspec <code>constants.py</code> with the new feature name.</li> <li>Update helpers for <code>setup.py</code> for building the spec:<ul> <li>Update <code>pysetup/constants.py</code> with the new feature name as Pyspec <code>constants.py</code> defined.</li> <li>Update <code>pysetup/spec_builders/__init__.py</code>. Implement a new <code>&lt;FEATURE_NAME&gt;SpecBuilder</code> in <code>pysetup/spec_builders/&lt;FEATURE_NAME&gt;.py</code> with the new feature name. e.g., <code>EIP9999SpecBuilder</code>. Append it to the <code>spec_builders</code> list.</li> <li>Update <code>pysetup/md_doc_paths.py</code>: add the path of the new markdown files in <code>get_md_doc_paths</code> function if needed.</li> </ul> </li> <li>Update <code>PREVIOUS_FORK_OF</code> setting in both <code>test/helpers/constants.py</code> and <code>pysetup/md_doc_paths.py</code>.<ul> <li>NOTE: since these two modules (the pyspec itself and the spec builder tool) must be separate, the fork sequence setting has to be defined again.</li> </ul> </li> </ul>"},{"location":"docs/new-feature/#b-make-it-executable-for-pytest-and-test-generator","title":"B: Make it executable for pytest and test generator","text":""},{"location":"docs/new-feature/#1-optional-add-light-client-docs-if-you-updated-the-content-of-beaconblock","title":"1. [Optional] Add <code>light-client/*</code> docs if you updated the content of <code>BeaconBlock</code>","text":"<ul> <li>You can refer to the previous fork's <code>light-client/*</code> file.</li> <li>Add the path of the new markdown files in <code>pysetup/md_doc_paths.py</code>'s <code>get_md_doc_paths</code> function.</li> </ul>"},{"location":"docs/new-feature/#2-add-the-mainnet-and-minimal-presets-and-update-the-configs","title":"2. Add the mainnet and minimal presets and update the configs","text":"<ul> <li>Add presets: <code>presets/mainnet/&lt;new-feature-name&gt;.yaml</code> and <code>presets/minimal/&lt;new-feature-name&gt;.yaml</code></li> <li>Update configs: <code>configs/mainnet.yaml</code> and <code>configs/minimal.yaml</code></li> </ul>"},{"location":"docs/new-feature/#3-update-contextpy","title":"3. Update <code>context.py</code>","text":"<ul> <li>[Optional] Add <code>with_&lt;new-feature-name&gt;_and_later</code> decorator for writing pytest cases. e.g., <code>with_capella_and_later</code>.</li> </ul>"},{"location":"docs/new-feature/#4-update-constantspy","title":"4. Update <code>constants.py</code>","text":"<ul> <li>Add <code>&lt;NEW_FEATURE&gt;</code> to <code>ALL_PHASES</code> and <code>TESTGEN_FORKS</code></li> </ul>"},{"location":"docs/new-feature/#5-update-genesispy","title":"5. Update <code>genesis.py</code>:","text":"<p>We use <code>create_genesis_state</code> to create the default <code>state</code> in tests.</p> <ul> <li>If the given feature changes <code>BeaconState</code> fields, you have to set the initial values by adding:</li> </ul> <pre><code>def create_genesis_state(spec, validator_balances, activation_threshold):\n...\nif is_post_eip9999(spec):\nstate.&lt;NEW_FIELD&gt; = &lt;value&gt;\nreturn state\n</code></pre> <ul> <li>If the given feature changes <code>ExecutionPayload</code> fields, you have to set the initial values by updating <code>get_sample_genesis_execution_payload_header</code> helper.</li> </ul>"},{"location":"docs/new-feature/#6-update-ci-configurations","title":"6. Update CI configurations","text":"<ul> <li>Update GitHub Actions config<ul> <li>Update <code>pyspec-tests.strategy.matrix.version</code> list by adding new feature to it</li> </ul> </li> <li>Update CircleCI config<ul> <li>Add new job to the <code>workflows.test_spec.jobs</code></li> </ul> </li> </ul>"},{"location":"docs/new-feature/#others","title":"Others","text":""},{"location":"docs/new-feature/#bonus","title":"Bonus","text":"<ul> <li>Add <code>validator.md</code> if honest validator behavior changes with the new feature.</li> </ul>"},{"location":"docs/new-feature/#need-help","title":"Need help?","text":"<p>You can tag spec elves for cleaning up your PR. \ud83e\uddda</p>"},{"location":"docs/templates/beacon-chain-template/","title":"<code>beacon-chain.md</code> Template","text":""},{"location":"docs/templates/beacon-chain-template/#-the-beacon-chain","title":"-- The Beacon Chain","text":""},{"location":"docs/templates/beacon-chain-template/#table-of-contents","title":"Table of contents","text":""},{"location":"docs/templates/beacon-chain-template/#introduction","title":"Introduction","text":""},{"location":"docs/templates/beacon-chain-template/#notation","title":"Notation","text":""},{"location":"docs/templates/beacon-chain-template/#custom-types","title":"Custom types","text":""},{"location":"docs/templates/beacon-chain-template/#constants","title":"Constants","text":""},{"location":"docs/templates/beacon-chain-template/#category-of-constants","title":"[CATEGORY OF CONSTANTS]","text":"Name Value <code>&lt;CONSTANT_NAME&gt;</code> ```"},{"location":"docs/templates/beacon-chain-template/#preset","title":"Preset","text":""},{"location":"docs/templates/beacon-chain-template/#category-of-presets","title":"[CATEGORY OF PRESETS]","text":"Name Value <code>&lt;PRESET_FIELD_NAME&gt;</code> <code>&lt;VALUE&gt;</code>"},{"location":"docs/templates/beacon-chain-template/#configuration","title":"Configuration","text":""},{"location":"docs/templates/beacon-chain-template/#category-of-configurations","title":"[CATEGORY OF CONFIGURATIONS]","text":"Name Value <code>&lt;CONFIGURATION_FIELD_NAME&gt;</code> <code>&lt;VALUE&gt;</code>"},{"location":"docs/templates/beacon-chain-template/#containers","title":"Containers","text":""},{"location":"docs/templates/beacon-chain-template/#category-of-containers","title":"[CATEGORY OF CONTAINERS]","text":""},{"location":"docs/templates/beacon-chain-template/#container_name","title":"<code>CONTAINER_NAME</code>","text":"<pre><code>class CONTAINER_NAME(Container):\nFILED_NAME: SSZ_TYPE\n</code></pre>"},{"location":"docs/templates/beacon-chain-template/#helper-functions","title":"Helper functions","text":""},{"location":"docs/templates/beacon-chain-template/#category-of-helpers","title":"[CATEGORY OF HELPERS]","text":"<pre><code>&lt;PYTHON HELPER FUNCTION&gt;\n</code></pre>"},{"location":"docs/templates/beacon-chain-template/#epoch-processing","title":"Epoch processing","text":""},{"location":"docs/templates/beacon-chain-template/#block-processing","title":"Block processing","text":""},{"location":"docs/templates/beacon-chain-template/#testing","title":"Testing","text":"<p>Note: The function <code>initialize_beacon_state_from_eth1</code> is modified for pure  testing only. <pre><code>def initialize_beacon_state_from_eth1(eth1_block_hash: Hash32,\neth1_timestamp: uint64,\ndeposits: Sequence[Deposit],\nexecution_payload_header: ExecutionPayloadHeader=ExecutionPayloadHeader()\n) -&gt; BeaconState:\n...\n</code></pre>"},{"location":"fork_choice/safe-block/","title":"Fork Choice -- Safe Block","text":""},{"location":"fork_choice/safe-block/#table-of-contents","title":"Table of contents","text":"<ul> <li>Introduction</li> <li><code>get_safe_beacon_block_root</code></li> <li><code>get_safe_execution_payload_hash</code></li> </ul>"},{"location":"fork_choice/safe-block/#introduction","title":"Introduction","text":"<p>Under honest majority and certain network synchronicity assumptions there exists a block that is safe from re-orgs. Normally this block is pretty close to the head of canonical chain which makes it valuable to expose a safe block to users.</p> <p>This section describes an algorithm to find a safe block.</p>"},{"location":"fork_choice/safe-block/#get_safe_beacon_block_root","title":"<code>get_safe_beacon_block_root</code>","text":"<p><pre><code>def get_safe_beacon_block_root(store: Store) -&gt; Root:\n# Use most recent justified block as a stopgap\nreturn store.justified_checkpoint.root\n</code></pre> Note: Currently safe block algorithm simply returns <code>store.justified_checkpoint.root</code> and is meant to be improved in the future.</p>"},{"location":"fork_choice/safe-block/#get_safe_execution_payload_hash","title":"<code>get_safe_execution_payload_hash</code>","text":"<pre><code>def get_safe_execution_payload_hash(store: Store) -&gt; Hash32:\nsafe_block_root = get_safe_beacon_block_root(store)\nsafe_block = store.blocks[safe_block_root]\n# Return Hash32() if no payload is yet justified\nif compute_epoch_at_slot(safe_block.slot) &gt;= BELLATRIX_FORK_EPOCH:\nreturn safe_block.body.execution_payload.block_hash\nelse:\nreturn Hash32()\n</code></pre> <p>Note: This helper uses beacon block container extended in Bellatrix.</p>"},{"location":"light-client/","title":"Light client specifications","text":""},{"location":"specs/_features/custody_game/beacon-chain/","title":"Custody Game -- The Beacon Chain","text":"<p>Notice: This document is a work-in-progress for researchers and implementers.</p>"},{"location":"specs/_features/custody_game/beacon-chain/#table-of-contents","title":"Table of contents","text":"<ul> <li>Introduction</li> <li>Constants</li> <li>Misc</li> <li>Domain types</li> <li>Preset</li> <li>Time parameters</li> <li>Max operations per block</li> <li>Size parameters</li> <li>Reward and penalty quotients</li> <li>Data structures</li> <li>Extended types<ul> <li><code>Validator</code></li> <li><code>BeaconBlockBody</code></li> <li><code>BeaconState</code></li> </ul> </li> <li>New Beacon Chain operations<ul> <li><code>CustodyChunkChallenge</code></li> <li><code>CustodyChunkChallengeRecord</code></li> <li><code>CustodyChunkResponse</code></li> <li><code>CustodySlashing</code></li> <li><code>SignedCustodySlashing</code></li> <li><code>CustodyKeyReveal</code></li> <li><code>EarlyDerivedSecretReveal</code></li> </ul> </li> <li>Helpers</li> <li><code>replace_empty_or_append</code></li> <li><code>legendre_bit</code></li> <li><code>get_custody_atoms</code></li> <li><code>get_custody_secrets</code></li> <li><code>universal_hash_function</code></li> <li><code>compute_custody_bit</code></li> <li><code>get_randao_epoch_for_custody_period</code></li> <li><code>get_custody_period_for_validator</code></li> <li>Per-block processing</li> <li>Block processing</li> <li>Custody Game Operations<ul> <li>Chunk challenges</li> <li>Custody chunk response</li> <li>Custody key reveals</li> <li>Early derived secret reveals</li> <li>Custody Slashings</li> </ul> </li> <li>Per-epoch processing</li> <li>Epoch transition</li> <li>Handling of reveal deadlines</li> <li>Final updates</li> </ul>"},{"location":"specs/_features/custody_game/beacon-chain/#introduction","title":"Introduction","text":"<p>This document details the beacon chain additions and changes of to support the shard data custody game, building upon the Sharding specification.</p>"},{"location":"specs/_features/custody_game/beacon-chain/#constants","title":"Constants","text":""},{"location":"specs/_features/custody_game/beacon-chain/#misc","title":"Misc","text":"Name Value Unit <code>CUSTODY_PRIME</code> <code>int(2 ** 256 - 189)</code> - <code>CUSTODY_SECRETS</code> <code>uint64(3)</code> - <code>BYTES_PER_CUSTODY_ATOM</code> <code>uint64(32)</code> bytes <code>CUSTODY_PROBABILITY_EXPONENT</code> <code>uint64(10)</code> -"},{"location":"specs/_features/custody_game/beacon-chain/#domain-types","title":"Domain types","text":"Name Value <code>DOMAIN_CUSTODY_BIT_SLASHING</code> <code>DomainType('0x83000000')</code>"},{"location":"specs/_features/custody_game/beacon-chain/#preset","title":"Preset","text":""},{"location":"specs/_features/custody_game/beacon-chain/#time-parameters","title":"Time parameters","text":"Name Value Unit Duration <code>RANDAO_PENALTY_EPOCHS</code> <code>uint64(2**1)</code> (= 2) epochs 12.8 minutes <code>EARLY_DERIVED_SECRET_PENALTY_MAX_FUTURE_EPOCHS</code> <code>uint64(2**15)</code> (= 32,768) epochs ~146 days <code>EPOCHS_PER_CUSTODY_PERIOD</code> <code>uint64(2**14)</code> (= 16,384) epochs ~73 days <code>CUSTODY_PERIOD_TO_RANDAO_PADDING</code> <code>uint64(2**11)</code> (= 2,048) epochs ~9 days <code>MAX_CHUNK_CHALLENGE_DELAY</code> <code>uint64(2**15)</code> (= 32,768) epochs ~146 days"},{"location":"specs/_features/custody_game/beacon-chain/#max-operations-per-block","title":"Max operations per block","text":"Name Value <code>MAX_CUSTODY_CHUNK_CHALLENGE_RECORDS</code> <code>uint64(2**20)</code> (= 1,048,576) <code>MAX_CUSTODY_KEY_REVEALS</code> <code>uint64(2**8)</code> (= 256) <code>MAX_EARLY_DERIVED_SECRET_REVEALS</code> <code>uint64(2**0)</code> (= 1) <code>MAX_CUSTODY_CHUNK_CHALLENGES</code> <code>uint64(2**2)</code> (= 4) <code>MAX_CUSTODY_CHUNK_CHALLENGE_RESPONSES</code> <code>uint64(2**4)</code> (= 16) <code>MAX_CUSTODY_SLASHINGS</code> <code>uint64(2**0)</code> (= 1)"},{"location":"specs/_features/custody_game/beacon-chain/#size-parameters","title":"Size parameters","text":"Name Value Unit <code>BYTES_PER_CUSTODY_CHUNK</code> <code>uint64(2**12)</code> (= 4,096) bytes <code>CUSTODY_RESPONSE_DEPTH</code> <code>ceillog2(MAX_SHARD_BLOCK_SIZE // BYTES_PER_CUSTODY_CHUNK)</code> -"},{"location":"specs/_features/custody_game/beacon-chain/#reward-and-penalty-quotients","title":"Reward and penalty quotients","text":"Name Value <code>EARLY_DERIVED_SECRET_REVEAL_SLOT_REWARD_MULTIPLE</code> <code>uint64(2**1)</code> (= 2) <code>MINOR_REWARD_QUOTIENT</code> <code>uint64(2**8)</code> (= 256)"},{"location":"specs/_features/custody_game/beacon-chain/#data-structures","title":"Data structures","text":""},{"location":"specs/_features/custody_game/beacon-chain/#extended-types","title":"Extended types","text":""},{"location":"specs/_features/custody_game/beacon-chain/#validator","title":"<code>Validator</code>","text":"<pre><code>class Validator(sharding.Validator):\n# next_custody_secret_to_reveal is initialised to the custody period\n# (of the particular validator) in which the validator is activated\n# = get_custody_period_for_validator(...)\nnext_custody_secret_to_reveal: uint64\n# TODO: The max_reveal_lateness doesn't really make sense anymore.\n# So how do we incentivise early custody key reveals now?\nall_custody_secrets_revealed_epoch: Epoch  # to be initialized to FAR_FUTURE_EPOCH\n</code></pre>"},{"location":"specs/_features/custody_game/beacon-chain/#beaconblockbody","title":"<code>BeaconBlockBody</code>","text":"<pre><code>class BeaconBlockBody(sharding.BeaconBlockBody):\n# Custody game\nchunk_challenges: List[CustodyChunkChallenge, MAX_CUSTODY_CHUNK_CHALLENGES]\nchunk_challenge_responses: List[CustodyChunkResponse, MAX_CUSTODY_CHUNK_CHALLENGE_RESPONSES]\ncustody_key_reveals: List[CustodyKeyReveal, MAX_CUSTODY_KEY_REVEALS]\nearly_derived_secret_reveals: List[EarlyDerivedSecretReveal, MAX_EARLY_DERIVED_SECRET_REVEALS]\ncustody_slashings: List[SignedCustodySlashing, MAX_CUSTODY_SLASHINGS]\n</code></pre>"},{"location":"specs/_features/custody_game/beacon-chain/#beaconstate","title":"<code>BeaconState</code>","text":"<pre><code>class BeaconState(sharding.BeaconState):\n# Future derived secrets already exposed; contains the indices of the exposed validator\n# at RANDAO reveal period % EARLY_DERIVED_SECRET_PENALTY_MAX_FUTURE_EPOCHS\nexposed_derived_secrets: Vector[List[ValidatorIndex, MAX_EARLY_DERIVED_SECRET_REVEALS * SLOTS_PER_EPOCH],\nEARLY_DERIVED_SECRET_PENALTY_MAX_FUTURE_EPOCHS]\ncustody_chunk_challenge_records: List[CustodyChunkChallengeRecord, MAX_CUSTODY_CHUNK_CHALLENGE_RECORDS]\ncustody_chunk_challenge_index: uint64\n</code></pre>"},{"location":"specs/_features/custody_game/beacon-chain/#new-beacon-chain-operations","title":"New Beacon Chain operations","text":""},{"location":"specs/_features/custody_game/beacon-chain/#custodychunkchallenge","title":"<code>CustodyChunkChallenge</code>","text":"<pre><code>class CustodyChunkChallenge(Container):\nresponder_index: ValidatorIndex\nshard_transition: ShardTransition\nattestation: Attestation\ndata_index: uint64\nchunk_index: uint64\n</code></pre>"},{"location":"specs/_features/custody_game/beacon-chain/#custodychunkchallengerecord","title":"<code>CustodyChunkChallengeRecord</code>","text":"<pre><code>class CustodyChunkChallengeRecord(Container):\nchallenge_index: uint64\nchallenger_index: ValidatorIndex\nresponder_index: ValidatorIndex\ninclusion_epoch: Epoch\ndata_root: Root\nchunk_index: uint64\n</code></pre>"},{"location":"specs/_features/custody_game/beacon-chain/#custodychunkresponse","title":"<code>CustodyChunkResponse</code>","text":"<pre><code>class CustodyChunkResponse(Container):\nchallenge_index: uint64\nchunk_index: uint64\nchunk: ByteVector[BYTES_PER_CUSTODY_CHUNK]\nbranch: Vector[Root, CUSTODY_RESPONSE_DEPTH + 1]\n</code></pre>"},{"location":"specs/_features/custody_game/beacon-chain/#custodyslashing","title":"<code>CustodySlashing</code>","text":"<pre><code>class CustodySlashing(Container):\n# (Attestation.data.shard_transition_root as ShardTransition).shard_data_roots[data_index] is the root of the data.\ndata_index: uint64\nmalefactor_index: ValidatorIndex\nmalefactor_secret: BLSSignature\nwhistleblower_index: ValidatorIndex\nshard_transition: ShardTransition\nattestation: Attestation\ndata: ByteList[MAX_SHARD_BLOCK_SIZE]\n</code></pre>"},{"location":"specs/_features/custody_game/beacon-chain/#signedcustodyslashing","title":"<code>SignedCustodySlashing</code>","text":"<pre><code>class SignedCustodySlashing(Container):\nmessage: CustodySlashing\nsignature: BLSSignature\n</code></pre>"},{"location":"specs/_features/custody_game/beacon-chain/#custodykeyreveal","title":"<code>CustodyKeyReveal</code>","text":"<pre><code>class CustodyKeyReveal(Container):\n# Index of the validator whose key is being revealed\nrevealer_index: ValidatorIndex\n# Reveal (masked signature)\nreveal: BLSSignature\n</code></pre>"},{"location":"specs/_features/custody_game/beacon-chain/#earlyderivedsecretreveal","title":"<code>EarlyDerivedSecretReveal</code>","text":"<p>Represents an early (punishable) reveal of one of the derived secrets, where derived secrets are RANDAO reveals and custody reveals (both are part of the same domain).</p> <pre><code>class EarlyDerivedSecretReveal(Container):\n# Index of the validator whose key is being revealed\nrevealed_index: ValidatorIndex\n# RANDAO epoch of the key that is being revealed\nepoch: Epoch\n# Reveal (masked signature)\nreveal: BLSSignature\n# Index of the validator who revealed (whistleblower)\nmasker_index: ValidatorIndex\n# Mask used to hide the actual reveal signature (prevent reveal from being stolen)\nmask: Bytes32\n</code></pre>"},{"location":"specs/_features/custody_game/beacon-chain/#helpers","title":"Helpers","text":""},{"location":"specs/_features/custody_game/beacon-chain/#replace_empty_or_append","title":"<code>replace_empty_or_append</code>","text":"<pre><code>def replace_empty_or_append(l: List, new_element: Any) -&gt; int:\nfor i in range(len(l)):\nif l[i] == type(new_element)():\nl[i] = new_element\nreturn i\nl.append(new_element)\nreturn len(l) - 1\n</code></pre>"},{"location":"specs/_features/custody_game/beacon-chain/#legendre_bit","title":"<code>legendre_bit</code>","text":"<p>Returns the Legendre symbol <code>(a/q)</code> normalizes as a bit (i.e. <code>((a/q) + 1) // 2</code>). In a production implementation, a well-optimized library (e.g. GMP) should be used for this.</p> <pre><code>def legendre_bit(a: int, q: int) -&gt; int:\nif a &gt;= q:\nreturn legendre_bit(a % q, q)\nif a == 0:\nreturn 0\nassert(q &gt; a &gt; 0 and q % 2 == 1)\nt = 1\nn = q\nwhile a != 0:\nwhile a % 2 == 0:\na //= 2\nr = n % 8\nif r == 3 or r == 5:\nt = -t\na, n = n, a\nif a % 4 == n % 4 == 3:\nt = -t\na %= n\nif n == 1:\nreturn (t + 1) // 2\nelse:\nreturn 0\n</code></pre>"},{"location":"specs/_features/custody_game/beacon-chain/#get_custody_atoms","title":"<code>get_custody_atoms</code>","text":"<p>Given one set of data, return the custody atoms: each atom will be combined with one legendre bit.</p> <pre><code>def get_custody_atoms(bytez: bytes) -&gt; Sequence[bytes]:\nlength_remainder = len(bytez) % BYTES_PER_CUSTODY_ATOM\nbytez += b'\\x00' * ((BYTES_PER_CUSTODY_ATOM - length_remainder) % BYTES_PER_CUSTODY_ATOM)  # right-padding\nreturn [\nbytez[i:i + BYTES_PER_CUSTODY_ATOM]\nfor i in range(0, len(bytez), BYTES_PER_CUSTODY_ATOM)\n]\n</code></pre>"},{"location":"specs/_features/custody_game/beacon-chain/#get_custody_secrets","title":"<code>get_custody_secrets</code>","text":"<p>Extract the custody secrets from the signature</p> <pre><code>def get_custody_secrets(key: BLSSignature) -&gt; Sequence[int]:\nfull_G2_element = bls.signature_to_G2(key)\nsignature = full_G2_element[0].coeffs\nsignature_bytes = b\"\".join(x.to_bytes(48, \"little\") for x in signature)\nsecrets = [int.from_bytes(signature_bytes[i:i + BYTES_PER_CUSTODY_ATOM], \"little\")\nfor i in range(0, len(signature_bytes), 32)]\nreturn secrets\n</code></pre>"},{"location":"specs/_features/custody_game/beacon-chain/#universal_hash_function","title":"<code>universal_hash_function</code>","text":"<pre><code>def universal_hash_function(data_chunks: Sequence[bytes], secrets: Sequence[int]) -&gt; int:\nn = len(data_chunks)\nreturn (\nsum(\nsecrets[i % CUSTODY_SECRETS]**i * int.from_bytes(atom, \"little\") % CUSTODY_PRIME\nfor i, atom in enumerate(data_chunks)\n) + secrets[n % CUSTODY_SECRETS]**n\n) % CUSTODY_PRIME\n</code></pre>"},{"location":"specs/_features/custody_game/beacon-chain/#compute_custody_bit","title":"<code>compute_custody_bit</code>","text":"<pre><code>def compute_custody_bit(key: BLSSignature, data: ByteList) -&gt; bit:\ncustody_atoms = get_custody_atoms(data)\nsecrets = get_custody_secrets(key)\nuhf = universal_hash_function(custody_atoms, secrets)\nlegendre_bits = [legendre_bit(uhf + secrets[0] + i, CUSTODY_PRIME) for i in range(CUSTODY_PROBABILITY_EXPONENT)]\nreturn bit(all(legendre_bits))\n</code></pre>"},{"location":"specs/_features/custody_game/beacon-chain/#get_randao_epoch_for_custody_period","title":"<code>get_randao_epoch_for_custody_period</code>","text":"<pre><code>def get_randao_epoch_for_custody_period(period: uint64, validator_index: ValidatorIndex) -&gt; Epoch:\nnext_period_start = (period + 1) * EPOCHS_PER_CUSTODY_PERIOD - validator_index % EPOCHS_PER_CUSTODY_PERIOD\nreturn Epoch(next_period_start + CUSTODY_PERIOD_TO_RANDAO_PADDING)\n</code></pre>"},{"location":"specs/_features/custody_game/beacon-chain/#get_custody_period_for_validator","title":"<code>get_custody_period_for_validator</code>","text":"<pre><code>def get_custody_period_for_validator(validator_index: ValidatorIndex, epoch: Epoch) -&gt; uint64:\n'''\n    Return the reveal period for a given validator.\n    '''\nreturn (epoch + validator_index % EPOCHS_PER_CUSTODY_PERIOD) // EPOCHS_PER_CUSTODY_PERIOD\n</code></pre>"},{"location":"specs/_features/custody_game/beacon-chain/#per-block-processing","title":"Per-block processing","text":""},{"location":"specs/_features/custody_game/beacon-chain/#block-processing","title":"Block processing","text":"<pre><code>def process_block(state: BeaconState, block: BeaconBlock) -&gt; None:\nprocess_block_header(state, block)\nprocess_randao(state, block.body)\nprocess_eth1_data(state, block.body)\nprocess_light_client_aggregate(state, block.body)\nprocess_operations(state, block.body)\nprocess_custody_game_operations(state, block.body)\n</code></pre>"},{"location":"specs/_features/custody_game/beacon-chain/#custody-game-operations","title":"Custody Game Operations","text":"<pre><code>def process_custody_game_operations(state: BeaconState, body: BeaconBlockBody) -&gt; None:\ndef for_ops(operations: Sequence[Any], fn: Callable[[BeaconState, Any], None]) -&gt; None:\nfor operation in operations:\nfn(state, operation)\nfor_ops(body.chunk_challenges, process_chunk_challenge)\nfor_ops(body.chunk_challenge_responses, process_chunk_challenge_response)\nfor_ops(body.custody_key_reveals, process_custody_key_reveal)\nfor_ops(body.early_derived_secret_reveals, process_early_derived_secret_reveal)\nfor_ops(body.custody_slashings, process_custody_slashing)\n</code></pre>"},{"location":"specs/_features/custody_game/beacon-chain/#chunk-challenges","title":"Chunk challenges","text":"<pre><code>def process_chunk_challenge(state: BeaconState, challenge: CustodyChunkChallenge) -&gt; None:\n# Verify the attestation\nassert is_valid_indexed_attestation(state, get_indexed_attestation(state, challenge.attestation))\n# Verify it is not too late to challenge the attestation\nmax_attestation_challenge_epoch = Epoch(challenge.attestation.data.target.epoch + MAX_CHUNK_CHALLENGE_DELAY)\nassert get_current_epoch(state) &lt;= max_attestation_challenge_epoch\n# Verify it is not too late to challenge the responder\nresponder = state.validators[challenge.responder_index]\nif responder.exit_epoch &lt; FAR_FUTURE_EPOCH:\nassert get_current_epoch(state) &lt;= responder.exit_epoch + MAX_CHUNK_CHALLENGE_DELAY\n# Verify responder is slashable\nassert is_slashable_validator(responder, get_current_epoch(state))\n# Verify the responder participated in the attestation\nattesters = get_attesting_indices(state, challenge)\nassert challenge.responder_index in attesters\n# Verify shard transition is correctly given\nassert hash_tree_root(challenge.shard_transition) == challenge.attestation.data.shard_transition_root\ndata_root = challenge.shard_transition.shard_data_roots[challenge.data_index]\n# Verify the challenge is not a duplicate\nfor record in state.custody_chunk_challenge_records:\nassert (\nrecord.data_root != data_root or\nrecord.chunk_index != challenge.chunk_index\n)\n# Verify depth\nshard_block_length = challenge.shard_transition.shard_block_lengths[challenge.data_index]\ntransition_chunks = (shard_block_length + BYTES_PER_CUSTODY_CHUNK - 1) // BYTES_PER_CUSTODY_CHUNK\nassert challenge.chunk_index &lt; transition_chunks\n# Add new chunk challenge record\nnew_record = CustodyChunkChallengeRecord(\nchallenge_index=state.custody_chunk_challenge_index,\nchallenger_index=get_beacon_proposer_index(state),\nresponder_index=challenge.responder_index,\ninclusion_epoch=get_current_epoch(state),\ndata_root=challenge.shard_transition.shard_data_roots[challenge.data_index],\nchunk_index=challenge.chunk_index,\n)\nreplace_empty_or_append(state.custody_chunk_challenge_records, new_record)\nstate.custody_chunk_challenge_index += 1\n# Postpone responder withdrawability\nresponder.withdrawable_epoch = FAR_FUTURE_EPOCH\n</code></pre>"},{"location":"specs/_features/custody_game/beacon-chain/#custody-chunk-response","title":"Custody chunk response","text":"<pre><code>def process_chunk_challenge_response(state: BeaconState,\nresponse: CustodyChunkResponse) -&gt; None:\n# Get matching challenge (if any) from records\nmatching_challenges = [\nrecord for record in state.custody_chunk_challenge_records\nif record.challenge_index == response.challenge_index\n]\nassert len(matching_challenges) == 1\nchallenge = matching_challenges[0]\n# Verify chunk index\nassert response.chunk_index == challenge.chunk_index\n# Verify the chunk matches the crosslink data root\nassert is_valid_merkle_branch(\nleaf=hash_tree_root(response.chunk),\nbranch=response.branch,\ndepth=CUSTODY_RESPONSE_DEPTH + 1,  # Add 1 for the List length mix-in\nindex=response.chunk_index,\nroot=challenge.data_root,\n)\n# Clear the challenge\nindex_in_records = state.custody_chunk_challenge_records.index(challenge)\nstate.custody_chunk_challenge_records[index_in_records] = CustodyChunkChallengeRecord()\n# Reward the proposer\nproposer_index = get_beacon_proposer_index(state)\nincrease_balance(state, proposer_index, Gwei(get_base_reward(state, proposer_index) // MINOR_REWARD_QUOTIENT))\n</code></pre>"},{"location":"specs/_features/custody_game/beacon-chain/#custody-key-reveals","title":"Custody key reveals","text":"<pre><code>def process_custody_key_reveal(state: BeaconState, reveal: CustodyKeyReveal) -&gt; None:\n\"\"\"\n    Process ``CustodyKeyReveal`` operation.\n    Note that this function mutates ``state``.\n    \"\"\"\nrevealer = state.validators[reveal.revealer_index]\nepoch_to_sign = get_randao_epoch_for_custody_period(revealer.next_custody_secret_to_reveal, reveal.revealer_index)\ncustody_reveal_period = get_custody_period_for_validator(reveal.revealer_index, get_current_epoch(state))\n# Only past custody periods can be revealed, except after exiting the exit period can be revealed\nis_past_reveal = revealer.next_custody_secret_to_reveal &lt; custody_reveal_period\nis_exited = revealer.exit_epoch &lt;= get_current_epoch(state)\nis_exit_period_reveal = (\nrevealer.next_custody_secret_to_reveal\n== get_custody_period_for_validator(reveal.revealer_index, revealer.exit_epoch - 1)\n)\nassert is_past_reveal or (is_exited and is_exit_period_reveal)\n# Revealed validator is active or exited, but not withdrawn\nassert is_slashable_validator(revealer, get_current_epoch(state))\n# Verify signature\ndomain = get_domain(state, DOMAIN_RANDAO, epoch_to_sign)\nsigning_root = compute_signing_root(epoch_to_sign, domain)\nassert bls.Verify(revealer.pubkey, signing_root, reveal.reveal)\n# Process reveal\nif is_exited and is_exit_period_reveal:\nrevealer.all_custody_secrets_revealed_epoch = get_current_epoch(state)\nrevealer.next_custody_secret_to_reveal += 1\n# Reward Block Proposer\nproposer_index = get_beacon_proposer_index(state)\nincrease_balance(\nstate,\nproposer_index,\nGwei(get_base_reward(state, reveal.revealer_index) // MINOR_REWARD_QUOTIENT)\n)\n</code></pre>"},{"location":"specs/_features/custody_game/beacon-chain/#early-derived-secret-reveals","title":"Early derived secret reveals","text":"<pre><code>def process_early_derived_secret_reveal(state: BeaconState, reveal: EarlyDerivedSecretReveal) -&gt; None:\n\"\"\"\n    Process ``EarlyDerivedSecretReveal`` operation.\n    Note that this function mutates ``state``.\n    \"\"\"\nrevealed_validator = state.validators[reveal.revealed_index]\nderived_secret_location = uint64(reveal.epoch % EARLY_DERIVED_SECRET_PENALTY_MAX_FUTURE_EPOCHS)\nassert reveal.epoch &gt;= get_current_epoch(state) + RANDAO_PENALTY_EPOCHS\nassert reveal.epoch &lt; get_current_epoch(state) + EARLY_DERIVED_SECRET_PENALTY_MAX_FUTURE_EPOCHS\nassert not revealed_validator.slashed\nassert reveal.revealed_index not in state.exposed_derived_secrets[derived_secret_location]\n# Verify signature correctness\nmasker = state.validators[reveal.masker_index]\npubkeys = [revealed_validator.pubkey, masker.pubkey]\ndomain = get_domain(state, DOMAIN_RANDAO, reveal.epoch)\nsigning_roots = [compute_signing_root(root, domain) for root in [hash_tree_root(reveal.epoch), reveal.mask]]\nassert bls.AggregateVerify(pubkeys, signing_roots, reveal.reveal)\nif reveal.epoch &gt;= get_current_epoch(state) + CUSTODY_PERIOD_TO_RANDAO_PADDING:\n# Full slashing when the secret was revealed so early it may be a valid custody\n# round key\nslash_validator(state, reveal.revealed_index, reveal.masker_index)\nelse:\n# Only a small penalty proportional to proposer slot reward for RANDAO reveal\n# that does not interfere with the custody period\n# The penalty is proportional to the max proposer reward\n# Calculate penalty\nmax_proposer_slot_reward = (\nget_base_reward(state, reveal.revealed_index)\n* SLOTS_PER_EPOCH\n// len(get_active_validator_indices(state, get_current_epoch(state)))\n// PROPOSER_REWARD_QUOTIENT\n)\npenalty = Gwei(\nmax_proposer_slot_reward\n* EARLY_DERIVED_SECRET_REVEAL_SLOT_REWARD_MULTIPLE\n* (len(state.exposed_derived_secrets[derived_secret_location]) + 1)\n)\n# Apply penalty\nproposer_index = get_beacon_proposer_index(state)\nwhistleblower_index = reveal.masker_index\nwhistleblowing_reward = Gwei(penalty // WHISTLEBLOWER_REWARD_QUOTIENT)\nproposer_reward = Gwei(whistleblowing_reward // PROPOSER_REWARD_QUOTIENT)\nincrease_balance(state, proposer_index, proposer_reward)\nincrease_balance(state, whistleblower_index, whistleblowing_reward - proposer_reward)\ndecrease_balance(state, reveal.revealed_index, penalty)\n# Mark this derived secret as exposed so validator cannot be punished repeatedly\nstate.exposed_derived_secrets[derived_secret_location].append(reveal.revealed_index)\n</code></pre>"},{"location":"specs/_features/custody_game/beacon-chain/#custody-slashings","title":"Custody Slashings","text":"<pre><code>def process_custody_slashing(state: BeaconState, signed_custody_slashing: SignedCustodySlashing) -&gt; None:\ncustody_slashing = signed_custody_slashing.message\nattestation = custody_slashing.attestation\n# Any signed custody-slashing should result in at least one slashing.\n# If the custody bits are valid, then the claim itself is slashed.\nmalefactor = state.validators[custody_slashing.malefactor_index] \nwhistleblower = state.validators[custody_slashing.whistleblower_index]\ndomain = get_domain(state, DOMAIN_CUSTODY_BIT_SLASHING, get_current_epoch(state))\nsigning_root = compute_signing_root(custody_slashing, domain)\nassert bls.Verify(whistleblower.pubkey, signing_root, signed_custody_slashing.signature)\n# Verify that the whistleblower is slashable\nassert is_slashable_validator(whistleblower, get_current_epoch(state))\n# Verify that the claimed malefactor is slashable\nassert is_slashable_validator(malefactor, get_current_epoch(state))\n# Verify the attestation\nassert is_valid_indexed_attestation(state, get_indexed_attestation(state, attestation))\n# TODO: can do a single combined merkle proof of data being attested.\n# Verify the shard transition is indeed attested by the attestation\nshard_transition = custody_slashing.shard_transition\nassert hash_tree_root(shard_transition) == attestation.data.shard_transition_root\n# Verify that the provided data matches the shard-transition\nassert len(custody_slashing.data) == shard_transition.shard_block_lengths[custody_slashing.data_index]\nassert hash_tree_root(custody_slashing.data) == shard_transition.shard_data_roots[custody_slashing.data_index]\n# Verify existence and participation of claimed malefactor\nattesters = get_attesting_indices(state, attestation)\nassert custody_slashing.malefactor_index in attesters\n# Verify the malefactor custody key\nepoch_to_sign = get_randao_epoch_for_custody_period(\nget_custody_period_for_validator(custody_slashing.malefactor_index, attestation.data.target.epoch),\ncustody_slashing.malefactor_index,\n)\ndomain = get_domain(state, DOMAIN_RANDAO, epoch_to_sign)\nsigning_root = compute_signing_root(epoch_to_sign, domain)\nassert bls.Verify(malefactor.pubkey, signing_root, custody_slashing.malefactor_secret)\n# Compute the custody bit\ncomputed_custody_bit = compute_custody_bit(custody_slashing.malefactor_secret, custody_slashing.data)\n# Verify the claim\nif computed_custody_bit == 1:\n# Slash the malefactor, reward the other committee members\nslash_validator(state, custody_slashing.malefactor_index)\ncommittee = get_beacon_committee(state, attestation.data.slot, attestation.data.index)\nothers_count = len(committee) - 1\nwhistleblower_reward = Gwei(malefactor.effective_balance // WHISTLEBLOWER_REWARD_QUOTIENT // others_count)\nfor attester_index in attesters:\nif attester_index != custody_slashing.malefactor_index:\nincrease_balance(state, attester_index, whistleblower_reward)\n# No special whisteblower reward: it is expected to be an attester. Others are free to slash too however. \nelse:\n# The claim was false, the custody bit was correct. Slash the whistleblower that induced this work.\nslash_validator(state, custody_slashing.whistleblower_index)\n</code></pre>"},{"location":"specs/_features/custody_game/beacon-chain/#per-epoch-processing","title":"Per-epoch processing","text":""},{"location":"specs/_features/custody_game/beacon-chain/#epoch-transition","title":"Epoch transition","text":"<p>This epoch transition overrides the phase0 epoch transition:</p> <pre><code>def process_epoch(state: BeaconState) -&gt; None:\nprocess_justification_and_finalization(state)\nprocess_rewards_and_penalties(state)\nprocess_registry_updates(state)\n# Proof of custody\nprocess_reveal_deadlines(state)\nprocess_challenge_deadlines(state)\nprocess_slashings(state)\n# Sharding\nprocess_pending_headers(state)\ncharge_confirmed_header_fees(state)\nreset_pending_headers(state)\n# Final updates\n# Phase 0\nprocess_eth1_data_reset(state)\nprocess_effective_balance_updates(state)\nprocess_slashings_reset(state)\nprocess_randao_mixes_reset(state)\nprocess_historical_roots_update(state)\nprocess_participation_record_updates(state)\n# Proof of custody\nprocess_custody_final_updates(state)\nprocess_shard_epoch_increment(state)\n</code></pre>"},{"location":"specs/_features/custody_game/beacon-chain/#handling-of-reveal-deadlines","title":"Handling of reveal deadlines","text":"<pre><code>def process_reveal_deadlines(state: BeaconState) -&gt; None:\nepoch = get_current_epoch(state)\nfor index, validator in enumerate(state.validators):\ndeadline = validator.next_custody_secret_to_reveal + 1\nif get_custody_period_for_validator(ValidatorIndex(index), epoch) &gt; deadline:\nslash_validator(state, ValidatorIndex(index))\n</code></pre> <pre><code>def process_challenge_deadlines(state: BeaconState) -&gt; None:\nfor custody_chunk_challenge in state.custody_chunk_challenge_records:\nif get_current_epoch(state) &gt; custody_chunk_challenge.inclusion_epoch + EPOCHS_PER_CUSTODY_PERIOD:\nslash_validator(state, custody_chunk_challenge.responder_index, custody_chunk_challenge.challenger_index)\nindex_in_records = state.custody_chunk_challenge_records.index(custody_chunk_challenge)\nstate.custody_chunk_challenge_records[index_in_records] = CustodyChunkChallengeRecord()\n</code></pre>"},{"location":"specs/_features/custody_game/beacon-chain/#final-updates","title":"Final updates","text":"<pre><code>def process_custody_final_updates(state: BeaconState) -&gt; None:\n# Clean up exposed RANDAO key reveals\nstate.exposed_derived_secrets[get_current_epoch(state) % EARLY_DERIVED_SECRET_PENALTY_MAX_FUTURE_EPOCHS] = []\n# Reset withdrawable epochs if challenge records are empty\nrecords = state.custody_chunk_challenge_records\nvalidator_indices_in_records = set(record.responder_index for record in records)  # non-duplicate\nfor index, validator in enumerate(state.validators):\nif validator.exit_epoch != FAR_FUTURE_EPOCH:\nnot_all_secrets_are_revealed = validator.all_custody_secrets_revealed_epoch == FAR_FUTURE_EPOCH\nif ValidatorIndex(index) in validator_indices_in_records or not_all_secrets_are_revealed:\n# Delay withdrawable epochs if challenge records are not empty or not all\n# custody secrets revealed\nvalidator.withdrawable_epoch = FAR_FUTURE_EPOCH\nelse:\n# Reset withdrawable epochs if challenge records are empty and all secrets are revealed\nif validator.withdrawable_epoch == FAR_FUTURE_EPOCH:\nvalidator.withdrawable_epoch = Epoch(validator.all_custody_secrets_revealed_epoch\n+ MIN_VALIDATOR_WITHDRAWABILITY_DELAY)\n</code></pre>"},{"location":"specs/_features/custody_game/validator/","title":"Custody Game -- Honest Validator","text":"<p>Notice: This document is a work-in-progress for researchers and implementers. This is an accompanying document to the Custody Game, which describes the expected actions of a \"validator\" participating in the shard data Custody Game.</p>"},{"location":"specs/_features/custody_game/validator/#table-of-contents","title":"Table of contents","text":"<ul> <li>Introduction</li> <li>Prerequisites</li> <li>Becoming a validator</li> <li>Beacon chain validator assignments<ul> <li>Custody slashings</li> <li>Custody key reveals</li> <li>Early derived secret reveals</li> <li>Construct attestation</li> </ul> </li> <li>How to avoid slashing</li> <li>Custody slashing</li> </ul>"},{"location":"specs/_features/custody_game/validator/#introduction","title":"Introduction","text":""},{"location":"specs/_features/custody_game/validator/#prerequisites","title":"Prerequisites","text":"<p>This document is an extension of the Sharding -- Validator. All behaviors and definitions defined in the Sharding doc carry over unless explicitly noted or overridden.</p> <p>All terminology, constants, functions, and protocol mechanics defined in the Custody Game -- The Beacon Chain docs are requisite for this document and used throughout. Please see the Custody Game docs before continuing and use them as a reference throughout.</p>"},{"location":"specs/_features/custody_game/validator/#becoming-a-validator","title":"Becoming a validator","text":"<p>Becoming a validator in Custody Game is unchanged from Phase 0. See the Phase 0 validator guide for details.</p>"},{"location":"specs/_features/custody_game/validator/#beacon-chain-validator-assignments","title":"Beacon chain validator assignments","text":"<p>Beacon chain validator assignments to beacon committees and beacon block proposal are unchanged from Phase 0. See the Phase 0 validator guide for details.</p>"},{"location":"specs/_features/custody_game/validator/#custody-slashings","title":"Custody slashings","text":"<p>Up to <code>MAX_CUSTODY_SLASHINGS</code>, <code>CustodySlashing</code> objects can be included in the <code>block</code>. The custody slashings must satisfy the verification conditions found in custody slashings processing. The validator receives a small \"whistleblower\" reward for each custody slashing included (THIS IS NOT CURRENTLY THE CASE BUT PROBABLY SHOULD BE).</p>"},{"location":"specs/_features/custody_game/validator/#custody-key-reveals","title":"Custody key reveals","text":"<p>Up to <code>MAX_CUSTODY_KEY_REVEALS</code>, <code>CustodyKeyReveal</code> objects can be included in the <code>block</code>. The custody key reveals must satisfy the verification conditions found in custody key reveal processing. The validator receives a small reward for each custody key reveal included.</p>"},{"location":"specs/_features/custody_game/validator/#early-derived-secret-reveals","title":"Early derived secret reveals","text":"<p>Up to <code>MAX_EARLY_DERIVED_SECRET_REVEALS</code>, <code>EarlyDerivedSecretReveal</code> objects can be included in the <code>block</code>. The early derived secret reveals must satisfy the verification conditions found in early derived secret reveal processing. The validator receives a small \"whistleblower\" reward for each early derived secret reveal included.</p>"},{"location":"specs/_features/custody_game/validator/#construct-attestation","title":"Construct attestation","text":"<p><code>attestation.data</code>, <code>attestation.aggregation_bits</code>, and <code>attestation.signature</code> are unchanged from Phase 0. But safety/validity in signing the message is premised upon calculation of the \"custody bit\" [TODO].</p>"},{"location":"specs/_features/custody_game/validator/#how-to-avoid-slashing","title":"How to avoid slashing","text":"<p>Proposer and Attester slashings described in Phase 0 remain in place with the addition of the following.</p>"},{"location":"specs/_features/custody_game/validator/#custody-slashing","title":"Custody slashing","text":"<p>To avoid custody slashings, the attester must never sign any shard transition for which the custody bit is one. The custody bit is computed using the custody secret:</p> <pre><code>def get_custody_secret(state: BeaconState,\nvalidator_index: ValidatorIndex,\nprivkey: int,\nepoch: Epoch=None) -&gt; BLSSignature:\nif epoch is None:\nepoch = get_current_epoch(state)\nperiod = get_custody_period_for_validator(validator_index, epoch)\nepoch_to_sign = get_randao_epoch_for_custody_period(period, validator_index)\ndomain = get_domain(state, DOMAIN_RANDAO, epoch_to_sign)\nsigning_root = compute_signing_root(Epoch(epoch_to_sign), domain)\nreturn bls.Sign(privkey, signing_root)\n</code></pre> <p>Note that the valid custody secret is always the one for the attestation target epoch, not to be confused with the epoch in which the shard block was generated. While they are the same most of the time, getting this wrong at custody epoch boundaries would result in a custody slashing.</p>"},{"location":"specs/_features/das/das-core/","title":"Data Availability Sampling -- Core","text":"<p>Notice: This document is a work-in-progress for researchers and implementers.</p>"},{"location":"specs/_features/das/das-core/#table-of-contents","title":"Table of contents","text":"<ul> <li>Custom types</li> <li>Configuration</li> <li>Misc</li> <li>New containers</li> <li><code>DASSample</code></li> <li>Helper functions</li> <li>Reverse bit ordering<ul> <li><code>reverse_bit_order</code></li> <li><code>reverse_bit_order_list</code></li> </ul> </li> <li>Data extension</li> <li>Data recovery</li> <li>DAS functions</li> </ul>"},{"location":"specs/_features/das/das-core/#custom-types","title":"Custom types","text":"<p>We define the following Python custom types for type hinting and readability:</p> Name SSZ equivalent Description <code>SampleIndex</code> <code>uint64</code> A sample index, corresponding to chunk of extended data"},{"location":"specs/_features/das/das-core/#configuration","title":"Configuration","text":""},{"location":"specs/_features/das/das-core/#misc","title":"Misc","text":"Name Value Notes <code>MAX_RESAMPLE_TIME</code> <code>TODO</code> (= TODO) Time window to sample a shard blob and put it on vertical subnets"},{"location":"specs/_features/das/das-core/#new-containers","title":"New containers","text":""},{"location":"specs/_features/das/das-core/#dassample","title":"<code>DASSample</code>","text":"<pre><code>class DASSample(Container):\nslot: Slot\nshard: Shard\nindex: SampleIndex\nproof: BLSCommitment\ndata: Vector[BLSPoint, POINTS_PER_SAMPLE]\n</code></pre>"},{"location":"specs/_features/das/das-core/#helper-functions","title":"Helper functions","text":""},{"location":"specs/_features/das/das-core/#reverse-bit-ordering","title":"Reverse bit ordering","text":""},{"location":"specs/_features/das/das-core/#reverse_bit_order","title":"<code>reverse_bit_order</code>","text":"<pre><code>def reverse_bit_order(n: int, order: int):\n\"\"\"\n    Reverse the bit order of an integer n\n    \"\"\"\nassert is_power_of_two(order)\nreturn int(('{:0' + str(order.bit_length() - 1) + 'b}').format(n)[::-1], 2)\n</code></pre>"},{"location":"specs/_features/das/das-core/#reverse_bit_order_list","title":"<code>reverse_bit_order_list</code>","text":"<pre><code>def reverse_bit_order_list(elements: Sequence[int]) -&gt; Sequence[int]:\norder = len(elements)\nassert is_power_of_two(order)\nreturn [elements[reverse_bit_order(i, order)] for i in range(order)]\n</code></pre>"},{"location":"specs/_features/das/das-core/#data-extension","title":"Data extension","text":"<p>Implementations: - Python - Go</p> <pre><code>def das_fft_extension(data: Sequence[Point]) -&gt; Sequence[Point]:\n\"\"\"\n    Given some even-index values of an IFFT input, compute the odd-index inputs,\n    such that the second output half of the IFFT is all zeroes.\n    \"\"\"\npoly = inverse_fft(data)\nreturn fft(poly + [0]*len(poly))[1::2]\n</code></pre>"},{"location":"specs/_features/das/das-core/#data-recovery","title":"Data recovery","text":"<p>See Reed-Solomon erasure code recovery in n*log^2(n) time with FFTs for theory. Implementations: - Original Python - New optimized approach in python - Old approach in Go</p> <pre><code>def recover_data(data: Sequence[Optional[Sequence[Point]]]) -&gt; Sequence[Point]:\n\"\"\"Given an a subset of half or more of subgroup-aligned ranges of values, recover the None values.\"\"\"\n...\n</code></pre>"},{"location":"specs/_features/das/das-core/#das-functions","title":"DAS functions","text":"<pre><code>def extend_data(data: Sequence[Point]) -&gt; Sequence[Point]:\n\"\"\"\n    The input data gets reverse-bit-ordered, such that the first half of the final output matches the original data.\n    We calculated the odd-index values with the DAS FFT extension, reverse-bit-order to put them in the second half.\n    \"\"\"\nrev_bit_odds = reverse_bit_order_list(das_fft_extension(reverse_bit_order_list(data)))\nreturn data + rev_bit_odds\n</code></pre> <pre><code>def unextend_data(extended_data: Sequence[Point]) -&gt; Sequence[Point]:\nreturn extended_data[:len(extended_data)//2]\n</code></pre> <pre><code>def check_multi_kzg_proof(commitment: BLSCommitment, proof: BLSCommitment, x: Point, ys: Sequence[Point]) -&gt; bool:\n\"\"\"\n    Run a KZG multi-proof check to verify that for the subgroup starting at x,\n    the proof indeed complements the ys to match the commitment.\n    \"\"\"\n...  # Omitted for now, refer to KZG implementation resources.\n</code></pre> <pre><code>def construct_proofs(extended_data_as_poly: Sequence[Point]) -&gt; Sequence[BLSCommitment]:\n\"\"\"\n    Constructs proofs for samples of extended data (in polynomial form, 2nd half being zeroes).\n    Use the FK20 multi-proof approach to construct proofs for a chunk length of POINTS_PER_SAMPLE.\n    \"\"\"\n... # Omitted for now, refer to KZG implementation resources.\n</code></pre> <pre><code>def commit_to_data(data_as_poly: Sequence[Point]) -&gt; BLSCommitment:\n\"\"\"Commit to a polynomial by \"\"\"\n</code></pre> <pre><code>def sample_data(slot: Slot, shard: Shard, extended_data: Sequence[Point]) -&gt; Sequence[DASSample]:\nsample_count = len(extended_data) // POINTS_PER_SAMPLE\nassert sample_count &lt;= MAX_SAMPLES_PER_BLOCK\n# get polynomial form of full extended data, second half will be all zeroes.\npoly = ifft(reverse_bit_order_list(extended_data))\nassert all(v == 0 for v in poly[len(poly)//2:])\nproofs = construct_proofs(poly)\nreturn [\nDASSample(\nslot=slot,\nshard=shard,\n# The proof applies to `x = w ** (reverse_bit_order(i, sample_count) * POINTS_PER_SAMPLE)`\nindex=i,\n# The computed proofs match the reverse_bit_order_list(extended_data), undo that to get the right proof.\nproof=proofs[reverse_bit_order(i, sample_count)],\n# note: we leave the sample data as-is so it matches the original nicely.\n# The proof applies to `ys = reverse_bit_order_list(sample.data)`\ndata=extended_data[i*POINTS_PER_SAMPLE:(i+1)*POINTS_PER_SAMPLE]\n) for i in range(sample_count)\n]\n</code></pre> <pre><code>def verify_sample(sample: DASSample, sample_count: uint64, commitment: BLSCommitment):\ndomain_pos = reverse_bit_order(sample.index, sample_count)\nsample_root_of_unity = ROOT_OF_UNITY**MAX_SAMPLES_PER_BLOCK  # change point-level to sample-level domain\nx = sample_root_of_unity**domain_pos\nys = reverse_bit_order_list(sample.data)\nassert check_multi_kzg_proof(commitment, sample.proof, x, ys)\n</code></pre> <pre><code>def reconstruct_extended_data(samples: Sequence[Optional[DASSample]]) -&gt; Sequence[Point]:\n# Instead of recovering with a point-by-point approach, recover the samples by recovering missing subgroups.\nsubgroups = [None if sample is None else reverse_bit_order_list(sample.data) for sample in samples]\nreturn recover_data(subgroups)\n</code></pre>"},{"location":"specs/_features/das/fork-choice/","title":"Data Availability Sampling -- Fork Choice","text":"<p>Notice: This document is a work-in-progress for researchers and implementers.</p>"},{"location":"specs/_features/das/fork-choice/#table-of-contents","title":"Table of contents","text":"<ul> <li>Introduction</li> <li>Dependency calculation</li> </ul>"},{"location":"specs/_features/das/fork-choice/#introduction","title":"Introduction","text":"<p>This document is the beacon chain fork choice spec for Data Availability Sampling. The only change that we add from phase 0 is that we add a concept of \"data dependencies\"; a block is only eligible for consideration in the fork choice after a data availability test has been successfully completed for all dependencies. The \"root\" of a shard block for data dependency purposes is considered to be a <code>DataCommitment</code> object, which is a pair of a Kate commitment and a length.</p>"},{"location":"specs/_features/das/fork-choice/#dependency-calculation","title":"Dependency calculation","text":"<pre><code>def get_new_dependencies(state: BeaconState) -&gt; Set[DataCommitment]:\nreturn set(\n# Already confirmed during this epoch\n[c.commitment for c in state.current_epoch_pending_headers if c.confirmed] +\n# Already confirmed during previous epoch\n[c.commitment for c in state.previous_epoch_pending_headers if c.confirmed] +\n# Confirmed in the epoch before the previous\n[c for c in shard for shard in state.grandparent_epoch_confirmed_commitments if c != DataCommitment()]\n)\n</code></pre> <pre><code>def get_all_dependencies(store: Store, block: BeaconBlock) -&gt; Set[DataCommitment]:\nif compute_epoch_at_slot(block.slot) &lt; SHARDING_FORK_EPOCH:\nreturn set()\nelse:\nlatest = get_new_dependencies(store.block_states[hash_tree_root(block)])\nolder = get_all_dependencies(store, store.blocks[block.parent_root])\nreturn latest.union(older)\n</code></pre>"},{"location":"specs/_features/das/p2p-interface/","title":"Data Availability Sampling -- Networking","text":"<p>Notice: This document is a work-in-progress for researchers and implementers.</p>"},{"location":"specs/_features/das/p2p-interface/#table-of-contents","title":"Table of contents","text":"<ul> <li>Introduction</li> <li>DAS Subnets</li> <li>Horizontal subnets<ul> <li>Publishing</li> <li>Horizontal propagation</li> <li>Horizontal to vertical</li> </ul> </li> <li>Vertical subnets<ul> <li>Slow rotation: Backbone</li> <li>Quick Rotation: Sampling</li> </ul> </li> <li>DAS in the Gossip domain: Push</li> <li>Topics and messages<ul> <li>Horizontal subnets: <code>shard_blob_{shard}</code></li> <li>Vertical subnets: <code>das_sample_{subnet_index}</code></li> </ul> </li> <li>DAS in the Req-Resp domain: Pull</li> <li>Messages<ul> <li>DASQuery</li> </ul> </li> </ul>"},{"location":"specs/_features/das/p2p-interface/#introduction","title":"Introduction","text":"<p>For an introduction about DAS itself, see the DAS participation spec. This is not a pre-requisite for the network layer, but will give you valuable context. </p> <p>For sampling, all nodes need to query for <code>k</code> random samples each slot.</p> <p>TODO: describe big picture of sampling workload size</p> <p>This is a lot of work, and ideally happens at a low latency.</p> <p>To achieve quick querying, the query model is changed to push the samples to listeners instead, using GossipSub. The listeners then randomly rotate their subscriptions to keep queries unpredictable. Except for a small subset of subscriptions, which will function as a backbone to keep topics more stable and allow for efficient peer discovery.</p> <p>Publishing can utilize the fan-out functionality in GossipSub, and is easier to split between nodes: nodes on the horizontal networks can help by producing the same samples and fan-out publishing to their own peers.</p> <p>This push model also helps to obfuscate the original source of a message: the listeners do not have to make individual queries to some identified source.</p> <p>The push model does not aim to serve \"historical\" queries (anything older than the most recent). Historical queries are still required for the unhappy case, where messages are not pushed quick enough, and missing samples are not reconstructed by other nodes on the horizontal subnet quick enough.</p> <p>The main challenge in supporting historical queries is to target the right nodes,  without concentrating too many requests on a single node, or breaking the network/consensus identity separation.</p>"},{"location":"specs/_features/das/p2p-interface/#das-subnets","title":"DAS Subnets","text":"<p>On a high level, the push-model roles are divided into: - Sources: create blobs of shard block data, and transformed into many tiny samples.  - Sinks: continuously look for samples</p> <p>At full operation, the network has one proposer, per shard, per slot.</p> <p>In the push-model, there are: - Vertical subnets: Sinks can subscribe to indices of samples: there is a sample to subnet mapping. - Horizontal subnets: Sources need to distribute samples to all vertical networks: they participate in a fan-out layer.</p>"},{"location":"specs/_features/das/p2p-interface/#horizontal-subnets","title":"Horizontal subnets","text":"<p>The shift of the distribution responsibility to a proposer can only be achieved with amplification: a regular proposer cannot reach every vertical subnet.</p>"},{"location":"specs/_features/das/p2p-interface/#publishing","title":"Publishing","text":"<p>To publish their work, proposers propagate the shard block as a whole on a shard-block subnet.</p> <p>The proposer can fan-out their work more aggressively, by using the fan-out functionality of GossipSub: it may publish to all its peers on the subnet, instead of just those in its mesh.</p>"},{"location":"specs/_features/das/p2p-interface/#horizontal-propagation","title":"Horizontal propagation","text":"<p>Peers on the horizontal subnet are expected to at least perform regular propagation of shard blocks, like participation in any other topic.</p> <p>Although this may be sufficient for testnets, expect parameter changes in the spec here.</p>"},{"location":"specs/_features/das/p2p-interface/#horizontal-to-vertical","title":"Horizontal to vertical","text":"<p>Nodes on this same subnet can replicate the sampling efficiently (including a proof for each sample), and distribute it to any vertical networks that are available to them.</p> <p>Since the messages are content-addressed (instead of origin-stamped),  multiple publishers of the same samples on a vertical subnet do not hurt performance,  but actually improve it by shortcutting regular propagation on the vertical subnet, and thus lowering the latency to a sample.</p>"},{"location":"specs/_features/das/p2p-interface/#vertical-subnets","title":"Vertical subnets","text":"<p>Vertical subnets propagate the samples to every peer that is interested. These interests are randomly sampled and rotate quickly: although not perfect,  sufficient to avoid any significant amount of nodes from being 100% predictable.</p> <p>As soon as a sample is missing after the expected propagation time window, nodes can divert to the pull-model, or ultimately flag it as unavailable data.</p> <p>Note that the vertical subnets are shared between the different shards, and a simple hash function <code>(shard, slot, sample_index) -&gt; subnet_index</code> defines which samples go where. This is to evenly distribute samples to subnets, even when one shard has more activity than the other.</p> <p>TODO: define <code>(shard, slot, sample_index) -&gt; subnet_index</code> hash function.</p>"},{"location":"specs/_features/das/p2p-interface/#slow-rotation-backbone","title":"Slow rotation: Backbone","text":"<p>To allow for subscriptions to rotate quickly and randomly, a backbone is formed to help onboard peers into other topics.</p> <p>This backbone is based on a pure function of the node identity and time: - Nodes can be found without additional discovery overhead:   peers on a vertical topic can be found by searching the local peerstore for identities that hash to the desired topic(s),   assuming the peerstore already has a large enough variety of peers. - Nodes can be held accountable for contributing to the backbone:   peers that participate in DAS but are not active on the appropriate backbone topics can be scored down.   Note: This is experimental, DAS should be light enough for all participants to run, but scoring needs to undergo testing</p> <p>A node should anticipate backbone topics to subscribe to based their own identity. These subscriptions rotate slowly, and with different offsets per node identity to avoid sudden network-wide rotations.</p> <pre><code># TODO hash function: (node, time)-&gt;subnets\n</code></pre> <p>Backbone subscription work is outlined in the DAS participation spec</p>"},{"location":"specs/_features/das/p2p-interface/#quick-rotation-sampling","title":"Quick Rotation: Sampling","text":"<p>A node MUST maintain <code>k</code> random subscriptions to topics, and rotate these according to the DAS participation spec. If the node does not already have connected peers on the topic it needs to sample, it can search its peerstore and, if necessary, in the DHT for peers in the topic backbone.</p>"},{"location":"specs/_features/das/p2p-interface/#das-in-the-gossip-domain-push","title":"DAS in the Gossip domain: Push","text":""},{"location":"specs/_features/das/p2p-interface/#topics-and-messages","title":"Topics and messages","text":"<p>Following the same scheme as the Phase0 gossip topics, names and payload types are: | Name                             | Message Type              | |----------------------------------|---------------------------| | <code>das_sample_{subnet_index}</code>      | <code>DASSample</code>               |</p> <p>Also see the Sharding general networking spec for important topics such as that of the shard-blobs and shard-headers.</p>"},{"location":"specs/_features/das/p2p-interface/#horizontal-subnets-shard_blob_shard","title":"Horizontal subnets: <code>shard_blob_{shard}</code>","text":"<p>Extending the regular <code>shard_blob_{shard}</code> as defined in the Sharding networking specification</p> <p>If participating in DAS, upon receiving a <code>signed_blob</code> for the first time with a <code>slot</code> not older than <code>MAX_RESAMPLE_TIME</code>, a subscriber of a <code>shard_blob_{shard}</code> SHOULD reconstruct the samples and publish them to vertical subnets. Take <code>blob = signed_blob.blob</code>: 1. Extend the data: <code>extended_data = extend_data(blob.data)</code> 2. Create samples with proofs: <code>samples = sample_data(blob.slot, blob.shard, extended_data)</code> 3. Fanout-publish the samples to the vertical subnets of its peers (not all vertical subnets may be reached).</p> <p>The DAS participation spec outlines when and where to participate in DAS on horizontal subnets.</p>"},{"location":"specs/_features/das/p2p-interface/#vertical-subnets-das_sample_subnet_index","title":"Vertical subnets: <code>das_sample_{subnet_index}</code>","text":"<p>Shard blob samples can be verified with just a 48 byte KZG proof (commitment quotient polynomial),  against the commitment to blob polynomial, specific to that <code>(shard, slot)</code> key.</p> <p>The following validations MUST pass before forwarding the <code>sample</code> on the vertical subnet. - [IGNORE] The commitment for the (<code>sample.shard</code>, <code>sample.slot</code>, <code>sample.index</code>) tuple must be known.    If not known, the client MAY queue the sample if it passes formatting conditions. - [REJECT] <code>sample.shard</code>, <code>sample.slot</code> and <code>sample.index</code> are hashed into a <code>sbunet_index</code> (TODO: define hash) which MUST match the topic <code>{subnet_index}</code> parameter. - [REJECT] <code>sample.shard</code> must be within valid range: <code>0 &lt;= sample.shard &lt; get_active_shard_count(state, compute_epoch_at_slot(sample.slot))</code>. - [REJECT] <code>sample.index</code> must be within valid range: <code>0 &lt;= sample.index &lt; sample_count</code>, where:     - <code>sample_count = (points_count + POINTS_PER_SAMPLE - 1) // POINTS_PER_SAMPLE</code>     - <code>points_count</code> is the length as claimed along with the commitment, which must be smaller than <code>MAX_SAMPLES_PER_BLOCK</code>. - [IGNORE] The <code>sample</code> is not from a future slot (with a <code>MAXIMUM_GOSSIP_CLOCK_DISPARITY</code> allowance) --   i.e. validate that <code>sample.slot &lt;= current_slot</code>. A client MAY queue future samples for processing at the appropriate slot if it passed formatting conditions. - [IGNORE] This is the first received sample with the (<code>sample.shard</code>, <code>sample.slot</code>, <code>sample.index</code>) key tuple. - [REJECT] As already limited by the SSZ list-limit, it is important the sample data is well-formatted and not too large. - [REJECT] The <code>sample.data</code> MUST NOT contain any point <code>p &gt;= MODULUS</code>. Although it is a <code>uint256</code>, not the full 256 bit range is valid. - [REJECT] The <code>sample.proof</code> MUST be valid: <code>verify_sample(sample, sample_count, commitment)</code></p> <p>Upon receiving a valid sample, it SHOULD be retained for a buffer period if the local node is part of the backbone that covers this sample. This is to serve other peers that may have missed it.</p>"},{"location":"specs/_features/das/p2p-interface/#das-in-the-req-resp-domain-pull","title":"DAS in the Req-Resp domain: Pull","text":"<p>To pull samples from nodes, in case of network instability when samples are unavailable, a new query method is added to the Req-Resp domain.</p> <p>This builds on top of the protocol identification and encoding spec which was introduced in the Phase0 network spec. </p> <p>Note that DAS networking uses a different protocol prefix: <code>/eth2/das/req</code></p>"},{"location":"specs/_features/das/p2p-interface/#messages","title":"Messages","text":""},{"location":"specs/_features/das/p2p-interface/#dasquery","title":"DASQuery","text":"<p>Protocol ID: <code>/eth2/das/req/query/1/</code></p> <p>Request Content: <pre><code>(\n  sample_index: SampleIndex\n)\n</code></pre></p> <p>Response Content: <pre><code>(\n  DASSample\n)\n</code></pre></p> <p>When the sample is: - Available: respond with a <code>Success</code> result code, and the encoded sample. - Expected to be available, but not: respond with a <code>ResourceUnavailable</code> result code. - Not available, but never of interest to the node: respond with an <code>InvalidRequest</code> result code.</p> <p>When the node is part of the backbone and expected to have the sample, the validity of the quest MUST be recognized with <code>Success</code> or <code>ResourceUnavailable</code>.</p>"},{"location":"specs/_features/das/sampling/","title":"Data Availability Sampling -- Sampling","text":"<p>Notice: This document is a work-in-progress for researchers and implementers.</p>"},{"location":"specs/_features/das/sampling/#table-of-contents","title":"Table of contents","text":"<ul> <li>Data Availability Sampling</li> <li>GossipSub</li> <li>Horizontal subnets</li> <li>Vertical subnets<ul> <li>Slow rotation: Backbone</li> <li>Quick rotation: Sampling</li> </ul> </li> <li>DAS during network instability<ul> <li>Stage 0: Waiting on missing samples</li> <li>Stage 1: Pulling missing samples from known peers</li> <li>Stage 2: Pulling missing data from validators with custody.</li> </ul> </li> </ul>"},{"location":"specs/_features/das/sampling/#data-availability-sampling","title":"Data Availability Sampling","text":"<p>TODO: Summary of Data Availability problem</p> <p>TODO: Summary of solution, why 2x extension, and randomized samples</p>"},{"location":"specs/_features/das/sampling/#gossipsub","title":"GossipSub","text":""},{"location":"specs/_features/das/sampling/#horizontal-subnets","title":"Horizontal subnets","text":"<p>TODO</p>"},{"location":"specs/_features/das/sampling/#vertical-subnets","title":"Vertical subnets","text":""},{"location":"specs/_features/das/sampling/#slow-rotation-backbone","title":"Slow rotation: Backbone","text":"<p>TODO</p>"},{"location":"specs/_features/das/sampling/#quick-rotation-sampling","title":"Quick rotation: Sampling","text":"<p>TODO</p>"},{"location":"specs/_features/das/sampling/#das-during-network-instability","title":"DAS during network instability","text":"<p>The GossipSub based retrieval of samples may not always work. In such event, a node can move through below stages until it recovers data availability.</p>"},{"location":"specs/_features/das/sampling/#stage-0-waiting-on-missing-samples","title":"Stage 0: Waiting on missing samples","text":"<p>Wait for the sample to re-broadcast. Someone may be slow with publishing, or someone else is able to do the work.</p> <p>Any node can do the following work to keep the network healthy: - Common: Listen on a horizontal subnet, chunkify the block data in samples, and propagate the samples to vertical subnets. - Extreme: Listen on enough vertical subnets, reconstruct the missing samples by recovery, and propagate the recovered samples.</p> <p>This is not a requirement, but should improve the network stability with little resources, and without any central party.</p>"},{"location":"specs/_features/das/sampling/#stage-1-pulling-missing-samples-from-known-peers","title":"Stage 1: Pulling missing samples from known peers","text":"<p>The more realistic option, to execute when a sample is missing, is to query any node that is known to hold it. Since consensus identity is disconnected from network identity, there is no direct way to contact custody holders without explicitly asking for the data.</p> <p>However, network identities are still used to build a backbone for each vertical subnet. These nodes should have received the samples, and can serve a buffer of them on demand. Although serving these is not directly incentivised, it is little work: 1. Buffer any message you see on the backbone vertical subnets, for a buffer of up to two weeks. 2. Serve the samples on request. An individual sample is just expected to be <code>~ 0.5 KB</code>, and does not require any pre-processing to serve.</p> <p>A validator SHOULD make a <code>DASQuery</code> request to random peers, until failing more than the configured failure-rate.</p> <p>TODO: detailed failure-mode spec. Stop after trying e.g. 3 peers for any sample in a configured time window (after the gossip period).</p>"},{"location":"specs/_features/das/sampling/#stage-2-pulling-missing-data-from-validators-with-custody","title":"Stage 2: Pulling missing data from validators with custody.","text":"<p>Pulling samples directly from nodes with validators that have a custody responsibility, without revealing their identity to the network, is an open problem.</p>"},{"location":"specs/_features/eip6914/beacon-chain/","title":"EIP-6914 -- The Beacon Chain","text":""},{"location":"specs/_features/eip6914/beacon-chain/#table-of-contents","title":"Table of contents","text":"<ul> <li>Introduction</li> <li>Preset</li> <li>Time parameters</li> <li>Helper functions</li> <li>Predicates<ul> <li><code>is_reusable_validator</code></li> </ul> </li> <li>Beacon chain state transition function</li> <li>Block processing<ul> <li>Modified <code>get_index_for_new_validator</code></li> </ul> </li> </ul>"},{"location":"specs/_features/eip6914/beacon-chain/#introduction","title":"Introduction","text":"<p>This is the beacon chain specification to assign new deposits to existing validator records. Refers to EIP-6914.</p> <p>Note: This specification is built upon Capella and is under active development.</p>"},{"location":"specs/_features/eip6914/beacon-chain/#preset","title":"Preset","text":""},{"location":"specs/_features/eip6914/beacon-chain/#time-parameters","title":"Time parameters","text":"Name Value Unit Duration <code>SAFE_EPOCHS_TO_REUSE_INDEX</code> <code>uint64(2**16)</code> (= 65,536) epochs ~0.8 year"},{"location":"specs/_features/eip6914/beacon-chain/#helper-functions","title":"Helper functions","text":""},{"location":"specs/_features/eip6914/beacon-chain/#predicates","title":"Predicates","text":""},{"location":"specs/_features/eip6914/beacon-chain/#is_reusable_validator","title":"<code>is_reusable_validator</code>","text":"<pre><code>def is_reusable_validator(validator: Validator, balance: Gwei, epoch: Epoch) -&gt; bool:\n\"\"\"\n    Check if ``validator`` index can be re-assigned to a new deposit.\n    \"\"\"\nreturn (\nepoch &gt; validator.withdrawable_epoch + SAFE_EPOCHS_TO_REUSE_INDEX\nand balance == 0\n)\n</code></pre>"},{"location":"specs/_features/eip6914/beacon-chain/#beacon-chain-state-transition-function","title":"Beacon chain state transition function","text":""},{"location":"specs/_features/eip6914/beacon-chain/#block-processing","title":"Block processing","text":""},{"location":"specs/_features/eip6914/beacon-chain/#modified-get_index_for_new_validator","title":"Modified <code>get_index_for_new_validator</code>","text":"<pre><code>def get_index_for_new_validator(state: BeaconState) -&gt; ValidatorIndex:\nfor index, validator in enumerate(state.validators):\nif is_reusable_validator(validator, state.balances[index], get_current_epoch(state)):\nreturn ValidatorIndex(index)\nreturn ValidatorIndex(len(state.validators))\n</code></pre>"},{"location":"specs/_features/eip6914/fork-choice/","title":"EIP-6914 -- Fork Choice","text":""},{"location":"specs/_features/eip6914/fork-choice/#table-of-contents","title":"Table of contents","text":"<ul> <li>Introduction</li> <li>Fork choice</li> <li>Handlers<ul> <li><code>on_reused_index</code></li> </ul> </li> </ul>"},{"location":"specs/_features/eip6914/fork-choice/#introduction","title":"Introduction","text":"<p>This is the modification of the fork choice according to EIP-6914.</p>"},{"location":"specs/_features/eip6914/fork-choice/#fork-choice","title":"Fork choice","text":"<p>A new handler is added with this upgrade:</p> <ul> <li><code>on_reused_index(store, index)</code> whenever a validator index <code>index: ValidatorIndex</code> is reused. That is, <code>get_index_for_new_validator()</code> provides an index due to a return value of <code>True</code> from <code>is_reusable_validator()</code>.</li> </ul> <p>This new handler is used to update the list of equivocating indices to be synchronized with the canonical chain.</p>"},{"location":"specs/_features/eip6914/fork-choice/#handlers","title":"Handlers","text":""},{"location":"specs/_features/eip6914/fork-choice/#on_reused_index","title":"<code>on_reused_index</code>","text":"<pre><code>def on_reused_index(store: Store, index: ValidatorIndex) -&gt; None:\nstore.equivocating_indices.discard(index)\n</code></pre>"},{"location":"specs/_features/eip7594/das-core/","title":"EIP-7594 -- Data Availability Sampling Core","text":"<p>Notice: This document is a work-in-progress for researchers and implementers.</p>"},{"location":"specs/_features/eip7594/das-core/#table-of-contents","title":"Table of contents","text":"<ul> <li>Constants</li> <li>Misc</li> <li>Custom types</li> <li>Configuration</li> <li>Data size</li> <li>Networking</li> <li>Custody setting</li> <li>Containers<ul> <li><code>DataColumnSidecar</code></li> </ul> </li> <li>Helper functions<ul> <li><code>get_custody_columns</code></li> <li><code>compute_extended_matrix</code></li> <li><code>recover_matrix</code></li> <li><code>get_data_column_sidecars</code></li> </ul> </li> <li>Custody</li> <li>Custody requirement</li> <li>Public, deterministic selection</li> <li>Peer discovery</li> <li>Extended data</li> <li>Column gossip</li> <li>Parameters</li> <li>Peer sampling</li> <li>Peer scoring</li> <li>Reconstruction and cross-seeding</li> <li>DAS providers</li> <li>A note on fork choice</li> <li>FAQs</li> <li>Row (blob) custody</li> <li>Subnet stability</li> </ul>"},{"location":"specs/_features/eip7594/das-core/#constants","title":"Constants","text":"<p>The following values are (non-configurable) constants used throughout the specification.</p>"},{"location":"specs/_features/eip7594/das-core/#misc","title":"Misc","text":"Name Value <code>UINT256_MAX</code> <code>uint256(2**256 - 1)</code>"},{"location":"specs/_features/eip7594/das-core/#custom-types","title":"Custom types","text":"<p>We define the following Python custom types for type hinting and readability:</p> Name SSZ equivalent Description <code>DataColumn</code> <code>List[Cell, MAX_BLOB_COMMITMENTS_PER_BLOCK]</code> The data of each column in EIP-7594 <code>ExtendedMatrix</code> <code>List[Cell, MAX_CELLS_IN_EXTENDED_MATRIX]</code> The full data of one-dimensional erasure coding extended blobs (in row major format)."},{"location":"specs/_features/eip7594/das-core/#configuration","title":"Configuration","text":""},{"location":"specs/_features/eip7594/das-core/#data-size","title":"Data size","text":"Name Value Description <code>NUMBER_OF_COLUMNS</code> <code>uint64(CELLS_PER_EXT_BLOB)</code> (= 128) Number of columns in the extended data matrix. <code>MAX_CELLS_IN_EXTENDED_MATRIX</code> <code>uint64(MAX_BLOBS_PER_BLOCK * NUMBER_OF_COLUMNS)</code> (= 768) The data size of <code>ExtendedMatrix</code>."},{"location":"specs/_features/eip7594/das-core/#networking","title":"Networking","text":"Name Value Description <code>DATA_COLUMN_SIDECAR_SUBNET_COUNT</code> <code>32</code> The number of data column sidecar subnets used in the gossipsub protocol"},{"location":"specs/_features/eip7594/das-core/#custody-setting","title":"Custody setting","text":"Name Value Description <code>SAMPLES_PER_SLOT</code> <code>8</code> Number of <code>DataColumn</code> random samples a node queries per slot <code>CUSTODY_REQUIREMENT</code> <code>1</code> Minimum number of subnets an honest node custodies and serves samples from <code>TARGET_NUMBER_OF_PEERS</code> <code>70</code> Suggested minimum peer count"},{"location":"specs/_features/eip7594/das-core/#containers","title":"Containers","text":""},{"location":"specs/_features/eip7594/das-core/#datacolumnsidecar","title":"<code>DataColumnSidecar</code>","text":"<pre><code>class DataColumnSidecar(Container):\nindex: ColumnIndex  # Index of column in extended matrix\ncolumn: DataColumn\nkzg_commitments: List[KZGCommitment, MAX_BLOB_COMMITMENTS_PER_BLOCK]\nkzg_proofs: List[KZGProof, MAX_BLOB_COMMITMENTS_PER_BLOCK]\nsigned_block_header: SignedBeaconBlockHeader\nkzg_commitments_inclusion_proof: Vector[Bytes32, KZG_COMMITMENTS_INCLUSION_PROOF_DEPTH]\n</code></pre>"},{"location":"specs/_features/eip7594/das-core/#helper-functions","title":"Helper functions","text":""},{"location":"specs/_features/eip7594/das-core/#get_custody_columns","title":"<code>get_custody_columns</code>","text":"<pre><code>def get_custody_columns(node_id: NodeID, custody_subnet_count: uint64) -&gt; Sequence[ColumnIndex]:\nassert custody_subnet_count &lt;= DATA_COLUMN_SIDECAR_SUBNET_COUNT\nsubnet_ids = []\ni = 0\nwhile len(subnet_ids) &lt; custody_subnet_count:\nif node_id == UINT256_MAX:\nnode_id = 0\nsubnet_id = (\nbytes_to_uint64(hash(uint_to_bytes(uint256(node_id + i)))[0:8])\n% DATA_COLUMN_SIDECAR_SUBNET_COUNT\n)\nif subnet_id not in subnet_ids:\nsubnet_ids.append(subnet_id)\ni += 1\nassert len(subnet_ids) == len(set(subnet_ids))\ncolumns_per_subnet = NUMBER_OF_COLUMNS // DATA_COLUMN_SIDECAR_SUBNET_COUNT\nreturn sorted([\nColumnIndex(DATA_COLUMN_SIDECAR_SUBNET_COUNT * i + subnet_id)\nfor i in range(columns_per_subnet)\nfor subnet_id in subnet_ids\n])\n</code></pre>"},{"location":"specs/_features/eip7594/das-core/#compute_extended_matrix","title":"<code>compute_extended_matrix</code>","text":"<pre><code>def compute_extended_matrix(blobs: Sequence[Blob]) -&gt; ExtendedMatrix:\n\"\"\"\n    Return the full ``ExtendedMatrix``.\n    This helper demonstrates the relationship between blobs and ``ExtendedMatrix``.\n    The data structure for storing cells is implementation-dependent.\n    \"\"\"\nextended_matrix = []\nfor blob in blobs:\nextended_matrix.extend(compute_cells(blob))\nreturn ExtendedMatrix(extended_matrix)\n</code></pre>"},{"location":"specs/_features/eip7594/das-core/#recover_matrix","title":"<code>recover_matrix</code>","text":"<pre><code>def recover_matrix(cells_dict: Dict[Tuple[BlobIndex, CellID], Cell], blob_count: uint64) -&gt; ExtendedMatrix:\n\"\"\"\n    Return the recovered ``ExtendedMatrix``.\n    This helper demonstrates how to apply ``recover_all_cells``.\n    The data structure for storing cells is implementation-dependent.\n    \"\"\"\nextended_matrix = []\nfor blob_index in range(blob_count):\ncell_ids = [cell_id for b_index, cell_id in cells_dict.keys() if b_index == blob_index]\ncells = [cells_dict[(blob_index, cell_id)] for cell_id in cell_ids]\nall_cells_for_row = recover_all_cells(cell_ids, cells)\nextended_matrix.extend(all_cells_for_row)\nreturn ExtendedMatrix(extended_matrix)\n</code></pre>"},{"location":"specs/_features/eip7594/das-core/#get_data_column_sidecars","title":"<code>get_data_column_sidecars</code>","text":"<pre><code>def get_data_column_sidecars(signed_block: SignedBeaconBlock,\nblobs: Sequence[Blob]) -&gt; Sequence[DataColumnSidecar]:\nsigned_block_header = compute_signed_block_header(signed_block)\nblock = signed_block.message\nkzg_commitments_inclusion_proof = compute_merkle_proof(\nblock.body,\nget_generalized_index(BeaconBlockBody, 'blob_kzg_commitments'),\n)\ncells_and_proofs = [compute_cells_and_kzg_proofs(blob) for blob in blobs]\nblob_count = len(blobs)\ncells = [cells_and_proofs[i][0] for i in range(blob_count)]\nproofs = [cells_and_proofs[i][1] for i in range(blob_count)]\nsidecars = []\nfor column_index in range(NUMBER_OF_COLUMNS):\ncolumn = DataColumn([cells[row_index][column_index]\nfor row_index in range(blob_count)])\nkzg_proof_of_column = [proofs[row_index][column_index]\nfor row_index in range(blob_count)]\nsidecars.append(DataColumnSidecar(\nindex=column_index,\ncolumn=column,\nkzg_commitments=block.body.blob_kzg_commitments,\nkzg_proofs=kzg_proof_of_column,\nsigned_block_header=signed_block_header,\nkzg_commitments_inclusion_proof=kzg_commitments_inclusion_proof,\n))\nreturn sidecars\n</code></pre>"},{"location":"specs/_features/eip7594/das-core/#custody","title":"Custody","text":""},{"location":"specs/_features/eip7594/das-core/#custody-requirement","title":"Custody requirement","text":"<p>Each node downloads and custodies a minimum of <code>CUSTODY_REQUIREMENT</code> subnets per slot. The particular subnets that the node is required to custody are selected pseudo-randomly (more on this below).</p> <p>A node may choose to custody and serve more than the minimum honesty requirement. Such a node explicitly advertises a number greater than <code>CUSTODY_REQUIREMENT</code> via the peer discovery mechanism -- for example, in their ENR (e.g. <code>custody_subnet_count: 4</code> if the node custodies <code>4</code> subnets each slot) -- up to a <code>DATA_COLUMN_SIDECAR_SUBNET_COUNT</code> (i.e. a super-full node).</p> <p>A node stores the custodied columns for the duration of the pruning period and responds to peer requests for samples on those columns.</p>"},{"location":"specs/_features/eip7594/das-core/#public-deterministic-selection","title":"Public, deterministic selection","text":"<p>The particular columns that a node custodies are selected pseudo-randomly as a function (<code>get_custody_columns</code>) of the node-id and custody size -- importantly this function can be run by any party as the inputs are all public.</p> <p>Note: increasing the <code>custody_size</code> parameter for a given <code>node_id</code> extends the returned list (rather than being an entirely new shuffle) such that if <code>custody_size</code> is unknown, the default <code>CUSTODY_REQUIREMENT</code> will be correct for a subset of the node's custody.</p>"},{"location":"specs/_features/eip7594/das-core/#peer-discovery","title":"Peer discovery","text":"<p>At each slot, a node needs to be able to readily sample from any set of columns. To this end, a node SHOULD find and maintain a set of diverse and reliable peers that can regularly satisfy their sampling demands.</p> <p>A node runs a background peer discovery process, maintaining at least <code>TARGET_NUMBER_OF_PEERS</code> of various custody distributions (both <code>custody_size</code> and column assignments). The combination of advertised <code>custody_size</code> size and public node-id make this readily and publicly accessible.</p> <p><code>TARGET_NUMBER_OF_PEERS</code> should be tuned upward in the event of failed sampling.</p> <p>Note: while high-capacity and super-full nodes are high value with respect to satisfying sampling requirements, a node SHOULD maintain a distribution across node capacities as to not centralize the p2p graph too much (in the extreme becomes hub/spoke) and to distribute sampling load better across all nodes.</p> <p>Note: A DHT-based peer discovery mechanism is expected to be utilized in the above. The beacon-chain network currently utilizes discv5 in a similar method as described for finding peers of particular distributions of attestation subnets. Additional peer discovery methods are valuable to integrate (e.g., latent peer discovery via libp2p gossipsub) to add a defense in breadth against one of the discovery methods being attacked.</p>"},{"location":"specs/_features/eip7594/das-core/#extended-data","title":"Extended data","text":"<p>In this construction, we extend the blobs using a one-dimensional erasure coding extension. The matrix comprises maximum <code>MAX_BLOBS_PER_BLOCK</code> rows and fixed <code>NUMBER_OF_COLUMNS</code> columns, with each row containing a <code>Blob</code> and its corresponding extension. <code>compute_extended_matrix</code> demonstrates the relationship between blobs and custom type <code>ExtendedMatrix</code>.</p>"},{"location":"specs/_features/eip7594/das-core/#column-gossip","title":"Column gossip","text":""},{"location":"specs/_features/eip7594/das-core/#parameters","title":"Parameters","text":"<p>For each column -- use <code>data_column_sidecar_{subnet_id}</code> subnets, where <code>subnet_id</code> can be computed with the <code>compute_subnet_for_data_column_sidecar(column_index: ColumnIndex)</code> helper. The sidecars can be computed with the <code>get_data_column_sidecars(signed_block: SignedBeaconBlock, blobs: Sequence[Blob])</code> helper.</p> <p>To custody a particular column, a node joins the respective gossip subnet. Verifiable samples from their respective column are gossiped on the assigned subnet.</p>"},{"location":"specs/_features/eip7594/das-core/#peer-sampling","title":"Peer sampling","text":"<p>A node SHOULD maintain a diverse set of peers for each column and each slot by verifying responsiveness to sample queries. At each slot, a node makes <code>SAMPLES_PER_SLOT</code> queries for samples from their peers via <code>DataColumnSidecarsByRoot</code> request. A node utilizes <code>get_custody_columns</code> helper to determine which peer(s) to request from. If a node has enough good/honest peers across all rows and columns, this has a high chance of success.</p>"},{"location":"specs/_features/eip7594/das-core/#peer-scoring","title":"Peer scoring","text":"<p>Due to the deterministic custody functions, a node knows exactly what a peer should be able to respond to. In the event that a peer does not respond to samples of their custodied rows/columns, a node may downscore or disconnect from a peer.</p>"},{"location":"specs/_features/eip7594/das-core/#reconstruction-and-cross-seeding","title":"Reconstruction and cross-seeding","text":"<p>If the node obtains 50%+ of all the columns, they can reconstruct the full data matrix via <code>recover_matrix</code> helper.</p> <p>If a node fails to sample a peer or fails to get a column on the column subnet, a node can utilize the Req/Resp message to query the missing column from other peers.</p> <p>Once the node obtain the column, the node SHOULD send the missing columns to the column subnets.</p> <p>Note: A node always maintains a matrix view of the rows and columns they are following, able to cross-reference and cross-seed in either direction.</p> <p>Note: There are timing considerations to analyze -- at what point does a node consider samples missing and choose to reconstruct and cross-seed.</p> <p>Note: There may be anti-DoS and quality-of-service considerations around how to send samples and consider samples -- is each individual sample a message or are they sent in aggregate forms.</p>"},{"location":"specs/_features/eip7594/das-core/#das-providers","title":"DAS providers","text":"<p>A DAS provider is a consistently-available-for-DAS-queries, super-full (or high capacity) node. To the p2p, these look just like other nodes but with high advertised capacity, and they should generally be able to be latently found via normal discovery.</p> <p>DAS providers can also be found out-of-band and configured into a node to connect to directly and prioritize. Nodes can add some set of these to their local configuration for persistent connection to bolster their DAS quality of service.</p> <p>Such direct peering utilizes a feature supported out of the box today on all nodes and can complement (and reduce attackability and increase quality-of-service) alternative peer discovery mechanisms.</p>"},{"location":"specs/_features/eip7594/das-core/#a-note-on-fork-choice","title":"A note on fork choice","text":"<p>Fork choice spec TBD, but it will just be a replacement of <code>is_data_available()</code> call in Deneb with column sampling instead of full download. Note the <code>is_data_available(slot_N)</code> will likely do a <code>-1</code> follow distance so that you just need to check the availability of slot <code>N-1</code> for slot <code>N</code> (starting with the block proposer of <code>N</code>).</p> <p>The fork choice rule (essentially a DA filter) is orthogonal to a given DAS design, other than the efficiency of a particular design impacting it.</p> <p>In any DAS design, there are probably a few degrees of freedom around timing, acceptability of short-term re-orgs, etc. </p> <p>For example, the fork choice rule might require validators to do successful DAS on slot <code>N</code> to be able to include block of slot <code>N</code> in its fork choice. That's the tightest DA filter. But trailing filters are also probably acceptable, knowing that there might be some failures/short re-orgs but that they don't hurt the aggregate security. For example, the rule could be \u2014 DAS must be completed for slot N-1 for a child block in N to be included in the fork choice.</p> <p>Such trailing techniques and their analysis will be valuable for any DAS construction. The question is \u2014 can you relax how quickly you need to do DA and in the worst case not confirm unavailable data via attestations/finality, and what impact does it have on short-term re-orgs and fast confirmation rules.</p>"},{"location":"specs/_features/eip7594/das-core/#faqs","title":"FAQs","text":""},{"location":"specs/_features/eip7594/das-core/#row-blob-custody","title":"Row (blob) custody","text":"<p>In the one-dimension construction, a node samples the peers by requesting the whole <code>DataColumn</code>. In reconstruction, a node can reconstruct all the blobs by 50% of the columns. Note that nodes can still download the row via <code>blob_sidecar_{subnet_id}</code> subnets.</p> <p>The potential benefits of having row custody could include:</p> <ol> <li>Allow for more \"natural\" distribution of data to consumers -- e.g., roll-ups -- but honestly, they won't know a priori which row their blob is going to be included in in the block, so they would either need to listen to all rows or download a particular row after seeing the block. The former looks just like listening to column [0, N)  and the latter is req/resp instead of gossiping.</li> <li>Help with some sort of distributed reconstruction. Those with full rows can compute extensions and seed missing samples to the network. This would either need to be able to send individual points on the gossip or would need some sort of req/resp faculty, potentially similar to an <code>IHAVEPOINTBITFIELD</code> and <code>IWANTSAMPLE</code>.</li> </ol> <p>However, for simplicity, we don't assign row custody assignments to nodes in the current design.</p>"},{"location":"specs/_features/eip7594/das-core/#subnet-stability","title":"Subnet stability","text":"<p>To start with a simple, stable backbone, for now, we don't shuffle the subnet assignments via the deterministic custody selection helper <code>get_custody_columns</code>. However, staggered rotation likely needs to happen on the order of the pruning period to ensure subnets can be utilized for recovery. For example, introducing an <code>epoch</code> argument allows the function to maintain stability over many epochs.</p>"},{"location":"specs/_features/eip7594/fork/","title":"EIP7594 -- Fork Logic","text":"<p>Notice: This document is a work-in-progress for researchers and implementers.</p>"},{"location":"specs/_features/eip7594/fork/#table-of-contents","title":"Table of contents","text":"<ul> <li>Introduction</li> <li>Configuration</li> <li>Helper functions</li> <li>Misc<ul> <li>Modified <code>compute_fork_version</code></li> </ul> </li> <li>Fork to EIP7594</li> <li>Fork trigger</li> <li>Upgrading the state</li> </ul>"},{"location":"specs/_features/eip7594/fork/#introduction","title":"Introduction","text":"<p>This document describes the process of EIP7594 upgrade.</p>"},{"location":"specs/_features/eip7594/fork/#configuration","title":"Configuration","text":"<p>Warning: this configuration is not definitive.</p> Name Value <code>EIP7594_FORK_VERSION</code> <code>Version('0x06000000')</code> <code>EIP7594_FORK_EPOCH</code> <code>Epoch(18446744073709551615)</code> TBD"},{"location":"specs/_features/eip7594/fork/#helper-functions","title":"Helper functions","text":""},{"location":"specs/_features/eip7594/fork/#misc","title":"Misc","text":""},{"location":"specs/_features/eip7594/fork/#modified-compute_fork_version","title":"Modified <code>compute_fork_version</code>","text":"<pre><code>def compute_fork_version(epoch: Epoch) -&gt; Version:\n\"\"\"\n    Return the fork version at the given ``epoch``.\n    \"\"\"\nif epoch &gt;= EIP7594_FORK_EPOCH:\nreturn EIP7594_FORK_VERSION\nif epoch &gt;= DENEB_FORK_EPOCH:\nreturn DENEB_FORK_VERSION\nif epoch &gt;= CAPELLA_FORK_EPOCH:\nreturn CAPELLA_FORK_VERSION\nif epoch &gt;= BELLATRIX_FORK_EPOCH:\nreturn BELLATRIX_FORK_VERSION\nif epoch &gt;= ALTAIR_FORK_EPOCH:\nreturn ALTAIR_FORK_VERSION\nreturn GENESIS_FORK_VERSION\n</code></pre>"},{"location":"specs/_features/eip7594/fork/#fork-to-eip7594","title":"Fork to EIP7594","text":""},{"location":"specs/_features/eip7594/fork/#fork-trigger","title":"Fork trigger","text":"<p>EIP7594 does not need a hard fork. We only add this fork doc for compiling this new feature in pyspec.</p> <p>For now, we assume the condition will be triggered at epoch <code>EIP7594_FORK_EPOCH</code>.</p> <p>Note that for the pure EIP7594 networks, we don't apply <code>upgrade_to_eip7594</code> since it starts with EIP7594 version logic.</p>"},{"location":"specs/_features/eip7594/fork/#upgrading-the-state","title":"Upgrading the state","text":"<p>If <code>state.slot % SLOTS_PER_EPOCH == 0</code> and <code>compute_epoch_at_slot(state.slot) == EIP7594_FORK_EPOCH</code>, an irregular state change is made to upgrade to EIP7594.</p> <pre><code>def upgrade_to_eip7594(pre: deneb.BeaconState) -&gt; BeaconState:\nepoch = deneb.get_current_epoch(pre)\npost = BeaconState(\n# Versioning\ngenesis_time=pre.genesis_time,\ngenesis_validators_root=pre.genesis_validators_root,\nslot=pre.slot,\nfork=Fork(\nprevious_version=pre.fork.current_version,\ncurrent_version=EIP7594_FORK_VERSION,  # [Modified in EIP7594]\nepoch=epoch,\n),\n# History\nlatest_block_header=pre.latest_block_header,\nblock_roots=pre.block_roots,\nstate_roots=pre.state_roots,\nhistorical_roots=pre.historical_roots,\n# Eth1\neth1_data=pre.eth1_data,\neth1_data_votes=pre.eth1_data_votes,\neth1_deposit_index=pre.eth1_deposit_index,\n# Registry\nvalidators=pre.validators,\nbalances=pre.balances,\n# Randomness\nrandao_mixes=pre.randao_mixes,\n# Slashings\nslashings=pre.slashings,\n# Participation\nprevious_epoch_participation=pre.previous_epoch_participation,\ncurrent_epoch_participation=pre.current_epoch_participation,\n# Finality\njustification_bits=pre.justification_bits,\nprevious_justified_checkpoint=pre.previous_justified_checkpoint,\ncurrent_justified_checkpoint=pre.current_justified_checkpoint,\nfinalized_checkpoint=pre.finalized_checkpoint,\n# Inactivity\ninactivity_scores=pre.inactivity_scores,\n# Sync\ncurrent_sync_committee=pre.current_sync_committee,\nnext_sync_committee=pre.next_sync_committee,\n# Execution-layer\nlatest_execution_payload_header=pre.latest_execution_payload_header,\n# Withdrawals\nnext_withdrawal_index=pre.next_withdrawal_index,\nnext_withdrawal_validator_index=pre.next_withdrawal_validator_index,\n# Deep history valid from Capella onwards\nhistorical_summaries=pre.historical_summaries,\n)\nreturn post\n</code></pre>"},{"location":"specs/_features/eip7594/p2p-interface/","title":"EIP-7594 -- Networking","text":"<p>Notice: This document is a work-in-progress for researchers and implementers.</p>"},{"location":"specs/_features/eip7594/p2p-interface/#table-of-contents","title":"Table of contents","text":"<ul> <li>Modifications in EIP-7594</li> <li>Preset</li> <li>Configuration</li> <li>Containers<ul> <li><code>DataColumnIdentifier</code></li> </ul> </li> <li>Helpers<ul> <li><code>verify_data_column_sidecar_kzg_proofs</code></li> <li><code>verify_data_column_sidecar_inclusion_proof</code></li> <li><code>compute_subnet_for_data_column_sidecar</code></li> </ul> </li> <li>The gossip domain: gossipsub<ul> <li>Topics and messages</li> <li>Blob subnets<ul> <li>Deprecated <code>blob_sidecar_{subnet_id}</code></li> <li><code>data_column_sidecar_{subnet_id}</code></li> </ul> </li> </ul> </li> <li>The Req/Resp domain<ul> <li>Messages</li> <li>DataColumnSidecarsByRoot v1</li> </ul> </li> <li>The discovery domain: discv5<ul> <li>ENR structure</li> <li><code>custody_subnet_count</code></li> </ul> </li> </ul>"},{"location":"specs/_features/eip7594/p2p-interface/#modifications-in-eip-7594","title":"Modifications in EIP-7594","text":""},{"location":"specs/_features/eip7594/p2p-interface/#preset","title":"Preset","text":"Name Value Description <code>KZG_COMMITMENTS_INCLUSION_PROOF_DEPTH</code> <code>uint64(floorlog2(get_generalized_index(BeaconBlockBody, 'blob_kzg_commitments')))</code> (= 4)  Merkle proof index for <code>blob_kzg_commitments</code>"},{"location":"specs/_features/eip7594/p2p-interface/#configuration","title":"Configuration","text":"<p>[New in Deneb:EIP4844]</p> Name Value Description <code>MAX_REQUEST_DATA_COLUMN_SIDECARS</code> <code>MAX_REQUEST_BLOCKS_DENEB * NUMBER_OF_COLUMNS</code> Maximum number of data column sidecars in a single request <code>MIN_EPOCHS_FOR_DATA_COLUMN_SIDECARS_REQUESTS</code> <code>2**12</code> (= 4096 epochs, ~18 days) The minimum epoch range over which a node must serve data column sidecars"},{"location":"specs/_features/eip7594/p2p-interface/#containers","title":"Containers","text":""},{"location":"specs/_features/eip7594/p2p-interface/#datacolumnidentifier","title":"<code>DataColumnIdentifier</code>","text":"<pre><code>class DataColumnIdentifier(Container):\nblock_root: Root\nindex: ColumnIndex\n</code></pre>"},{"location":"specs/_features/eip7594/p2p-interface/#helpers","title":"Helpers","text":""},{"location":"specs/_features/eip7594/p2p-interface/#verify_data_column_sidecar_kzg_proofs","title":"<code>verify_data_column_sidecar_kzg_proofs</code>","text":"<pre><code>def verify_data_column_sidecar_kzg_proofs(sidecar: DataColumnSidecar) -&gt; bool:\n\"\"\"\n    Verify if the proofs are correct\n    \"\"\"\nassert sidecar.index &lt; NUMBER_OF_COLUMNS\nassert len(sidecar.column) == len(sidecar.kzg_commitments) == len(sidecar.kzg_proofs)\nrow_ids = [RowIndex(i) for i in range(len(sidecar.column))]\n# KZG batch verifies that the cells match the corresponding commitments and proofs\nreturn verify_cell_kzg_proof_batch(\nrow_commitments=sidecar.kzg_commitments,\nrow_indices=row_ids,  # all rows\ncolumn_indices=[sidecar.index],\ncells=sidecar.column,\nproofs=sidecar.kzg_proofs,\n)\n</code></pre>"},{"location":"specs/_features/eip7594/p2p-interface/#verify_data_column_sidecar_inclusion_proof","title":"<code>verify_data_column_sidecar_inclusion_proof</code>","text":"<pre><code>def verify_data_column_sidecar_inclusion_proof(sidecar: DataColumnSidecar) -&gt; bool:\n\"\"\"\n    Verify if the given KZG commitments included in the given beacon block.\n    \"\"\"\ngindex = get_subtree_index(get_generalized_index(BeaconBlockBody, 'blob_kzg_commitments'))\nreturn is_valid_merkle_branch(\nleaf=hash_tree_root(sidecar.kzg_commitments),\nbranch=sidecar.kzg_commitments_inclusion_proof,\ndepth=KZG_COMMITMENTS_INCLUSION_PROOF_DEPTH,\nindex=gindex,\nroot=sidecar.signed_block_header.message.body_root,\n)\n</code></pre>"},{"location":"specs/_features/eip7594/p2p-interface/#compute_subnet_for_data_column_sidecar","title":"<code>compute_subnet_for_data_column_sidecar</code>","text":"<pre><code>def compute_subnet_for_data_column_sidecar(column_index: ColumnIndex) -&gt; SubnetID:\nreturn SubnetID(column_index % DATA_COLUMN_SIDECAR_SUBNET_COUNT)\n</code></pre>"},{"location":"specs/_features/eip7594/p2p-interface/#the-gossip-domain-gossipsub","title":"The gossip domain: gossipsub","text":"<p>Some gossip meshes are upgraded in the EIP-7594 fork to support upgraded types.</p>"},{"location":"specs/_features/eip7594/p2p-interface/#topics-and-messages","title":"Topics and messages","text":""},{"location":"specs/_features/eip7594/p2p-interface/#blob-subnets","title":"Blob subnets","text":""},{"location":"specs/_features/eip7594/p2p-interface/#deprecated-blob_sidecar_subnet_id","title":"Deprecated <code>blob_sidecar_{subnet_id}</code>","text":"<p><code>blob_sidecar_{subnet_id}</code> is deprecated.</p>"},{"location":"specs/_features/eip7594/p2p-interface/#data_column_sidecar_subnet_id","title":"<code>data_column_sidecar_{subnet_id}</code>","text":"<p>This topic is used to propagate column sidecars, where each column maps to some <code>subnet_id</code>.</p> <p>The type of the payload of this topic is <code>DataColumnSidecar</code>.</p> <p>The following validations MUST pass before forwarding the <code>sidecar: DataColumnSidecar</code> on the network, assuming the alias <code>block_header = sidecar.signed_block_header.message</code>:</p> <ul> <li>[REJECT] The sidecar's index is consistent with <code>NUMBER_OF_COLUMNS</code> -- i.e. <code>sidecar.index &lt; NUMBER_OF_COLUMNS</code>.</li> <li>[REJECT] The sidecar is for the correct subnet -- i.e. <code>compute_subnet_for_data_column_sidecar(sidecar.index) == subnet_id</code>.</li> <li>[IGNORE] The sidecar is not from a future slot (with a <code>MAXIMUM_GOSSIP_CLOCK_DISPARITY</code> allowance) -- i.e. validate that <code>block_header.slot &lt;= current_slot</code> (a client MAY queue future sidecars for processing at the appropriate slot).</li> <li>[IGNORE] The sidecar is from a slot greater than the latest finalized slot -- i.e. validate that <code>block_header.slot &gt; compute_start_slot_at_epoch(state.finalized_checkpoint.epoch)</code></li> <li>[REJECT] The proposer signature of <code>sidecar.signed_block_header</code>, is valid with respect to the <code>block_header.proposer_index</code> pubkey.</li> <li>[IGNORE] The sidecar's block's parent (defined by <code>block_header.parent_root</code>) has been seen (via both gossip and non-gossip sources) (a client MAY queue sidecars for processing once the parent block is retrieved).</li> <li>[REJECT] The sidecar's block's parent (defined by <code>block_header.parent_root</code>) passes validation.</li> <li>[REJECT] The sidecar is from a higher slot than the sidecar's block's parent (defined by <code>block_header.parent_root</code>).</li> <li>[REJECT] The current finalized_checkpoint is an ancestor of the sidecar's block -- i.e. <code>get_checkpoint_block(store, block_header.parent_root, store.finalized_checkpoint.epoch) == store.finalized_checkpoint.root</code>.</li> <li>[REJECT] The sidecar's <code>kzg_commitments</code> field inclusion proof is valid as verified by <code>verify_data_column_sidecar_inclusion_proof(sidecar)</code>.</li> <li>[REJECT] The sidecar's column data is valid as verified by <code>verify_data_column_sidecar_kzg_proofs(sidecar)</code>.</li> <li>[IGNORE] The sidecar is the first sidecar for the tuple <code>(block_header.slot, block_header.proposer_index, sidecar.index)</code> with valid header signature, sidecar inclusion proof, and kzg proof.</li> <li>[REJECT] The sidecar is proposed by the expected <code>proposer_index</code> for the block's slot in the context of the current shuffling (defined by <code>block_header.parent_root</code>/<code>block_header.slot</code>).   If the <code>proposer_index</code> cannot immediately be verified against the expected shuffling, the sidecar MAY be queued for later processing while proposers for the block's branch are calculated -- in such a case do not <code>REJECT</code>, instead <code>IGNORE</code> this message.</li> </ul> <p>Note: In the <code>verify_data_column_sidecar_inclusion_proof(sidecar)</code> check, for all the sidecars of the same block, it verifies against the same set of <code>kzg_commitments</code> of the given beacon block. Client can choose to cache the result of the arguments tuple <code>(sidecar.kzg_commitments, sidecar.kzg_commitments_inclusion_proof, sidecar.signed_block_header)</code>.</p>"},{"location":"specs/_features/eip7594/p2p-interface/#the-reqresp-domain","title":"The Req/Resp domain","text":""},{"location":"specs/_features/eip7594/p2p-interface/#messages","title":"Messages","text":""},{"location":"specs/_features/eip7594/p2p-interface/#datacolumnsidecarsbyroot-v1","title":"DataColumnSidecarsByRoot v1","text":"<p>Protocol ID: <code>/eth2/beacon_chain/req/data_column_sidecars_by_root/1/</code></p> <p>[New in EIP7594]</p> <p>The <code>&lt;context-bytes&gt;</code> field is calculated as <code>context = compute_fork_digest(fork_version, genesis_validators_root)</code>:</p> <code>fork_version</code> Chunk SSZ type <code>EIP7594_FORK_VERSION</code> <code>eip7594.DataColumnSidecar</code> <p>Request Content:</p> <pre><code>(\n  List[DataColumnIdentifier, MAX_REQUEST_DATA_COLUMN_SIDECARS]\n)\n</code></pre> <p>Response Content:</p> <pre><code>(\n    List[DataColumnSidecar, MAX_REQUEST_DATA_COLUMN_SIDECARS]\n)\n</code></pre> <p>Requests sidecars by block root and index. The response is a list of <code>DataColumnIdentifier</code> whose length is less than or equal to the number of requests. It may be less in the case that the responding peer is missing blocks or sidecars.</p> <p>Before consuming the next response chunk, the response reader SHOULD verify the data column sidecar is well-formatted, has valid inclusion proof, and is correct w.r.t. the expected KZG commitments through <code>verify_data_column_sidecar_kzg_proofs</code>.</p> <p>No more than <code>MAX_REQUEST_DATA_COLUMN_SIDECARS</code> may be requested at a time.</p> <p>The response MUST consist of zero or more <code>response_chunk</code>. Each successful <code>response_chunk</code> MUST contain a single <code>DataColumnSidecar</code> payload.</p> <p>Clients MUST support requesting sidecars since <code>minimum_request_epoch</code>, where <code>minimum_request_epoch = max(finalized_epoch, current_epoch - MIN_EPOCHS_FOR_DATA_COLUMN_SIDECARS_REQUESTS, EIP7594_FORK_EPOCH)</code>. If any root in the request content references a block earlier than <code>minimum_request_epoch</code>, peers MAY respond with error code <code>3: ResourceUnavailable</code> or not include the data column sidecar in the response.</p> <p>Clients MUST respond with at least one sidecar, if they have it. Clients MAY limit the number of blocks and sidecars in the response.</p> <p>Clients SHOULD include a sidecar in the response as soon as it passes the gossip validation rules. Clients SHOULD NOT respond with sidecars related to blocks that fail gossip validation rules. Clients SHOULD NOT respond with sidecars related to blocks that fail the beacon chain state transition</p>"},{"location":"specs/_features/eip7594/p2p-interface/#the-discovery-domain-discv5","title":"The discovery domain: discv5","text":""},{"location":"specs/_features/eip7594/p2p-interface/#enr-structure","title":"ENR structure","text":""},{"location":"specs/_features/eip7594/p2p-interface/#custody_subnet_count","title":"<code>custody_subnet_count</code>","text":"<p>A new field is added to the ENR under the key <code>custody_subnet_count</code> to facilitate custody data column discovery.</p> Key Value <code>custody_subnet_count</code> SSZ <code>uint64</code>"},{"location":"specs/_features/eip7594/polynomial-commitments-sampling/","title":"EIP-7594 -- Polynomial Commitments","text":""},{"location":"specs/_features/eip7594/polynomial-commitments-sampling/#table-of-contents","title":"Table of contents","text":"<ul> <li>Introduction</li> <li>Custom types</li> <li>Constants</li> <li>Preset</li> <li>Cells</li> <li>Helper functions</li> <li>BLS12-381 helpers<ul> <li><code>cell_to_coset_evals</code></li> <li><code>coset_evals_to_cell</code></li> </ul> </li> <li>Linear combinations<ul> <li><code>g2_lincomb</code></li> </ul> </li> <li>FFTs<ul> <li><code>_fft_field</code></li> <li><code>fft_field</code></li> </ul> </li> <li>Polynomials in coefficient form<ul> <li><code>polynomial_eval_to_coeff</code></li> <li><code>add_polynomialcoeff</code></li> <li><code>neg_polynomialcoeff</code></li> <li><code>multiply_polynomialcoeff</code></li> <li><code>divide_polynomialcoeff</code></li> <li><code>shift_polynomialcoeff</code></li> <li><code>interpolate_polynomialcoeff</code></li> <li><code>vanishing_polynomialcoeff</code></li> <li><code>evaluate_polynomialcoeff</code></li> </ul> </li> <li>KZG multiproofs<ul> <li><code>compute_kzg_proof_multi_impl</code></li> <li><code>verify_kzg_proof_multi_impl</code></li> </ul> </li> <li>Cell cosets<ul> <li><code>coset_for_cell</code></li> </ul> </li> <li>Cells</li> <li>Cell computation<ul> <li><code>compute_cells_and_kzg_proofs</code></li> <li><code>compute_cells</code></li> </ul> </li> <li>Cell verification<ul> <li><code>verify_cell_kzg_proof</code></li> <li><code>verify_cell_kzg_proof_batch</code></li> </ul> </li> <li>Reconstruction</li> <li><code>construct_vanishing_polynomial</code></li> <li><code>recover_shifted_data</code></li> <li><code>recover_original_data</code></li> <li><code>recover_all_cells</code></li> </ul>"},{"location":"specs/_features/eip7594/polynomial-commitments-sampling/#introduction","title":"Introduction","text":"<p>This document extends polynomial-commitments.md with the functions required for data availability sampling (DAS). It is not part of the core Deneb spec but an extension that can be optionally implemented to allow nodes to reduce their load using DAS.</p> <p>For any KZG library extended to support DAS, functions flagged as \"Public method\" MUST be provided by the underlying KZG library as public functions. All other functions are private functions used internally by the KZG library.</p> <p>Public functions MUST accept raw bytes as input and perform the required cryptographic normalization before invoking any internal functions.</p>"},{"location":"specs/_features/eip7594/polynomial-commitments-sampling/#custom-types","title":"Custom types","text":"Name SSZ equivalent Description <code>PolynomialCoeff</code> <code>List[BLSFieldElement, FIELD_ELEMENTS_PER_EXT_BLOB]</code> A polynomial in coefficient form <code>Coset</code> <code>Vector[BLSFieldElement, FIELD_ELEMENTS_PER_CELL]</code> The evaluation domain of a cell <code>CosetEvals</code> <code>Vector[BLSFieldElement, FIELD_ELEMENTS_PER_CELL]</code> The internal representation of a cell (the evaluations over its Coset) <code>Cell</code> <code>ByteVector[BYTES_PER_FIELD_ELEMENT * FIELD_ELEMENTS_PER_CELL]</code> The unit of blob data that can come with its own KZG proof <code>CellID</code> <code>uint64</code> Cell identifier <code>RowIndex</code> <code>uint64</code> Row identifier <code>ColumnIndex</code> <code>uint64</code> Column identifier"},{"location":"specs/_features/eip7594/polynomial-commitments-sampling/#constants","title":"Constants","text":"Name Value Notes"},{"location":"specs/_features/eip7594/polynomial-commitments-sampling/#preset","title":"Preset","text":""},{"location":"specs/_features/eip7594/polynomial-commitments-sampling/#cells","title":"Cells","text":"<p>Cells are the smallest unit of blob data that can come with their own KZG proofs. Samples can be constructed from one or several cells (e.g. an individual cell or line).</p> Name Value Description <code>FIELD_ELEMENTS_PER_EXT_BLOB</code> <code>2 * FIELD_ELEMENTS_PER_BLOB</code> Number of field elements in a Reed-Solomon extended blob <code>FIELD_ELEMENTS_PER_CELL</code> <code>uint64(64)</code> Number of field elements in a cell <code>BYTES_PER_CELL</code> <code>FIELD_ELEMENTS_PER_CELL * BYTES_PER_FIELD_ELEMENT</code> The number of bytes in a cell <code>CELLS_PER_EXT_BLOB</code> <code>FIELD_ELEMENTS_PER_EXT_BLOB // FIELD_ELEMENTS_PER_CELL</code> The number of cells in an extended blob <code>RANDOM_CHALLENGE_KZG_CELL_BATCH_DOMAIN</code> <code>b'RCKZGCBATCH__V1_'</code>"},{"location":"specs/_features/eip7594/polynomial-commitments-sampling/#helper-functions","title":"Helper functions","text":""},{"location":"specs/_features/eip7594/polynomial-commitments-sampling/#bls12-381-helpers","title":"BLS12-381 helpers","text":""},{"location":"specs/_features/eip7594/polynomial-commitments-sampling/#cell_to_coset_evals","title":"<code>cell_to_coset_evals</code>","text":"<pre><code>def cell_to_coset_evals(cell: Cell) -&gt; CosetEvals:\n\"\"\"\n    Convert an untrusted ``Cell`` into a trusted ``CosetEvals``.\n    \"\"\"\nevals = []\nfor i in range(FIELD_ELEMENTS_PER_CELL):\nstart = i * BYTES_PER_FIELD_ELEMENT\nend = (i + 1) * BYTES_PER_FIELD_ELEMENT\nvalue = bytes_to_bls_field(cell[start:end])\nevals.append(value)\nreturn CosetEvals(evals)\n</code></pre>"},{"location":"specs/_features/eip7594/polynomial-commitments-sampling/#coset_evals_to_cell","title":"<code>coset_evals_to_cell</code>","text":"<pre><code>def coset_evals_to_cell(coset_evals: CosetEvals) -&gt; Cell:\n\"\"\"\n    Convert a trusted ``CosetEval`` into an untrusted ``Cell``.\n    \"\"\"\ncell = []\nfor i in range(FIELD_ELEMENTS_PER_CELL):\ncell += bls_field_to_bytes(coset_evals[i])\nreturn Cell(cell)\n</code></pre>"},{"location":"specs/_features/eip7594/polynomial-commitments-sampling/#linear-combinations","title":"Linear combinations","text":""},{"location":"specs/_features/eip7594/polynomial-commitments-sampling/#g2_lincomb","title":"<code>g2_lincomb</code>","text":"<pre><code>def g2_lincomb(points: Sequence[G2Point], scalars: Sequence[BLSFieldElement]) -&gt; Bytes96:\n\"\"\"\n    BLS multiscalar multiplication in G2. This can be naively implemented using double-and-add.\n    \"\"\"\nassert len(points) == len(scalars)\nif len(points) == 0:\nreturn bls.G2_to_bytes96(bls.Z2())\npoints_g2 = []\nfor point in points:\npoints_g2.append(bls.bytes96_to_G2(point))\nresult = bls.multi_exp(points_g2, scalars)\nreturn Bytes96(bls.G2_to_bytes96(result))\n</code></pre>"},{"location":"specs/_features/eip7594/polynomial-commitments-sampling/#ffts","title":"FFTs","text":""},{"location":"specs/_features/eip7594/polynomial-commitments-sampling/#_fft_field","title":"<code>_fft_field</code>","text":"<pre><code>def _fft_field(vals: Sequence[BLSFieldElement],\nroots_of_unity: Sequence[BLSFieldElement]) -&gt; Sequence[BLSFieldElement]:\nif len(vals) == 1:\nreturn vals\nL = _fft_field(vals[::2], roots_of_unity[::2])\nR = _fft_field(vals[1::2], roots_of_unity[::2])\no = [BLSFieldElement(0) for _ in vals]\nfor i, (x, y) in enumerate(zip(L, R)):\ny_times_root = (int(y) * int(roots_of_unity[i])) % BLS_MODULUS\no[i] = BLSFieldElement((int(x) + y_times_root) % BLS_MODULUS)\no[i + len(L)] = BLSFieldElement((int(x) - y_times_root + BLS_MODULUS) % BLS_MODULUS)\nreturn o\n</code></pre>"},{"location":"specs/_features/eip7594/polynomial-commitments-sampling/#fft_field","title":"<code>fft_field</code>","text":"<pre><code>def fft_field(vals: Sequence[BLSFieldElement],\nroots_of_unity: Sequence[BLSFieldElement],\ninv: bool=False) -&gt; Sequence[BLSFieldElement]:\nif inv:\n# Inverse FFT\ninvlen = pow(len(vals), BLS_MODULUS - 2, BLS_MODULUS)\nreturn [BLSFieldElement((int(x) * invlen) % BLS_MODULUS)\nfor x in _fft_field(vals, list(roots_of_unity[0:1]) + list(roots_of_unity[:0:-1]))]\nelse:\n# Regular FFT\nreturn _fft_field(vals, roots_of_unity)\n</code></pre>"},{"location":"specs/_features/eip7594/polynomial-commitments-sampling/#polynomials-in-coefficient-form","title":"Polynomials in coefficient form","text":""},{"location":"specs/_features/eip7594/polynomial-commitments-sampling/#polynomial_eval_to_coeff","title":"<code>polynomial_eval_to_coeff</code>","text":"<pre><code>def polynomial_eval_to_coeff(polynomial: Polynomial) -&gt; PolynomialCoeff:\n\"\"\"\n    Interpolates a polynomial (given in evaluation form) to a polynomial in coefficient form.\n    \"\"\"\nroots_of_unity = compute_roots_of_unity(FIELD_ELEMENTS_PER_BLOB)\npolynomial_coeff = fft_field(bit_reversal_permutation(list(polynomial)), roots_of_unity, inv=True)\nreturn polynomial_coeff\n</code></pre>"},{"location":"specs/_features/eip7594/polynomial-commitments-sampling/#add_polynomialcoeff","title":"<code>add_polynomialcoeff</code>","text":"<pre><code>def add_polynomialcoeff(a: PolynomialCoeff, b: PolynomialCoeff) -&gt; PolynomialCoeff:\n\"\"\"\n    Sum the coefficient form polynomials ``a`` and ``b``.\n    \"\"\"\na, b = (a, b) if len(a) &gt;= len(b) else (b, a)\nlength_a = len(a)\nlength_b = len(b)\nreturn [(a[i] + (b[i] if i &lt; length_b else 0)) % BLS_MODULUS for i in range(length_a)]\n</code></pre>"},{"location":"specs/_features/eip7594/polynomial-commitments-sampling/#neg_polynomialcoeff","title":"<code>neg_polynomialcoeff</code>","text":"<pre><code>def neg_polynomialcoeff(a: PolynomialCoeff) -&gt; PolynomialCoeff:\n\"\"\"\n    Negative of coefficient form polynomial ``a``\n    \"\"\"\nreturn [(BLS_MODULUS - x) % BLS_MODULUS for x in a]\n</code></pre>"},{"location":"specs/_features/eip7594/polynomial-commitments-sampling/#multiply_polynomialcoeff","title":"<code>multiply_polynomialcoeff</code>","text":"<pre><code>def multiply_polynomialcoeff(a: PolynomialCoeff, b: PolynomialCoeff) -&gt; PolynomialCoeff:\n\"\"\"\n    Multiplies the coefficient form polynomials ``a`` and ``b``\n    \"\"\"\nassert len(a) + len(b) &lt;= FIELD_ELEMENTS_PER_EXT_BLOB\nr = [0]\nfor power, coef in enumerate(a):\nsummand = [0] * power + [int(coef) * int(x) % BLS_MODULUS for x in b]\nr = add_polynomialcoeff(r, summand)\nreturn r\n</code></pre>"},{"location":"specs/_features/eip7594/polynomial-commitments-sampling/#divide_polynomialcoeff","title":"<code>divide_polynomialcoeff</code>","text":"<pre><code>def divide_polynomialcoeff(a: PolynomialCoeff, b: PolynomialCoeff) -&gt; PolynomialCoeff:\n\"\"\"\n    Long polynomial division for two coefficient form polynomials ``a`` and ``b``\n    \"\"\"\na = a.copy()  # Make a copy since `a` is passed by reference\no = []\napos = len(a) - 1\nbpos = len(b) - 1\ndiff = apos - bpos\nwhile diff &gt;= 0:\nquot = div(a[apos], b[bpos])\no.insert(0, quot)\nfor i in range(bpos, -1, -1):\na[diff + i] = (int(a[diff + i]) - int(b[i] + BLS_MODULUS) * int(quot)) % BLS_MODULUS\napos -= 1\ndiff -= 1\nreturn [x % BLS_MODULUS for x in o]\n</code></pre>"},{"location":"specs/_features/eip7594/polynomial-commitments-sampling/#shift_polynomialcoeff","title":"<code>shift_polynomialcoeff</code>","text":"<pre><code>def shift_polynomialcoeff(polynomial_coeff: PolynomialCoeff, factor: BLSFieldElement) -&gt; PolynomialCoeff:\n\"\"\"\n    Shift the evaluation of a polynomial in coefficient form by factor.\n    This results in a new polynomial g(x) = f(factor * x)\n    \"\"\"\nfactor_power = 1\ninv_factor = pow(int(factor), BLS_MODULUS - 2, BLS_MODULUS)\no = []\nfor p in polynomial_coeff:\no.append(int(p) * factor_power % BLS_MODULUS)\nfactor_power = factor_power * inv_factor % BLS_MODULUS\nreturn o\n</code></pre>"},{"location":"specs/_features/eip7594/polynomial-commitments-sampling/#interpolate_polynomialcoeff","title":"<code>interpolate_polynomialcoeff</code>","text":"<pre><code>def interpolate_polynomialcoeff(xs: Sequence[BLSFieldElement], ys: Sequence[BLSFieldElement]) -&gt; PolynomialCoeff:\n\"\"\"\n    Lagrange interpolation: Finds the lowest degree polynomial that takes the value ``ys[i]`` at ``x[i]``\n    for all i.\n    Outputs a coefficient form polynomial. Leading coefficients may be zero.\n    \"\"\"\nassert len(xs) == len(ys)\nr = [0]\nfor i in range(len(xs)):\nsummand = [ys[i]]\nfor j in range(len(ys)):\nif j != i:\nweight_adjustment = bls_modular_inverse(int(xs[i]) - int(xs[j]))\nsummand = multiply_polynomialcoeff(\nsummand, [((BLS_MODULUS - int(weight_adjustment)) * int(xs[j])) % BLS_MODULUS, weight_adjustment]\n)\nr = add_polynomialcoeff(r, summand)\nreturn r\n</code></pre>"},{"location":"specs/_features/eip7594/polynomial-commitments-sampling/#vanishing_polynomialcoeff","title":"<code>vanishing_polynomialcoeff</code>","text":"<pre><code>def vanishing_polynomialcoeff(xs: Sequence[BLSFieldElement]) -&gt; PolynomialCoeff:\n\"\"\"\n    Compute the vanishing polynomial on ``xs`` (in coefficient form)\n    \"\"\"\np = [1]\nfor x in xs:\np = multiply_polynomialcoeff(p, [-int(x) + BLS_MODULUS, 1])\nreturn p\n</code></pre>"},{"location":"specs/_features/eip7594/polynomial-commitments-sampling/#evaluate_polynomialcoeff","title":"<code>evaluate_polynomialcoeff</code>","text":"<pre><code>def evaluate_polynomialcoeff(polynomial_coeff: PolynomialCoeff, z: BLSFieldElement) -&gt; BLSFieldElement:\n\"\"\"\n    Evaluate a coefficient form polynomial at ``z`` using Horner's schema\n    \"\"\"\ny = 0\nfor coef in polynomial_coeff[::-1]:\ny = (int(y) * int(z) + int(coef)) % BLS_MODULUS\nreturn BLSFieldElement(y % BLS_MODULUS)\n</code></pre>"},{"location":"specs/_features/eip7594/polynomial-commitments-sampling/#kzg-multiproofs","title":"KZG multiproofs","text":"<p>Extended KZG functions for multiproofs</p>"},{"location":"specs/_features/eip7594/polynomial-commitments-sampling/#compute_kzg_proof_multi_impl","title":"<code>compute_kzg_proof_multi_impl</code>","text":"<pre><code>def compute_kzg_proof_multi_impl(\npolynomial_coeff: PolynomialCoeff,\nzs: Coset) -&gt; Tuple[KZGProof, CosetEvals]:\n\"\"\"\n    Compute a KZG multi-evaluation proof for a set of `k` points.\n    This is done by committing to the following quotient polynomial:  \n        Q(X) = f(X) - I(X) / Z(X)\n    Where:\n        - I(X) is the degree `k-1` polynomial that agrees with f(x) at all `k` points\n        - Z(X) is the degree `k` polynomial that evaluates to zero on all `k` points\n    We further note that since the degree of I(X) is less than the degree of Z(X),\n    the computation can be simplified in monomial form to Q(X) = f(X) / Z(X)\n    \"\"\"\n# For all points, compute the evaluation of those points\nys = [evaluate_polynomialcoeff(polynomial_coeff, z) for z in zs]\n# Compute Z(X)\ndenominator_poly = vanishing_polynomialcoeff(zs)\n# Compute the quotient polynomial directly in monomial form\nquotient_polynomial = divide_polynomialcoeff(polynomial_coeff, denominator_poly)\nreturn KZGProof(g1_lincomb(KZG_SETUP_G1_MONOMIAL[:len(quotient_polynomial)], quotient_polynomial)), ys\n</code></pre>"},{"location":"specs/_features/eip7594/polynomial-commitments-sampling/#verify_kzg_proof_multi_impl","title":"<code>verify_kzg_proof_multi_impl</code>","text":"<pre><code>def verify_kzg_proof_multi_impl(commitment: KZGCommitment,\nzs: Coset,\nys: CosetEvals,\nproof: KZGProof) -&gt; bool:\n\"\"\"\n    Verify a KZG multi-evaluation proof for a set of `k` points.\n    This is done by checking if the following equation holds:\n        Q(x) Z(x) = f(X) - I(X)\n    Where:\n        f(X) is the polynomial that we want to verify opens at `k` points to `k` values\n        Q(X) is the quotient polynomial computed by the prover\n        I(X) is the degree k-1 polynomial that evaluates to `ys` at all `zs`` points\n        Z(X) is the polynomial that evaluates to zero on all `k` points\n    The verifier receives the commitments to Q(X) and f(X), so they check the equation\n    holds by using the following pairing equation:\n        e([Q(X)]_1, [Z(X)]_2) == e([f(X)]_1 - [I(X)]_1, [1]_2)\n    \"\"\"\nassert len(zs) == len(ys)\n# Compute [Z(X)]_2\nzero_poly = g2_lincomb(KZG_SETUP_G2_MONOMIAL[:len(zs) + 1], vanishing_polynomialcoeff(zs))\n# Compute [I(X)]_1\ninterpolated_poly = g1_lincomb(KZG_SETUP_G1_MONOMIAL[:len(zs)], interpolate_polynomialcoeff(zs, ys))\nreturn (bls.pairing_check([\n[bls.bytes48_to_G1(proof), bls.bytes96_to_G2(zero_poly)],\n[\nbls.add(bls.bytes48_to_G1(commitment), bls.neg(bls.bytes48_to_G1(interpolated_poly))),\nbls.neg(bls.bytes96_to_G2(KZG_SETUP_G2_MONOMIAL[0])),\n],\n]))\n</code></pre>"},{"location":"specs/_features/eip7594/polynomial-commitments-sampling/#cell-cosets","title":"Cell cosets","text":""},{"location":"specs/_features/eip7594/polynomial-commitments-sampling/#coset_for_cell","title":"<code>coset_for_cell</code>","text":"<pre><code>def coset_for_cell(cell_id: CellID) -&gt; Coset:\n\"\"\"\n    Get the coset for a given ``cell_id``\n    \"\"\"\nassert cell_id &lt; CELLS_PER_EXT_BLOB\nroots_of_unity_brp = bit_reversal_permutation(\ncompute_roots_of_unity(FIELD_ELEMENTS_PER_EXT_BLOB)\n)\nreturn Coset(roots_of_unity_brp[FIELD_ELEMENTS_PER_CELL * cell_id:FIELD_ELEMENTS_PER_CELL * (cell_id + 1)])\n</code></pre>"},{"location":"specs/_features/eip7594/polynomial-commitments-sampling/#cells_1","title":"Cells","text":""},{"location":"specs/_features/eip7594/polynomial-commitments-sampling/#cell-computation","title":"Cell computation","text":""},{"location":"specs/_features/eip7594/polynomial-commitments-sampling/#compute_cells_and_kzg_proofs","title":"<code>compute_cells_and_kzg_proofs</code>","text":"<pre><code>def compute_cells_and_kzg_proofs(blob: Blob) -&gt; Tuple[\nVector[Cell, CELLS_PER_EXT_BLOB],\nVector[KZGProof, CELLS_PER_EXT_BLOB]]:\n\"\"\"\n    Compute all the cell proofs for an extended blob. This is an inefficient O(n^2) algorithm,\n    for performant implementation the FK20 algorithm that runs in O(n log n) should be\n    used instead.\n    Public method.\n    \"\"\"\nassert len(blob) == BYTES_PER_BLOB\npolynomial = blob_to_polynomial(blob)\npolynomial_coeff = polynomial_eval_to_coeff(polynomial)\ncells = []\nproofs = []\nfor i in range(CELLS_PER_EXT_BLOB):\ncoset = coset_for_cell(i)\nproof, ys = compute_kzg_proof_multi_impl(polynomial_coeff, coset)\ncells.append(coset_evals_to_cell(ys))\nproofs.append(proof)\nreturn cells, proofs\n</code></pre>"},{"location":"specs/_features/eip7594/polynomial-commitments-sampling/#compute_cells","title":"<code>compute_cells</code>","text":"<pre><code>def compute_cells(blob: Blob) -&gt; Vector[Cell, CELLS_PER_EXT_BLOB]:\n\"\"\"\n    Compute the cell data for an extended blob (without computing the proofs).\n    Public method.\n    \"\"\"\nassert len(blob) == BYTES_PER_BLOB\npolynomial = blob_to_polynomial(blob)\npolynomial_coeff = polynomial_eval_to_coeff(polynomial)\nextended_data = fft_field(polynomial_coeff + [0] * FIELD_ELEMENTS_PER_BLOB,\ncompute_roots_of_unity(FIELD_ELEMENTS_PER_EXT_BLOB))\nextended_data_rbo = bit_reversal_permutation(extended_data)\ncells = []\nfor cell_id in range(CELLS_PER_EXT_BLOB):\nstart = cell_id * FIELD_ELEMENTS_PER_CELL\nend = (cell_id + 1) * FIELD_ELEMENTS_PER_CELL\ncells.append(coset_evals_to_cell(extended_data_rbo[start:end]))\nreturn cells\n</code></pre>"},{"location":"specs/_features/eip7594/polynomial-commitments-sampling/#cell-verification","title":"Cell verification","text":""},{"location":"specs/_features/eip7594/polynomial-commitments-sampling/#verify_cell_kzg_proof","title":"<code>verify_cell_kzg_proof</code>","text":"<pre><code>def verify_cell_kzg_proof(commitment_bytes: Bytes48,\ncell_id: CellID,\ncell: Cell,\nproof_bytes: Bytes48) -&gt; bool:\n\"\"\"\n    Check a cell proof\n    Public method.\n    \"\"\"\nassert len(commitment_bytes) == BYTES_PER_COMMITMENT\nassert cell_id &lt; CELLS_PER_EXT_BLOB\nassert len(cell) == BYTES_PER_CELL\nassert len(proof_bytes) == BYTES_PER_PROOF\ncoset = coset_for_cell(cell_id)\nreturn verify_kzg_proof_multi_impl(\nbytes_to_kzg_commitment(commitment_bytes),\ncoset,\ncell_to_coset_evals(cell),\nbytes_to_kzg_proof(proof_bytes))\n</code></pre>"},{"location":"specs/_features/eip7594/polynomial-commitments-sampling/#verify_cell_kzg_proof_batch","title":"<code>verify_cell_kzg_proof_batch</code>","text":"<pre><code>def verify_cell_kzg_proof_batch(row_commitments_bytes: Sequence[Bytes48],\nrow_indices: Sequence[RowIndex],\ncolumn_indices: Sequence[ColumnIndex],\ncells: Sequence[Cell],\nproofs_bytes: Sequence[Bytes48]) -&gt; bool:\n\"\"\"\n    Verify a set of cells, given their corresponding proofs and their coordinates (row_id, column_id) in the blob\n    matrix. The list of all commitments is also provided in row_commitments_bytes.\n    This function implements the naive algorithm of checking every cell\n    individually; an efficient algorithm can be found here:\n    https://ethresear.ch/t/a-universal-verification-equation-for-data-availability-sampling/13240\n    This implementation does not require randomness, but for the algorithm that\n    requires it, `RANDOM_CHALLENGE_KZG_CELL_BATCH_DOMAIN` should be used to compute\n    the challenge value.\n    Public method.\n    \"\"\"\nassert len(cells) == len(proofs_bytes) == len(row_indices) == len(column_indices)\nfor commitment_bytes in row_commitments_bytes:\nassert len(commitment_bytes) == BYTES_PER_COMMITMENT\nfor row_index in row_indices:\nassert row_index &lt; len(row_commitments_bytes)\nfor column_index in column_indices:\nassert column_index &lt; CELLS_PER_EXT_BLOB\nfor cell in cells:\nassert len(cell) == BYTES_PER_CELL\nfor proof_bytes in proofs_bytes:\nassert len(proof_bytes) == BYTES_PER_PROOF\n# Get commitments via row IDs\ncommitments_bytes = [row_commitments_bytes[row_index] for row_index in row_indices]\n# Get objects from bytes\ncommitments = [bytes_to_kzg_commitment(commitment_bytes) for commitment_bytes in commitments_bytes]\ncosets_evals = [cell_to_coset_evals(cell) for cell in cells]\nproofs = [bytes_to_kzg_proof(proof_bytes) for proof_bytes in proofs_bytes]\nreturn all(\nverify_kzg_proof_multi_impl(commitment, coset_for_cell(column_index), coset_evals, proof)\nfor commitment, column_index, coset_evals, proof in zip(commitments, column_indices, cosets_evals, proofs)\n)\n</code></pre>"},{"location":"specs/_features/eip7594/polynomial-commitments-sampling/#reconstruction","title":"Reconstruction","text":""},{"location":"specs/_features/eip7594/polynomial-commitments-sampling/#construct_vanishing_polynomial","title":"<code>construct_vanishing_polynomial</code>","text":"<pre><code>def construct_vanishing_polynomial(missing_cell_ids: Sequence[CellID]) -&gt; Tuple[\nSequence[BLSFieldElement],\nSequence[BLSFieldElement]]:\n\"\"\"\n    Given the cells that are missing from the data, compute the polynomial that vanishes at every point that\n    corresponds to a missing field element.\n    \"\"\"\n# Get the small domain\nroots_of_unity_reduced = compute_roots_of_unity(CELLS_PER_EXT_BLOB)\n# Compute polynomial that vanishes at all the missing cells (over the small domain)\nshort_zero_poly = vanishing_polynomialcoeff([\nroots_of_unity_reduced[reverse_bits(missing_cell_id, CELLS_PER_EXT_BLOB)]\nfor missing_cell_id in missing_cell_ids\n])\n# Extend vanishing polynomial to full domain using the closed form of the vanishing polynomial over a coset\nzero_poly_coeff = [0] * FIELD_ELEMENTS_PER_EXT_BLOB\nfor i, coeff in enumerate(short_zero_poly):\nzero_poly_coeff[i * FIELD_ELEMENTS_PER_CELL] = coeff\n# Compute evaluations of the extended vanishing polynomial\nzero_poly_eval = fft_field(zero_poly_coeff,\ncompute_roots_of_unity(FIELD_ELEMENTS_PER_EXT_BLOB))\nzero_poly_eval_brp = bit_reversal_permutation(zero_poly_eval)\n# Sanity check\nfor cell_id in range(CELLS_PER_EXT_BLOB):\nstart = cell_id * FIELD_ELEMENTS_PER_CELL\nend = (cell_id + 1) * FIELD_ELEMENTS_PER_CELL\nif cell_id in missing_cell_ids:\nassert all(a == 0 for a in zero_poly_eval_brp[start:end])\nelse:  # cell_id in cell_ids\nassert all(a != 0 for a in zero_poly_eval_brp[start:end])\nreturn zero_poly_coeff, zero_poly_eval\n</code></pre>"},{"location":"specs/_features/eip7594/polynomial-commitments-sampling/#recover_shifted_data","title":"<code>recover_shifted_data</code>","text":"<pre><code>def recover_shifted_data(cell_ids: Sequence[CellID],\ncells: Sequence[Cell],\nzero_poly_eval: Sequence[BLSFieldElement],\nzero_poly_coeff: Sequence[BLSFieldElement],\nroots_of_unity_extended: Sequence[BLSFieldElement]) -&gt; Tuple[\nSequence[BLSFieldElement],\nSequence[BLSFieldElement],\nBLSFieldElement]:\n\"\"\"\n    Given Z(x), return polynomial Q_1(x)=(E*Z)(k*x) and Q_2(x)=Z(k*x) and k^{-1}.\n    \"\"\"\nshift_factor = BLSFieldElement(PRIMITIVE_ROOT_OF_UNITY)\nshift_inv = div(BLSFieldElement(1), shift_factor)\nextended_evaluation_rbo = [0] * FIELD_ELEMENTS_PER_EXT_BLOB\nfor cell_id, cell in zip(cell_ids, cells):\nstart = cell_id * FIELD_ELEMENTS_PER_CELL\nend = (cell_id + 1) * FIELD_ELEMENTS_PER_CELL\nextended_evaluation_rbo[start:end] = cell\nextended_evaluation = bit_reversal_permutation(extended_evaluation_rbo)\n# Compute (E*Z)(x)\nextended_evaluation_times_zero = [BLSFieldElement(int(a) * int(b) % BLS_MODULUS)\nfor a, b in zip(zero_poly_eval, extended_evaluation)]\nextended_evaluations_fft = fft_field(extended_evaluation_times_zero, roots_of_unity_extended, inv=True)\n# Compute (E*Z)(k*x)\nshifted_extended_evaluation = shift_polynomialcoeff(extended_evaluations_fft, shift_factor)\n# Compute Z(k*x)\nshifted_zero_poly = shift_polynomialcoeff(zero_poly_coeff, shift_factor)\neval_shifted_extended_evaluation = fft_field(shifted_extended_evaluation, roots_of_unity_extended)\neval_shifted_zero_poly = fft_field(shifted_zero_poly, roots_of_unity_extended)\nreturn eval_shifted_extended_evaluation, eval_shifted_zero_poly, shift_inv\n</code></pre>"},{"location":"specs/_features/eip7594/polynomial-commitments-sampling/#recover_original_data","title":"<code>recover_original_data</code>","text":"<pre><code>def recover_original_data(eval_shifted_extended_evaluation: Sequence[BLSFieldElement],\neval_shifted_zero_poly: Sequence[BLSFieldElement],\nshift_inv: BLSFieldElement,\nroots_of_unity_extended: Sequence[BLSFieldElement]) -&gt; Sequence[BLSFieldElement]:\n\"\"\"\n    Given Q_1, Q_2 and k^{-1}, compute P(x).\n    \"\"\"\n# Compute Q_3 = Q_1(x)/Q_2(x) = P(k*x)\neval_shifted_reconstructed_poly = [\ndiv(a, b)\nfor a, b in zip(eval_shifted_extended_evaluation, eval_shifted_zero_poly)\n]\nshifted_reconstructed_poly = fft_field(eval_shifted_reconstructed_poly, roots_of_unity_extended, inv=True)\n# Unshift P(k*x) by k^{-1} to get P(x)\nreconstructed_poly = shift_polynomialcoeff(shifted_reconstructed_poly, shift_inv)\nreconstructed_data = bit_reversal_permutation(fft_field(reconstructed_poly, roots_of_unity_extended))\nreturn reconstructed_data\n</code></pre>"},{"location":"specs/_features/eip7594/polynomial-commitments-sampling/#recover_all_cells","title":"<code>recover_all_cells</code>","text":"<pre><code>def recover_all_cells(cell_ids: Sequence[CellID], cells: Sequence[Cell]) -&gt; Sequence[Cell]:\n\"\"\"\n    Recover all of the cells in the extended blob from FIELD_ELEMENTS_PER_EXT_BLOB evaluations, \n    half of which can be missing.\n    This algorithm uses FFTs to recover cells faster than using Lagrange implementation, as can be seen here:\n    https://ethresear.ch/t/reed-solomon-erasure-code-recovery-in-n-log-2-n-time-with-ffts/3039\n    A faster version thanks to Qi Zhou can be found here:\n    https://github.com/ethereum/research/blob/51b530a53bd4147d123ab3e390a9d08605c2cdb8/polynomial_reconstruction/polynomial_reconstruction_danksharding.py\n    Public method.\n    \"\"\"\nassert len(cell_ids) == len(cells)\n# Check we have enough cells to be able to perform the reconstruction\nassert CELLS_PER_EXT_BLOB / 2 &lt;= len(cell_ids) &lt;= CELLS_PER_EXT_BLOB\n# Check for duplicates\nassert len(cell_ids) == len(set(cell_ids))\n# Check that each cell is the correct length\nfor cell in cells:\nassert len(cell) == BYTES_PER_CELL\n# Get the extended domain\nroots_of_unity_extended = compute_roots_of_unity(FIELD_ELEMENTS_PER_EXT_BLOB)\n# Convert cells to coset evals\ncosets_evals = [cell_to_coset_evals(cell) for cell in cells]\nmissing_cell_ids = [cell_id for cell_id in range(CELLS_PER_EXT_BLOB) if cell_id not in cell_ids]\nzero_poly_coeff, zero_poly_eval = construct_vanishing_polynomial(missing_cell_ids)\neval_shifted_extended_evaluation, eval_shifted_zero_poly, shift_inv = recover_shifted_data(\ncell_ids,\ncosets_evals,\nzero_poly_eval,\nzero_poly_coeff,\nroots_of_unity_extended,\n)\nreconstructed_data = recover_original_data(\neval_shifted_extended_evaluation,\neval_shifted_zero_poly,\nshift_inv,\nroots_of_unity_extended,\n)\nfor cell_id, coset_evals in zip(cell_ids, cosets_evals):\nstart = cell_id * FIELD_ELEMENTS_PER_CELL\nend = (cell_id + 1) * FIELD_ELEMENTS_PER_CELL\nassert reconstructed_data[start:end] == coset_evals\nreconstructed_data_as_cells = [\ncoset_evals_to_cell(reconstructed_data[i * FIELD_ELEMENTS_PER_CELL:(i + 1) * FIELD_ELEMENTS_PER_CELL])\nfor i in range(CELLS_PER_EXT_BLOB)]\nreturn reconstructed_data_as_cells\n</code></pre>"},{"location":"specs/_features/sharding/beacon-chain/","title":"Sharding -- The Beacon Chain","text":"<p>Notice: This document is a work-in-progress for researchers and implementers.</p>"},{"location":"specs/_features/sharding/beacon-chain/#table-of-contents","title":"Table of contents","text":"<ul> <li>Introduction</li> <li>Glossary</li> <li>Constants</li> <li>Misc</li> <li>Domain types</li> <li>Preset</li> <li>Misc</li> <li>Time parameters</li> <li>Shard blob samples</li> <li>Configuration</li> <li>Time parameters</li> <li>Containers</li> <li>New Containers<ul> <li><code>BuilderBlockBid</code></li> <li><code>BuilderBlockBidWithRecipientAddress</code></li> <li><code>ShardedCommitmentsContainer</code></li> <li><code>ShardSample</code></li> </ul> </li> <li>Extended Containers<ul> <li><code>BeaconState</code></li> <li><code>BuilderBlockData</code></li> <li><code>BeaconBlockBody</code></li> </ul> </li> <li>Helper functions</li> <li>Block processing<ul> <li><code>is_builder_block_slot</code></li> </ul> </li> <li>Beacon state accessors<ul> <li><code>get_active_shard_count</code></li> </ul> </li> <li>Beacon chain state transition function</li> <li>Block processing<ul> <li><code>process_block</code></li> <li>Block header</li> <li>Builder Block Bid</li> <li>Sharded data</li> <li>Execution payload</li> </ul> </li> </ul>"},{"location":"specs/_features/sharding/beacon-chain/#introduction","title":"Introduction","text":"<p>This document describes the extensions made to the Phase 0 design of The Beacon Chain to support data sharding, based on the ideas here and more broadly here, using KZG10 commitments to commit to data to remove any need for fraud proofs (and hence, safety-critical synchrony assumptions) in the design.</p>"},{"location":"specs/_features/sharding/beacon-chain/#glossary","title":"Glossary","text":"<ul> <li>Data: A list of KZG points, to translate a byte string into</li> <li>Blob: Data with commitments and meta-data, like a flattened bundle of L2 transactions.</li> </ul>"},{"location":"specs/_features/sharding/beacon-chain/#constants","title":"Constants","text":"<p>The following values are (non-configurable) constants used throughout the specification.</p>"},{"location":"specs/_features/sharding/beacon-chain/#misc","title":"Misc","text":"Name Value Notes <code>FIELD_ELEMENTS_PER_SAMPLE</code> <code>uint64(2**4)</code> (= 16) 31 * 16 = 496 bytes"},{"location":"specs/_features/sharding/beacon-chain/#domain-types","title":"Domain types","text":"Name Value <code>DOMAIN_SHARD_SAMPLE</code> <code>DomainType('0x10000000')</code>"},{"location":"specs/_features/sharding/beacon-chain/#preset","title":"Preset","text":""},{"location":"specs/_features/sharding/beacon-chain/#misc_1","title":"Misc","text":"Name Value Notes <code>MAX_SHARDS</code> <code>uint64(2**12)</code> (= 4,096) Theoretical max shard count (used to determine data structure sizes) <code>ACTIVE_SHARDS</code> <code>uint64(2**8)</code> (= 256) Initial shard count <code>MAX_PROPOSER_BLOCKS_BETWEEN_BUILDER_BLOCKS</code> <code>uint64(2**4)</code> (= 16) TODO: Need to define what happens if there were more blocks without builder blocks"},{"location":"specs/_features/sharding/beacon-chain/#time-parameters","title":"Time parameters","text":"<p>With the introduction of builder blocks the number of slots per epoch is doubled (it counts beacon blocks and builder blocks).</p> Name Value Unit Duration <code>SLOTS_PER_EPOCH</code> <code>uint64(2**6)</code> (= 64) slots 8:32 minutes"},{"location":"specs/_features/sharding/beacon-chain/#shard-blob-samples","title":"Shard blob samples","text":"Name Value Notes <code>SAMPLES_PER_BLOB</code> <code>uint64(2**9)</code> (= 512) 248 * 512 = 126,976 bytes"},{"location":"specs/_features/sharding/beacon-chain/#configuration","title":"Configuration","text":"<p>Note: Some preset variables may become run-time configurable for testnets, but default to a preset while the spec is unstable. E.g. <code>ACTIVE_SHARDS</code> and <code>SAMPLES_PER_BLOB</code>.</p>"},{"location":"specs/_features/sharding/beacon-chain/#time-parameters_1","title":"Time parameters","text":"Name Value Unit Duration <code>SECONDS_PER_SLOT</code> <code>uint64(8)</code> seconds 8 seconds"},{"location":"specs/_features/sharding/beacon-chain/#containers","title":"Containers","text":""},{"location":"specs/_features/sharding/beacon-chain/#new-containers","title":"New Containers","text":""},{"location":"specs/_features/sharding/beacon-chain/#builderblockbid","title":"<code>BuilderBlockBid</code>","text":"<pre><code>class BuilderBlockBid(Container):\nslot: Slot\nparent_block_root: Root\nexecution_payload_root: Root\nsharded_data_commitment_root: Root # Root of the sharded data (only data, not beacon/builder block commitments)\nsharded_data_commitment_count: uint64 # Count of sharded data commitments\nbid: Gwei # Block builder bid paid to proposer\nvalidator_index: ValidatorIndex # Validator index for this bid\n# Block builders use an Eth1 address -- need signature as\n# block bid and data gas base fees will be charged to this address\nsignature_y_parity: bool\nsignature_r: uint256\nsignature_s: uint256    \n</code></pre>"},{"location":"specs/_features/sharding/beacon-chain/#builderblockbidwithrecipientaddress","title":"<code>BuilderBlockBidWithRecipientAddress</code>","text":"<pre><code>class BuilderBlockBidWithRecipientAddress(Container):\nbuilder_block_bid: Union[None, BuilderBlockBid]\nrecipient_address: ExecutionAddress # Address to receive the block builder bid\n</code></pre>"},{"location":"specs/_features/sharding/beacon-chain/#shardedcommitmentscontainer","title":"<code>ShardedCommitmentsContainer</code>","text":"<pre><code>class ShardedCommitmentsContainer(Container):\nsharded_commitments: List[KZGCommitment, 2 * MAX_SHARDS]\n# Aggregate degree proof for all sharded_commitments\ndegree_proof: KZGCommitment\n# The sizes of the blocks encoded in the commitments (last builder and all beacon blocks since)\nincluded_block_sizes: List[uint64, MAX_PROPOSER_BLOCKS_BETWEEN_BUILDER_BLOCKS + 1]\n# Number of commitments that are for sharded data (no blocks)\nincluded_sharded_data_commitments: uint64\n# Random evaluation of beacon blocks + execution payload (this helps with quick verification)\nblock_verification_kzg_proof: KZGCommitment\n</code></pre>"},{"location":"specs/_features/sharding/beacon-chain/#shardsample","title":"<code>ShardSample</code>","text":"<pre><code>class ShardSample(Container):\nslot: Slot\nrow: uint64\ncolumn: uint64\ndata: Vector[BLSFieldElement, FIELD_ELEMENTS_PER_SAMPLE]\nproof: KZGCommitment\nbuilder: ValidatorIndex\nsignature: BLSSignature\n</code></pre>"},{"location":"specs/_features/sharding/beacon-chain/#extended-containers","title":"Extended Containers","text":""},{"location":"specs/_features/sharding/beacon-chain/#beaconstate","title":"<code>BeaconState</code>","text":"<pre><code>class BeaconState(bellatrix.BeaconState):\nblocks_since_builder_block: List[BeaconBlock, MAX_PROPOSER_BLOCKS_BETWEEN_BUILDER_BLOCKS]\n</code></pre>"},{"location":"specs/_features/sharding/beacon-chain/#builderblockdata","title":"<code>BuilderBlockData</code>","text":"<pre><code>class BuilderBlockData(Container):\nexecution_payload: ExecutionPayload\nsharded_commitments_container: ShardedCommitmentsContainer\n</code></pre>"},{"location":"specs/_features/sharding/beacon-chain/#beaconblockbody","title":"<code>BeaconBlockBody</code>","text":"<pre><code>class BeaconBlockBody(altair.BeaconBlockBody):\npayload_data: Union[BuilderBlockBid, BuilderBlockData]\n</code></pre>"},{"location":"specs/_features/sharding/beacon-chain/#helper-functions","title":"Helper functions","text":""},{"location":"specs/_features/sharding/beacon-chain/#block-processing","title":"Block processing","text":""},{"location":"specs/_features/sharding/beacon-chain/#is_builder_block_slot","title":"<code>is_builder_block_slot</code>","text":"<pre><code>def is_builder_block_slot(slot: Slot) -&gt; bool:\nreturn slot % 2 == 1\n</code></pre>"},{"location":"specs/_features/sharding/beacon-chain/#beacon-state-accessors","title":"Beacon state accessors","text":""},{"location":"specs/_features/sharding/beacon-chain/#get_active_shard_count","title":"<code>get_active_shard_count</code>","text":"<pre><code>def get_active_shard_count(state: BeaconState, epoch: Epoch) -&gt; uint64:\n\"\"\"\n    Return the number of active shards.\n    Note that this puts an upper bound on the number of committees per slot.\n    \"\"\"\nreturn ACTIVE_SHARDS\n</code></pre>"},{"location":"specs/_features/sharding/beacon-chain/#beacon-chain-state-transition-function","title":"Beacon chain state transition function","text":""},{"location":"specs/_features/sharding/beacon-chain/#block-processing_1","title":"Block processing","text":""},{"location":"specs/_features/sharding/beacon-chain/#process_block","title":"<code>process_block</code>","text":"<pre><code>def process_block(state: BeaconState, block: BeaconBlock) -&gt; None:\nprocess_block_header(state, block)\nverify_builder_block_bid(state, block)\nprocess_sharded_data(state, block)\nprocess_execution_payload(state, block, EXECUTION_ENGINE)\nif not is_builder_block_slot(block.slot):\nprocess_randao(state, block.body)\nprocess_eth1_data(state, block.body)\nprocess_operations(state, block.body)\nprocess_sync_aggregate(state, block.body.sync_aggregate)\nif is_builder_block_slot(block.slot):\nstate.blocks_since_builder_block = []\nstate.blocks_since_builder_block.append(block)\n</code></pre>"},{"location":"specs/_features/sharding/beacon-chain/#block-header","title":"Block header","text":"<pre><code>def process_block_header(state: BeaconState, block: BeaconBlock) -&gt; None:\n# Verify that the slots match\nassert block.slot == state.slot\n# Verify that the block is newer than latest block header\nassert block.slot &gt; state.latest_block_header.slot\n# Verify that proposer index is the correct index\nif not is_builder_block_slot(block.slot):\nassert block.proposer_index == get_beacon_proposer_index(state)\n# Verify that the parent matches\nassert block.parent_root == hash_tree_root(state.latest_block_header)\n# Cache current block as the new latest block\nstate.latest_block_header = BeaconBlockHeader(\nslot=block.slot,\nproposer_index=block.proposer_index,\nparent_root=block.parent_root,\nstate_root=Bytes32(),  # Overwritten in the next process_slot call\nbody_root=hash_tree_root(block.body),\n)\n# Verify proposer is not slashed\nproposer = state.validators[block.proposer_index]\nassert not proposer.slashed\n</code></pre>"},{"location":"specs/_features/sharding/beacon-chain/#builder-block-bid","title":"Builder Block Bid","text":"<pre><code>def verify_builder_block_bid(state: BeaconState, block: BeaconBlock) -&gt; None:\nif is_builder_block_slot(block.slot):\n# Get last builder block bid\nassert state.blocks_since_builder_block[-1].body.payload_data.selector == 0\nbuilder_block_bid = state.blocks_since_builder_block[-1].body.payload_data.value.builder_block_bid\nassert builder_block_bid.slot + 1 == block.slot\nassert block.body.payload_data.selector == 1 # Verify that builder block does not contain bid\nbuilder_block_data = block.body.payload_data.value\nassert builder_block_bid.execution_payload_root == hash_tree_root(builder_block_data.execution_payload)\nassert builder_block_bid.sharded_data_commitment_count == builder_block_data.included_sharded_data_commitments\nassert builder_block_bid.sharded_data_commitment_root == hash_tree_root(builder_block_data.sharded_commitments[-builder_block_bid.included_sharded_data_commitments:])\nassert builder_block_bid.validator_index == block.proposer_index\nelse:\nassert block.body.payload_data.selector == 0\nbuilder_block_bid = block.body.payload_data.value.builder_block_bid\nassert builder_block_bid.slot == block.slot\nassert builder_block_bid.parent_block_root == block.parent_root\n# We do not check that the builder address exists or has sufficient balance here.\n# If it does not have sufficient balance, the block proposer loses out, so it is their\n# responsibility to check.\n# Check that the builder is a slashable validator. We can probably reduce this requirement and only\n# ensure that they have 1 ETH in their account as a DOS protection.\nbuilder = state.validators[builder_block_bid.validator_index]\nassert is_slashable_validator(builder, get_current_epoch(state))\n</code></pre>"},{"location":"specs/_features/sharding/beacon-chain/#sharded-data","title":"Sharded data","text":"<pre><code>def process_sharded_data(state: BeaconState, block: BeaconBlock) -&gt; None:\nif is_builder_block_slot(block.slot):\nassert block.body.payload_data.selector == 1\nsharded_commitments_container = block.body.payload_data.value.sharded_commitments_container\n# Verify not too many commitments\nassert len(sharded_commitments_container.sharded_commitments) // 2 &lt;= get_active_shard_count(state, get_current_epoch(state))\n# Verify the degree proof\nr = hash_to_bls_field(sharded_commitments_container.sharded_commitments, 0)\nr_powers = compute_powers(r, len(sharded_commitments_container.sharded_commitments))\ncombined_commitment = elliptic_curve_lincomb(sharded_commitments_container.sharded_commitments, r_powers)\npayload_field_elements_per_blob = SAMPLES_PER_BLOB * FIELD_ELEMENTS_PER_SAMPLE // 2\nverify_degree_proof(combined_commitment, payload_field_elements_per_blob, sharded_commitments_container.degree_proof)\n# Verify that the 2*N commitments lie on a degree &lt; N polynomial\nlow_degree_check(sharded_commitments_container.sharded_commitments)\n# Verify that blocks since the last builder block have been included\nblocks_chunked = [bytes_to_field_elements(ssz_serialize(block)) for block in state.blocks_since_builder_block]\nblock_vectors = []\nfor block_chunked in blocks_chunked:\nfor i in range(0, len(block_chunked), payload_field_elements_per_blob):\nblock_vectors.append(block_chunked[i:i + payload_field_elements_per_blob])\nnumber_of_blobs = len(block_vectors)\nr = hash_to_bls_field(sharded_commitments_container.sharded_commitments[:number_of_blobs], 0)\nx = hash_to_bls_field(sharded_commitments_container.sharded_commitments[:number_of_blobs], 1)\nr_powers = compute_powers(r, number_of_blobs)\ncombined_vector = vector_lincomb(block_vectors, r_powers)\ncombined_commitment = elliptic_curve_lincomb(sharded_commitments_container.sharded_commitments[:number_of_blobs], r_powers)\ny = evaluate_polynomial_in_evaluation_form(combined_vector, x)\nverify_kzg_proof(combined_commitment, x, y, sharded_commitments_container.block_verification_kzg_proof)\n# Verify that number of sharded data commitments is correctly indicated\nassert 2 * (number_of_blobs + included_sharded_data_commitments) == len(sharded_commitments_container.sharded_commitments)\n</code></pre>"},{"location":"specs/_features/sharding/beacon-chain/#execution-payload","title":"Execution payload","text":"<pre><code>def process_execution_payload(state: BeaconState, block: BeaconBlock, execution_engine: ExecutionEngine) -&gt; None:\nif is_builder_block_slot(block.slot):\nassert block.body.payload_data.selector == 1\npayload = block.body.payload_data.value.execution_payload\n# Verify consistency of the parent hash with respect to the previous execution payload header\nassert payload.parent_hash == state.latest_execution_payload_header.block_hash\n# Verify random\nassert payload.random == get_randao_mix(state, get_current_epoch(state))\n# Verify timestamp\nassert payload.timestamp == compute_timestamp_at_slot(state, state.slot)\n# Get sharded data commitments\nsharded_commitments_container = block.body.sharded_commitments_container\nsharded_data_commitments = sharded_commitments_container.sharded_commitments[-sharded_commitments_container.included_sharded_data_commitments:]\n# Get all unprocessed builder block bids\nunprocessed_builder_block_bid_with_recipient_addresses = []\nfor block in state.blocks_since_builder_block[1:]:\nunprocessed_builder_block_bid_with_recipient_addresses.append(block.body.builder_block_bid_with_recipient_address.value)\n# Verify the execution payload is valid\n# The execution engine gets two extra payloads: One for the sharded data commitments (these are needed to verify type 3 transactions)\n# and one for all so far unprocessed builder block bids:\n# * The execution engine needs to transfer the balance from the bidder to the proposer.\n# * The execution engine needs to deduct data gas fees from the bidder balances\nassert execution_engine.execute_payload(payload,\nsharded_data_commitments,\nunprocessed_builder_block_bid_with_recipient_addresses)\n# Cache execution payload header\nstate.latest_execution_payload_header = ExecutionPayloadHeader(\nparent_hash=payload.parent_hash,\nfee_recipient=payload.fee_recipient,\nstate_root=payload.state_root,\nreceipt_root=payload.receipt_root,\nlogs_bloom=payload.logs_bloom,\nrandom=payload.random,\nblock_number=payload.block_number,\ngas_limit=payload.gas_limit,\ngas_used=payload.gas_used,\ntimestamp=payload.timestamp,\nextra_data=payload.extra_data,\nbase_fee_per_gas=payload.base_fee_per_gas,\nblock_hash=payload.block_hash,\ntransactions_root=hash_tree_root(payload.transactions),\n)\n</code></pre>"},{"location":"specs/_features/sharding/p2p-interface/","title":"Sharding -- Networking","text":"<p>Notice: This document is a work-in-progress for researchers and implementers.</p>"},{"location":"specs/_features/sharding/p2p-interface/#table-of-contents","title":"Table of contents","text":"<ul> <li>Introduction</li> <li>Constants</li> <li>Misc</li> <li>Gossip domain</li> <li>Topics and messages<ul> <li>Builder block bid</li> <li><code>builder_block_bid</code></li> <li>Shard sample subnets</li> <li><code>shard_row_{subnet_id}</code></li> </ul> </li> </ul>"},{"location":"specs/_features/sharding/p2p-interface/#introduction","title":"Introduction","text":"<p>The specification of these changes continues in the same format as the network specifications of previous upgrades, and assumes them as pre-requisite. The adjustments and additions for Shards are outlined in this document.</p>"},{"location":"specs/_features/sharding/p2p-interface/#constants","title":"Constants","text":""},{"location":"specs/_features/sharding/p2p-interface/#misc","title":"Misc","text":"Name Value Description <code>SHARD_ROW_SUBNET_COUNT</code> <code>512</code> The number of <code>shard_row_{subnet_id}</code> subnets used in the gossipsub protocol. <code>SHARD_COLUMN_SUBNET_COUNT</code> <code>512</code> The number of <code>shard_column_{subnet_id}</code> subnets used in the gossipsub protocol."},{"location":"specs/_features/sharding/p2p-interface/#gossip-domain","title":"Gossip domain","text":""},{"location":"specs/_features/sharding/p2p-interface/#topics-and-messages","title":"Topics and messages","text":"<p>Following the same scheme as the Phase0 gossip topics, names and payload types are:</p> Name Message Type <code>shard_row_{subnet_id}</code> <code>SignedShardSample</code> <code>shard_column_{subnet_id}</code> <code>SignedShardSample</code> <code>builder_block_bid</code> <code>BuilderBlockBid</code> <p>The DAS network specification defines additional topics.</p>"},{"location":"specs/_features/sharding/p2p-interface/#builder-block-bid","title":"Builder block bid","text":""},{"location":"specs/_features/sharding/p2p-interface/#builder_block_bid","title":"<code>builder_block_bid</code>","text":"<ul> <li>[IGNORE] The <code>bid</code> is published 1 slot early or later (with a <code>MAXIMUM_GOSSIP_CLOCK_DISPARITY</code> allowance) --   i.e. validate that <code>bid.slot &lt;= current_slot + 1</code>   (a client MAY queue future samples for propagation at the appropriate slot).</li> <li>[IGNORE] The <code>bid</code> is for the current or next block   i.e. validate that <code>bid.slot &gt;= current_slot</code></li> <li>[IGNORE] The <code>bid</code> is the first <code>bid</code> valid bid for <code>bid.slot</code>, or the bid is at least 1% higher than the previous known <code>bid</code></li> <li>[REJECT] The validator defined by <code>bid.validator_index</code> exists and is slashable.</li> <li>[REJECT] The bid signature, which is an Eth1 signature, needs to be valid and the address needs to contain enough Ether to cover the bid and the data gas base fee.</li> </ul>"},{"location":"specs/_features/sharding/p2p-interface/#shard-sample-subnets","title":"Shard sample subnets","text":"<p>Shard sample (row/column) subnets are used by builders to make their samples available as part of their intermediate block release after selection by beacon block proposers.</p>"},{"location":"specs/_features/sharding/p2p-interface/#shard_row_subnet_id","title":"<code>shard_row_{subnet_id}</code>","text":"<p>Shard sample data, in the form of a <code>SignedShardSample</code> is published to the <code>shard_row_{subnet_id}</code> and <code>shard_column_{subnet_id}</code> subnets.</p> <p>The following validations MUST pass before forwarding the <code>sample</code>.</p> <ul> <li>[IGNORE] The <code>sample</code> is published 1 slot early or later (with a <code>MAXIMUM_GOSSIP_CLOCK_DISPARITY</code> allowance) --   i.e. validate that <code>sample.slot &lt;= current_slot + 1</code>   (a client MAY queue future samples for propagation at the appropriate slot).</li> <li>[IGNORE] The <code>sample</code> is new enough to still be processed --   i.e. validate that <code>compute_epoch_at_slot(sample.slot) &gt;= get_previous_epoch(state)</code></li> <li>[REJECT] The shard sample is for the correct subnet --   i.e. <code>sample.row == subnet_id</code> for <code>shard_row_{subnet_id}</code> and <code>sample.column == subnet_id</code> for <code>shard_column_{subnet_id}</code></li> <li>[IGNORE] The sample is the first sample with valid signature received for the <code>(sample.builder, sample.slot, sample.row, sample.column)</code> combination.</li> <li>[REJECT] The <code>sample.data</code> MUST NOT contain any point <code>x &gt;= BLS_MODULUS</code>. Although it is a <code>uint256</code>, not the full 256 bit range is valid.</li> <li>[REJECT] The validator defined by <code>sample.builder</code> exists and is slashable.</li> <li>[REJECT] The sample is proposed by the expected <code>builder</code> for the sample's <code>slot</code>.   i.e., the beacon block at <code>sample.slot - 1</code> according to the node's fork choice contains an <code>IntermediateBlockBid</code>   with <code>intermediate_block_bid.validator_index == sample.builder</code></li> <li>[REJECT] The sample signature, <code>sample.signature</code>, is valid for the builder --   i.e. <code>bls.Verify(builder_pubkey, sample_signing_root, sample.signature)</code> OR <code>sample.signature == Bytes96(b\"\\0\" * 96)</code> AND   the sample verification <code>verify_sample</code> passes</li> </ul>"},{"location":"specs/_features/sharding/polynomial-commitments/","title":"Sharding -- Polynomial Commitments","text":"<p>Notice: This document is a work-in-progress for researchers and implementers.</p>"},{"location":"specs/_features/sharding/polynomial-commitments/#table-of-contents","title":"Table of contents","text":"<ul> <li>Introduction</li> <li>Constants</li> <li>BLS Field</li> <li>KZG Trusted setup</li> <li>Custom types</li> <li>Helper functions<ul> <li><code>next_power_of_two</code></li> <li><code>reverse_bit_order</code></li> <li><code>list_to_reverse_bit_order</code></li> </ul> </li> <li>Field operations</li> <li>Generic field operations<ul> <li><code>bls_modular_inverse</code></li> <li><code>roots_of_unity</code></li> </ul> </li> <li>Field helper functions<ul> <li><code>compute_powers</code></li> <li><code>low_degree_check</code></li> <li><code>vector_lincomb</code></li> <li><code>bytes_to_field_elements</code></li> </ul> </li> <li>Polynomial operations<ul> <li><code>add_polynomials</code></li> <li><code>multiply_polynomials</code></li> <li><code>interpolate_polynomial</code></li> <li><code>evaluate_polynomial_in_evaluation_form</code></li> </ul> </li> <li>KZG Operations</li> <li>Elliptic curve helper functions<ul> <li><code>elliptic_curve_lincomb</code></li> </ul> </li> <li>Hash to field<ul> <li><code>hash_to_bls_field</code></li> </ul> </li> <li>KZG operations<ul> <li><code>verify_kzg_proof</code></li> <li><code>verify_kzg_multiproof</code></li> <li><code>verify_degree_proof</code></li> </ul> </li> </ul>"},{"location":"specs/_features/sharding/polynomial-commitments/#introduction","title":"Introduction","text":"<p>This document specifies basic polynomial operations and KZG polynomial commitment operations as they are needed for the sharding specification. The implementations are not optimized for performance, but readability. All practical implementations should optimize the polynomial operations, and hints what the best known algorithms for these implementations are included below.</p>"},{"location":"specs/_features/sharding/polynomial-commitments/#constants","title":"Constants","text":""},{"location":"specs/_features/sharding/polynomial-commitments/#bls-field","title":"BLS Field","text":"Name Value Notes <code>BLS_MODULUS</code> <code>0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001</code> (curve order of BLS12_381) <code>PRIMITIVE_ROOT_OF_UNITY</code> <code>7</code> Primitive root of unity of the BLS12_381 (inner) BLS_MODULUS"},{"location":"specs/_features/sharding/polynomial-commitments/#kzg-trusted-setup","title":"KZG Trusted setup","text":"Name Value <code>G1_SETUP</code> Type <code>List[G1]</code>. The G1-side trusted setup <code>[G, G*s, G*s**2....]</code>; note that the first point is the generator. <code>G2_SETUP</code> Type <code>List[G2]</code>. The G2-side trusted setup <code>[G, G*s, G*s**2....]</code>"},{"location":"specs/_features/sharding/polynomial-commitments/#custom-types","title":"Custom types","text":"<p>We define the following Python custom types for type hinting and readability:</p> Name SSZ equivalent Description <code>KZGCommitment</code> <code>Bytes48</code> A G1 curve point <code>BLSFieldElement</code> <code>uint256</code> A number <code>x</code> in the range <code>0 &lt;= x &lt; BLS_MODULUS</code> <code>BLSPolynomialByCoefficients</code> <code>List[BLSFieldElement]</code> A polynomial over the BLS field, given in coefficient form <code>BLSPolynomialByEvaluations</code> <code>List[BLSFieldElement]</code> A polynomial over the BLS field, given in evaluation form"},{"location":"specs/_features/sharding/polynomial-commitments/#helper-functions","title":"Helper functions","text":""},{"location":"specs/_features/sharding/polynomial-commitments/#next_power_of_two","title":"<code>next_power_of_two</code>","text":"<pre><code>def next_power_of_two(x: int) -&gt; int:\nassert x &gt; 0\nreturn 2 ** ((x - 1).bit_length())\n</code></pre>"},{"location":"specs/_features/sharding/polynomial-commitments/#reverse_bit_order","title":"<code>reverse_bit_order</code>","text":"<pre><code>def reverse_bit_order(n: int, order: int) -&gt; int:\n\"\"\"\n    Reverse the bit order of an integer n\n    \"\"\"\nassert is_power_of_two(order)\n# Convert n to binary with the same number of bits as \"order\" - 1, then reverse its bit order\nreturn int(('{:0' + str(order.bit_length() - 1) + 'b}').format(n)[::-1], 2)\n</code></pre>"},{"location":"specs/_features/sharding/polynomial-commitments/#list_to_reverse_bit_order","title":"<code>list_to_reverse_bit_order</code>","text":"<pre><code>def list_to_reverse_bit_order(l: List[int]) -&gt; List[int]:\n\"\"\"\n    Convert a list between normal and reverse bit order. The permutation is an involution (inverts itself)..\n    \"\"\"\nreturn [l[reverse_bit_order(i, len(l))] for i in range(len(l))]\n</code></pre>"},{"location":"specs/_features/sharding/polynomial-commitments/#field-operations","title":"Field operations","text":""},{"location":"specs/_features/sharding/polynomial-commitments/#generic-field-operations","title":"Generic field operations","text":""},{"location":"specs/_features/sharding/polynomial-commitments/#bls_modular_inverse","title":"<code>bls_modular_inverse</code>","text":"<pre><code>def bls_modular_inverse(x: BLSFieldElement) -&gt; BLSFieldElement:\n\"\"\"\n    Compute the modular inverse of x, i.e. y such that x * y % BLS_MODULUS == 1 and return 1 for x == 0\n    \"\"\"\nlm, hm = 1, 0\nlow, high = x % BLS_MODULUS, BLS_MODULUS\nwhile low &gt; 1:\nr = high // low\nnm, new = hm - lm * r, high - low * r\nlm, low, hm, high = nm, new, lm, low\nreturn lm % BLS_MODULUS\n</code></pre>"},{"location":"specs/_features/sharding/polynomial-commitments/#roots_of_unity","title":"<code>roots_of_unity</code>","text":"<pre><code>def roots_of_unity(order: uint64) -&gt; List[BLSFieldElement]:\n\"\"\"\n    Compute a list of roots of unity for a given order.\n    The order must divide the BLS multiplicative group order, i.e. BLS_MODULUS - 1\n    \"\"\"\nassert (BLS_MODULUS - 1) % order == 0\nroots = []\nroot_of_unity = pow(PRIMITIVE_ROOT_OF_UNITY, (BLS_MODULUS - 1) // order, BLS_MODULUS)\ncurrent_root_of_unity = 1\nfor i in range(SAMPLES_PER_BLOB * FIELD_ELEMENTS_PER_SAMPLE):\nroots.append(current_root_of_unity)\ncurrent_root_of_unity = current_root_of_unity * root_of_unity % BLS_MODULUS\nreturn roots\n</code></pre>"},{"location":"specs/_features/sharding/polynomial-commitments/#field-helper-functions","title":"Field helper functions","text":""},{"location":"specs/_features/sharding/polynomial-commitments/#compute_powers","title":"<code>compute_powers</code>","text":"<pre><code>def compute_powers(x: BLSFieldElement, n: uint64) -&gt; List[BLSFieldElement]:\ncurrent_power = 1\npowers = []\nfor _ in range(n):\npowers.append(BLSFieldElement(current_power))\ncurrent_power = current_power * int(x) % BLS_MODULUS\nreturn powers\n</code></pre>"},{"location":"specs/_features/sharding/polynomial-commitments/#low_degree_check","title":"<code>low_degree_check</code>","text":"<pre><code>def low_degree_check(commitments: List[KZGCommitment]):\n\"\"\"\n    Checks that the commitments are on a low-degree polynomial.\n    If there are 2*N commitments, that means they should lie on a polynomial\n    of degree d = K - N - 1, where K = next_power_of_two(2*N)\n    (The remaining positions are filled with 0, this is to make FFTs usable)\n    For details see here: https://notes.ethereum.org/@dankrad/barycentric_low_degree_check\n    \"\"\"\nassert len(commitments) % 2 == 0\nN = len(commitments) // 2\nr = hash_to_bls_field(commitments, 0)\nK = next_power_of_two(2 * N)\nd = K - N - 1\nr_to_K = pow(r, N, K)\nroots = list_to_reverse_bit_order(roots_of_unity(K))\n# For an efficient implementation, B and Bprime should be precomputed\ndef B(z):\nr = 1\nfor w in roots[:d + 1]:\nr = r * (z - w) % BLS_MODULUS\nreturn r\ndef Bprime(z):\nr = 0\nfor i in range(d + 1):\nm = 1\nfor w in roots[:i] + roots[i + 1:d + 1]:\nm = m * (z - w) % BLS_MODULUS\nr = (r + m) % BLS_MODULUS\nreturn r\ncoefs = []\nfor i in range(K):\ncoefs.append( - (r_to_K - 1) * bls_modular_inverse(K * roots[i * (K - 1) % K] * (r - roots[i])) % BLS_MODULUS)\nfor i in range(d + 1):\ncoefs[i] = (coefs[i] + B(r) * bls_modular_inverse(Bprime(r) * (r - roots[i]))) % BLS_MODULUS\nassert elliptic_curve_lincomb(commitments, coefs) == bls.inf_G1()\n</code></pre>"},{"location":"specs/_features/sharding/polynomial-commitments/#vector_lincomb","title":"<code>vector_lincomb</code>","text":"<pre><code>def vector_lincomb(vectors: List[List[BLSFieldElement]], scalars: List[BLSFieldElement]) -&gt; List[BLSFieldElement]:\n\"\"\"\n    Compute a linear combination of field element vectors.\n    \"\"\"\nr = [0]*len(vectors[0])\nfor v, a in zip(vectors, scalars):\nfor i, x in enumerate(v):\nr[i] = (r[i] + a * x) % BLS_MODULUS\nreturn [BLSFieldElement(x) for x in r]\n</code></pre>"},{"location":"specs/_features/sharding/polynomial-commitments/#bytes_to_field_elements","title":"<code>bytes_to_field_elements</code>","text":"<pre><code>def bytes_to_field_elements(block: bytes) -&gt; List[BLSFieldElement]:\n\"\"\"\n    Slices a block into 31-byte chunks that can fit into field elements.\n    \"\"\"\nsliced_block = [block[i:i + 31] for i in range(0, len(bytes), 31)]\nreturn [BLSFieldElement(int.from_bytes(x, \"little\")) for x in sliced_block]\n</code></pre>"},{"location":"specs/_features/sharding/polynomial-commitments/#polynomial-operations","title":"Polynomial operations","text":""},{"location":"specs/_features/sharding/polynomial-commitments/#add_polynomials","title":"<code>add_polynomials</code>","text":"<pre><code>def add_polynomials(a: BLSPolynomialByCoefficients, b: BLSPolynomialByCoefficients) -&gt; BLSPolynomialByCoefficients:\n\"\"\"\n    Sum the polynomials ``a`` and ``b`` given by their coefficients.\n    \"\"\"\na, b = (a, b) if len(a) &gt;= len(b) else (b, a)\nreturn [(a[i] + (b[i] if i &lt; len(b) else 0)) % BLS_MODULUS for i in range(len(a))]\n</code></pre>"},{"location":"specs/_features/sharding/polynomial-commitments/#multiply_polynomials","title":"<code>multiply_polynomials</code>","text":"<pre><code>def multiply_polynomials(a: BLSPolynomialByCoefficients, b: BLSPolynomialByCoefficients) -&gt; BLSPolynomialByCoefficients:\n\"\"\"\n    Multiplies the polynomials `a` and `b` given by their coefficients\n    \"\"\"\nr = [0]\nfor power, coef in enumerate(a):\nsummand = [0] * power + [coef * x % BLS_MODULUS for x in b]\nr = add_polynomials(r, summand)\nreturn r\n</code></pre>"},{"location":"specs/_features/sharding/polynomial-commitments/#interpolate_polynomial","title":"<code>interpolate_polynomial</code>","text":"<pre><code>def interpolate_polynomial(xs: List[BLSFieldElement], ys: List[BLSFieldElement]) -&gt; BLSPolynomialByCoefficients:\n\"\"\"\n    Lagrange interpolation\n    \"\"\"\nassert len(xs) == len(ys)\nr = [0]\nfor i in range(len(xs)):\nsummand = [ys[i]]\nfor j in range(len(ys)):\nif j != i:\nweight_adjustment = bls_modular_inverse(xs[j] - xs[i])\nsummand = multiply_polynomials(\nsummand, [weight_adjustment, ((BLS_MODULUS - weight_adjustment) * xs[i])]\n)\nr = add_polynomials(r, summand)\nreturn r\n</code></pre>"},{"location":"specs/_features/sharding/polynomial-commitments/#evaluate_polynomial_in_evaluation_form","title":"<code>evaluate_polynomial_in_evaluation_form</code>","text":"<pre><code>def evaluate_polynomial_in_evaluation_form(poly: BLSPolynomialByEvaluations, x: BLSFieldElement) -&gt; BLSFieldElement:\n\"\"\"\n    Evaluates a polynomial (in evaluation form) at an arbitrary point\n    \"\"\"\nfield_elements_per_blob = SAMPLES_PER_BLOB * FIELD_ELEMENTS_PER_SAMPLE\nroots = roots_of_unity(field_elements_per_blob)\ndef A(z):\nr = 1\nfor w in roots:\nr = r * (z - w) % BLS_MODULUS\nreturn r\ndef Aprime(z):\nreturn field_elements_per_blob * pow(z, field_elements_per_blob - 1, BLS_MODULUS) \nr = 0\ninverses = [bls_modular_inverse(z - x) for z in roots]\nfor i, x in enumerate(inverses):\nr += poly[i] * bls_modular_inverse(Aprime(roots[i])) * x % BLS_MODULUS\nr = r * A(x) % BLS_MODULUS\nreturn r\n</code></pre>"},{"location":"specs/_features/sharding/polynomial-commitments/#kzg-operations","title":"KZG Operations","text":"<p>We are using the KZG10 polynomial commitment scheme (Kate, Zaverucha and Goldberg, 2010: https://www.iacr.org/archive/asiacrypt2010/6477178/6477178.pdf).  </p>"},{"location":"specs/_features/sharding/polynomial-commitments/#elliptic-curve-helper-functions","title":"Elliptic curve helper functions","text":""},{"location":"specs/_features/sharding/polynomial-commitments/#elliptic_curve_lincomb","title":"<code>elliptic_curve_lincomb</code>","text":"<pre><code>def elliptic_curve_lincomb(points: List[KZGCommitment], scalars: List[BLSFieldElement]) -&gt; KZGCommitment:\n\"\"\"\n    BLS multiscalar multiplication. This function can be optimized using Pippenger's algorithm and variants.\n    This is a non-optimized implementation.\n    \"\"\"\nr = bls.inf_G1()\nfor x, a in zip(points, scalars):\nr = r.add(x.mult(a))\nreturn r\n</code></pre>"},{"location":"specs/_features/sharding/polynomial-commitments/#hash-to-field","title":"Hash to field","text":""},{"location":"specs/_features/sharding/polynomial-commitments/#hash_to_bls_field","title":"<code>hash_to_bls_field</code>","text":"<pre><code>def hash_to_bls_field(x: Container, challenge_number: uint64) -&gt; BLSFieldElement:\n\"\"\"\n    This function is used to generate Fiat-Shamir challenges. The output is not uniform over the BLS field.\n    \"\"\"\nreturn (\n(int.from_bytes(hash(hash_tree_root(x) + int.to_bytes(challenge_number, 32, \"little\")), \"little\"))\n% BLS_MODULUS\n)\n</code></pre>"},{"location":"specs/_features/sharding/polynomial-commitments/#kzg-operations_1","title":"KZG operations","text":""},{"location":"specs/_features/sharding/polynomial-commitments/#verify_kzg_proof","title":"<code>verify_kzg_proof</code>","text":"<pre><code>def verify_kzg_proof(commitment: KZGCommitment, x: BLSFieldElement, y: BLSFieldElement, proof: KZGCommitment) -&gt; None:\n\"\"\"\n    Check that `proof` is a valid KZG proof for the polynomial committed to by `commitment` evaluated\n    at `x` equals `y`.\n    \"\"\"\nzero_poly = G2_SETUP[1].add(G2_SETUP[0].mult(x).neg())\nassert (\nbls.Pairing(proof, zero_poly)\n== bls.Pairing(commitment.add(G1_SETUP[0].mult(y).neg), G2_SETUP[0])\n)\n</code></pre>"},{"location":"specs/_features/sharding/polynomial-commitments/#verify_kzg_multiproof","title":"<code>verify_kzg_multiproof</code>","text":"<pre><code>def verify_kzg_multiproof(commitment: KZGCommitment,\nxs: List[BLSFieldElement],\nys: List[BLSFieldElement],\nproof: KZGCommitment) -&gt; None:\n\"\"\"\n    Verify a KZG multiproof.\n    \"\"\"\nzero_poly = elliptic_curve_lincomb(G2_SETUP[:len(xs)], interpolate_polynomial(xs, [0] * len(ys)))\ninterpolated_poly = elliptic_curve_lincomb(G2_SETUP[:len(xs)], interpolate_polynomial(xs, ys))\nassert (\nbls.Pairing(proof, zero_poly)\n== bls.Pairing(commitment.add(interpolated_poly.neg()), G2_SETUP[0])\n)\n</code></pre>"},{"location":"specs/_features/sharding/polynomial-commitments/#verify_degree_proof","title":"<code>verify_degree_proof</code>","text":"<pre><code>def verify_degree_proof(commitment: KZGCommitment, degree_bound: uint64, proof: KZGCommitment):\n\"\"\"\n    Verifies that the commitment is of polynomial degree &lt; degree_bound. \n    \"\"\"\nassert (\nbls.Pairing(proof, G2_SETUP[0])\n== bls.Pairing(commitment, G2_SETUP[-degree_bound])\n)\n</code></pre>"},{"location":"specs/_features/sharding/validator/","title":"Sharding -- Honest Validator","text":"<p>Notice: This document is a work-in-progress for researchers and implementers.</p>"},{"location":"specs/_features/sharding/validator/#table-of-contents","title":"Table of contents","text":"<ul> <li>Introduction</li> <li>Prerequisites</li> <li>Constants<ul> <li>Sample counts</li> </ul> </li> <li>Helpers<ul> <li><code>get_validator_row_subnets</code></li> <li><code>get_validator_column_subnets</code></li> <li><code>reconstruct_polynomial</code></li> </ul> </li> <li>Sample verification<ul> <li><code>verify_sample</code></li> </ul> </li> <li>Beacon chain responsibilities</li> <li>Validator assignments<ul> <li>Attesting</li> </ul> </li> <li>Sample reconstruction</li> <li>Minimum online validator requirement</li> </ul>"},{"location":"specs/_features/sharding/validator/#introduction","title":"Introduction","text":"<p>This document represents the changes to be made in the code of an \"honest validator\" to implement executable beacon chain proposal.</p>"},{"location":"specs/_features/sharding/validator/#prerequisites","title":"Prerequisites","text":"<p>This document is an extension of the Bellatrix -- Honest Validator guide. All behaviors and definitions defined in this document, and documents it extends, carry over unless explicitly noted or overridden.</p> <p>All terminology, constants, functions, and protocol mechanics defined in the updated Beacon Chain doc of Sharding are requisite for this document and used throughout. Please see related Beacon Chain doc before continuing and use them as a reference throughout.</p>"},{"location":"specs/_features/sharding/validator/#constants","title":"Constants","text":""},{"location":"specs/_features/sharding/validator/#sample-counts","title":"Sample counts","text":"Name Value <code>VALIDATOR_SAMPLE_ROW_COUNT</code> <code>2</code> <code>VALIDATOR_SAMPLE_COLUMN_COUNT</code> <code>2</code>"},{"location":"specs/_features/sharding/validator/#helpers","title":"Helpers","text":""},{"location":"specs/_features/sharding/validator/#get_validator_row_subnets","title":"<code>get_validator_row_subnets</code>","text":"<p>TODO: Currently the subnets are public (i.e. anyone can derive them.) This is good for a proof of custody with public verifiability, but bad for validator privacy.</p> <pre><code>def get_validator_row_subnets(validator: Validator, epoch: Epoch) -&gt; List[uint64]:\nreturn [int.from_bytes(hash_tree_root([validator.pubkey, 0, i])) for i in range(VALIDATOR_SAMPLE_ROW_COUNT)]\n</code></pre>"},{"location":"specs/_features/sharding/validator/#get_validator_column_subnets","title":"<code>get_validator_column_subnets</code>","text":"<pre><code>def get_validator_column_subnets(validator: Validator, epoch: Epoch) -&gt; List[uint64]:\nreturn [int.from_bytes(hash_tree_root([validator.pubkey, 1, i])) for i in range(VALIDATOR_SAMPLE_COLUMN_COUNT)]\n</code></pre>"},{"location":"specs/_features/sharding/validator/#reconstruct_polynomial","title":"<code>reconstruct_polynomial</code>","text":"<pre><code>def reconstruct_polynomial(samples: List[SignedShardSample]) -&gt; List[SignedShardSample]:\n\"\"\"\n    Reconstructs one full row/column from at least 1/2 of the samples\n    \"\"\"\n</code></pre>"},{"location":"specs/_features/sharding/validator/#sample-verification","title":"Sample verification","text":""},{"location":"specs/_features/sharding/validator/#verify_sample","title":"<code>verify_sample</code>","text":"<pre><code>def verify_sample(state: BeaconState, block: BeaconBlock, sample: SignedShardSample):\nassert sample.row &lt; 2 * get_active_shard_count(state, get_current_epoch(block.slot))\nassert sample.column &lt; 2 * SAMPLES_PER_BLOB\nassert block.slot == sample.slot\n# Verify builder signature.\n# TODO: We should probably not do this. This should only be done by p2p to verify samples *before* intermediate block is in\n# builder = state.validators[signed_block.message.proposer_index]\n# signing_root = compute_signing_root(sample, get_domain(state, DOMAIN_SHARD_SAMPLE))\n# assert bls.Verify(sample.builder, signing_root, sample.signature)\nroots_in_rbo = list_to_reverse_bit_order(roots_of_unity(SAMPLES_PER_BLOB * FIELD_ELEMENTS_PER_SAMPLE))\n# Verify KZG proof\nverify_kzg_multiproof(block.body.payload_data.value.sharded_commitments_container.sharded_commitments[sample.row],\nroots_in_rbo[sample.column * FIELD_ELEMENTS_PER_SAMPLE:(sample.column + 1) * FIELD_ELEMENTS_PER_SAMPLE]\nsample.data,\nsample.proof)\n</code></pre>"},{"location":"specs/_features/sharding/validator/#beacon-chain-responsibilities","title":"Beacon chain responsibilities","text":""},{"location":"specs/_features/sharding/validator/#validator-assignments","title":"Validator assignments","text":""},{"location":"specs/_features/sharding/validator/#attesting","title":"Attesting","text":"<p>Every attester is assigned <code>VALIDATOR_SAMPLE_ROW_COUNT</code> rows and <code>VALIDATOR_SAMPLE_COLUMN_COUNT</code> columns of shard samples. As part of their validator duties, they should subscribe to the subnets given by <code>get_validator_row_subnets</code> and <code>get_validator_column_subnets</code>, for the whole epoch.</p> <p>A row or column is available for a <code>slot</code> if at least half of the total number of samples were received on the subnet and passed <code>verify_sample</code>. Otherwise it is called unavailable.</p> <p>If a validator is assigned to an attestation at slot <code>attestation_slot</code> and had his previous attestation duty at <code>previous_attestation_slot</code>, then they should only attest under the following conditions:</p> <ul> <li>For all intermediate blocks <code>block</code> with <code>previous_attestation_slot &lt; block.slot &lt;= attestation_slot</code>: All sample rows and columns assigned to the validator were available.</li> </ul> <p>If this condition is not fulfilled, then the validator should instead attest to the last block for which the condition holds.</p> <p>This leads to the security property that a chain that is not fully available cannot have more than 1/16th of all validators voting for it. TODO: This claim is for an \"infinite number\" of validators. Compute the concrete security due to sampling bias.</p>"},{"location":"specs/_features/sharding/validator/#sample-reconstruction","title":"Sample reconstruction","text":"<p>A validator that has received enough samples of a row or column to mark it as available, should reconstruct all samples in that row/column (if they aren't all available already.) The function <code>reconstruct_polynomial</code> gives an example implementation for this.</p> <p>Once they have run the reconstruction function, they should distribute the samples that they reconstructed on all pubsub that the local node is subscribed to, if they have not already received that sample on that pubsub. As an example:</p> <ul> <li>The validator is subscribed to row <code>2</code> and column <code>5</code></li> <li>The sample <code>(row, column) = (2, 5)</code> is missing in the column <code>5</code> pubsub</li> <li>After they have reconstruction of row <code>2</code>, the validator should send the sample <code>(2, 5)</code> on to the row <code>2</code> pubsub (if it was missing) as well as the column <code>5</code> pubsub.</li> </ul> <p>TODO: We need to verify the total complexity of doing this and make sure this does not cause too much load on a validator</p>"},{"location":"specs/_features/sharding/validator/#minimum-online-validator-requirement","title":"Minimum online validator requirement","text":"<p>The data availability construction guarantees that reconstruction is possible if 75% of all samples are available. In this case, at least 50% of all rows and 50% of all columns are independently available. In practice, it is likely that some supernodes will centrally collect all samples and fill in any gaps. However, we want to build a system that reliably reconstructs even absent all supernodes. Any row or column with 50% of samples will easily be reconstructed even with only 100s of validators online; so the only question is how we get to 50% of samples for all rows and columns, when some of them might be completely unseeded.</p> <p>Each validator will transfer 4 samples between rows and columns where there is overlap. Without loss of generality, look at row 0. Each validator has 1/128 chance of having a sample in this row, and we need 256 samples to reconstruct it. So we expect that we need ~256 * 128 = 32,768 validators to have a fair chance of reconstructing it if it was completely unseeded.</p> <p>A more elaborate estimate here needs about 55,000 validators to be online for high safety that each row and column will be reconstructed.</p>"},{"location":"specs/_features/whisk/beacon-chain/","title":"Whisk -- The Beacon Chain","text":"<p>Notice: This document is a work-in-progress for researchers and implementers.</p>"},{"location":"specs/_features/whisk/beacon-chain/#table-of-contents","title":"Table of contents","text":"<ul> <li>Introduction</li> <li>Constants</li> <li>Domain types</li> <li>Preset</li> <li>Configuration</li> <li>Cryptography</li> <li>BLS</li> <li>Curdleproofs and opening proofs</li> <li>Epoch processing</li> <li><code>WhiskTracker</code></li> <li><code>BeaconState</code></li> <li>Block processing</li> <li>Block header</li> <li>Whisk<ul> <li><code>BeaconBlockBody</code></li> </ul> </li> <li>Deposits</li> <li><code>get_beacon_proposer_index</code></li> <li>Testing</li> </ul>"},{"location":"specs/_features/whisk/beacon-chain/#introduction","title":"Introduction","text":"<p>This document details the beacon chain additions and changes of to support the Whisk SSLE.</p> <p>Note: This specification is built upon capella and is under active development.</p>"},{"location":"specs/_features/whisk/beacon-chain/#constants","title":"Constants","text":""},{"location":"specs/_features/whisk/beacon-chain/#domain-types","title":"Domain types","text":"Name Value <code>DOMAIN_WHISK_CANDIDATE_SELECTION</code> <code>DomainType('0x07000000')</code> <code>DOMAIN_WHISK_SHUFFLE</code> <code>DomainType('0x07100000')</code> <code>DOMAIN_WHISK_PROPOSER_SELECTION</code> <code>DomainType('0x07200000')</code>"},{"location":"specs/_features/whisk/beacon-chain/#preset","title":"Preset","text":"Name Value Description <code>CURDLEPROOFS_N_BLINDERS</code> <code>uint64(4)</code> number of blinders for curdleproofs <code>WHISK_CANDIDATE_TRACKERS_COUNT</code> <code>uint64(2**14)</code> (= 16,384) number of candidate trackers <code>WHISK_PROPOSER_TRACKERS_COUNT</code> <code>uint64(2**13)</code> (= 8,192) number of proposer trackers <code>WHISK_VALIDATORS_PER_SHUFFLE</code> <code>uint64(2**7 - 4)</code> (= 124) number of validators shuffled per shuffle step <code>WHISK_MAX_SHUFFLE_PROOF_SIZE</code> <code>uint64(2**15)</code> max size of a shuffle proof <code>WHISK_MAX_OPENING_PROOF_SIZE</code> <code>uint64(2**10)</code> max size of a opening proof"},{"location":"specs/_features/whisk/beacon-chain/#configuration","title":"Configuration","text":"Name Value Description <code>WHISK_EPOCHS_PER_SHUFFLING_PHASE</code> <code>Epoch(2**8)</code> (= 256) epochs per shuffling phase <code>WHISK_PROPOSER_SELECTION_GAP</code> <code>Epoch(2)</code> gap between proposer selection and the block proposal phase"},{"location":"specs/_features/whisk/beacon-chain/#cryptography","title":"Cryptography","text":""},{"location":"specs/_features/whisk/beacon-chain/#bls","title":"BLS","text":"Name SSZ equivalent Description <code>BLSFieldElement</code> <code>uint256</code> BLS12-381 scalar <code>BLSG1Point</code> <code>Bytes48</code> compressed BLS12-381 G1 point <code>WhiskShuffleProof</code> <code>ByteList[WHISK_MAX_SHUFFLE_PROOF_SIZE]</code> Serialized shuffle proof <code>WhiskTrackerProof</code> <code>ByteList[WHISK_MAX_OPENING_PROOF_SIZE]</code> Serialized tracker proof <p>Note: A subgroup check MUST be performed when deserializing a <code>BLSG1Point</code> for use in any of the functions below.</p> <pre><code>def BLSG1ScalarMultiply(scalar: BLSFieldElement, point: BLSG1Point) -&gt; BLSG1Point:\nreturn bls.G1_to_bytes48(bls.multiply(bls.bytes48_to_G1(point), scalar))\n</code></pre> <pre><code>def bytes_to_bls_field(b: Bytes32) -&gt; BLSFieldElement:\n\"\"\"\n    Convert bytes to a BLS field scalar. The output is not uniform over the BLS field.\n    TODO: Deneb will introduces this helper too. Should delete it once it's rebased to post-Deneb.\n    \"\"\"\nfield_element = int.from_bytes(b, ENDIANNESS)\nreturn BLSFieldElement(field_element % BLS_MODULUS)\n</code></pre> Name Value <code>BLS_G1_GENERATOR</code> <code>BLSG1Point('0x97f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb')  # noqa: E501</code> <code>BLS_MODULUS</code> <code>52435875175126190479447740508185965837690552500527637822603658699938581184513</code> <code>CURDLEPROOFS_CRS</code> TBD"},{"location":"specs/_features/whisk/beacon-chain/#curdleproofs-and-opening-proofs","title":"Curdleproofs and opening proofs","text":"<p>Note that Curdleproofs (Whisk Shuffle Proofs), the tracker opening proofs and all related data structures and verifier code (along with tests) is specified in curdleproofs.pie repository.</p> <pre><code>def IsValidWhiskShuffleProof(pre_shuffle_trackers: Sequence[WhiskTracker],\npost_shuffle_trackers: Sequence[WhiskTracker],\nshuffle_proof: WhiskShuffleProof) -&gt; bool:\n\"\"\"\n    Verify `post_shuffle_trackers` is a permutation of `pre_shuffle_trackers`.\n    Defined in https://github.com/nalinbhardwaj/curdleproofs.pie/blob/dev/curdleproofs/curdleproofs/whisk_interface.py.\n    \"\"\"\nreturn curdleproofs.IsValidWhiskShuffleProof(\nCURDLEPROOFS_CRS,\npre_shuffle_trackers,\npost_shuffle_trackers,\nshuffle_proof,\n)\n</code></pre> <pre><code>def IsValidWhiskOpeningProof(tracker: WhiskTracker,\nk_commitment: BLSG1Point,\ntracker_proof: WhiskTrackerProof) -&gt; bool:\n\"\"\"\n    Verify knowledge of `k` such that `tracker.k_r_G == k * tracker.r_G` and `k_commitment == k * BLS_G1_GENERATOR`.\n    Defined in https://github.com/nalinbhardwaj/curdleproofs.pie/blob/dev/curdleproofs/curdleproofs/whisk_interface.py.\n    \"\"\"\nreturn curdleproofs.IsValidWhiskOpeningProof(tracker, k_commitment, tracker_proof)\n</code></pre>"},{"location":"specs/_features/whisk/beacon-chain/#epoch-processing","title":"Epoch processing","text":""},{"location":"specs/_features/whisk/beacon-chain/#whisktracker","title":"<code>WhiskTracker</code>","text":"<pre><code>class WhiskTracker(Container):\nr_G: BLSG1Point  # r * G\nk_r_G: BLSG1Point  # k * r * G\n</code></pre>"},{"location":"specs/_features/whisk/beacon-chain/#beaconstate","title":"<code>BeaconState</code>","text":"<pre><code>class BeaconState(Container):\n# Versioning\ngenesis_time: uint64\ngenesis_validators_root: Root\nslot: Slot\nfork: Fork\n# History\nlatest_block_header: BeaconBlockHeader\nblock_roots: Vector[Root, SLOTS_PER_HISTORICAL_ROOT]\nstate_roots: Vector[Root, SLOTS_PER_HISTORICAL_ROOT]\nhistorical_roots: List[Root, HISTORICAL_ROOTS_LIMIT]  # Frozen in Capella, replaced by historical_summaries\n# Eth1\neth1_data: Eth1Data\neth1_data_votes: List[Eth1Data, EPOCHS_PER_ETH1_VOTING_PERIOD * SLOTS_PER_EPOCH]\neth1_deposit_index: uint64\n# Registry\nvalidators: List[Validator, VALIDATOR_REGISTRY_LIMIT]\nbalances: List[Gwei, VALIDATOR_REGISTRY_LIMIT]\n# Randomness\nrandao_mixes: Vector[Bytes32, EPOCHS_PER_HISTORICAL_VECTOR]\n# Slashings\nslashings: Vector[Gwei, EPOCHS_PER_SLASHINGS_VECTOR]  # Per-epoch sums of slashed effective balances\n# Participation\nprevious_epoch_participation: List[ParticipationFlags, VALIDATOR_REGISTRY_LIMIT]\ncurrent_epoch_participation: List[ParticipationFlags, VALIDATOR_REGISTRY_LIMIT]\n# Finality\njustification_bits: Bitvector[JUSTIFICATION_BITS_LENGTH]  # Bit set for every recent justified epoch\nprevious_justified_checkpoint: Checkpoint\ncurrent_justified_checkpoint: Checkpoint\nfinalized_checkpoint: Checkpoint\n# Inactivity\ninactivity_scores: List[uint64, VALIDATOR_REGISTRY_LIMIT]\n# Sync\ncurrent_sync_committee: SyncCommittee\nnext_sync_committee: SyncCommittee\n# Execution\nlatest_execution_payload_header: ExecutionPayloadHeader\n# Withdrawals\nnext_withdrawal_index: WithdrawalIndex\nnext_withdrawal_validator_index: ValidatorIndex\n# Deep history valid from Capella onwards\nhistorical_summaries: List[HistoricalSummary, HISTORICAL_ROOTS_LIMIT]\n# Whisk\nwhisk_candidate_trackers: Vector[WhiskTracker, WHISK_CANDIDATE_TRACKERS_COUNT]  # [New in Whisk]\nwhisk_proposer_trackers: Vector[WhiskTracker, WHISK_PROPOSER_TRACKERS_COUNT]  # [New in Whisk]\nwhisk_trackers: List[WhiskTracker, VALIDATOR_REGISTRY_LIMIT]  # [New in Whisk]\nwhisk_k_commitments: List[BLSG1Point, VALIDATOR_REGISTRY_LIMIT]  # [New in Whisk]\n</code></pre> <pre><code>def select_whisk_proposer_trackers(state: BeaconState, epoch: Epoch) -&gt; None:\n# Select proposer trackers from candidate trackers\nproposer_seed = get_seed(\nstate,\nEpoch(saturating_sub(epoch, WHISK_PROPOSER_SELECTION_GAP)),\nDOMAIN_WHISK_PROPOSER_SELECTION\n)\nfor i in range(WHISK_PROPOSER_TRACKERS_COUNT):\nindex = compute_shuffled_index(uint64(i), uint64(len(state.whisk_candidate_trackers)), proposer_seed)\nstate.whisk_proposer_trackers[i] = state.whisk_candidate_trackers[index]\n</code></pre> <pre><code>def select_whisk_candidate_trackers(state: BeaconState, epoch: Epoch) -&gt; None:\n# Select candidate trackers from active validator trackers\nactive_validator_indices = get_active_validator_indices(state, epoch)\nfor i in range(WHISK_CANDIDATE_TRACKERS_COUNT):\nseed = hash(get_seed(state, epoch, DOMAIN_WHISK_CANDIDATE_SELECTION) + uint_to_bytes(uint64(i)))\ncandidate_index = compute_proposer_index(state, active_validator_indices, seed)  # sample by effective balance\nstate.whisk_candidate_trackers[i] = state.whisk_trackers[candidate_index]\n</code></pre> <pre><code>def process_whisk_updates(state: BeaconState) -&gt; None:\nnext_epoch = Epoch(get_current_epoch(state) + 1)\nif next_epoch % WHISK_EPOCHS_PER_SHUFFLING_PHASE == 0:  # select trackers at the start of shuffling phases\nselect_whisk_proposer_trackers(state, next_epoch)\nselect_whisk_candidate_trackers(state, next_epoch)\n</code></pre> <pre><code>def process_epoch(state: BeaconState) -&gt; None:\nprocess_justification_and_finalization(state)\nprocess_inactivity_updates(state)\nprocess_rewards_and_penalties(state)\nprocess_registry_updates(state)\nprocess_slashings(state)\nprocess_eth1_data_reset(state)\nprocess_effective_balance_updates(state)\nprocess_slashings_reset(state)\nprocess_randao_mixes_reset(state)\nprocess_historical_summaries_update(state)\nprocess_participation_flag_updates(state)\nprocess_sync_committee_updates(state)\nprocess_whisk_updates(state)  # [New in Whisk]\n</code></pre>"},{"location":"specs/_features/whisk/beacon-chain/#block-processing","title":"Block processing","text":""},{"location":"specs/_features/whisk/beacon-chain/#block-header","title":"Block header","text":"<pre><code>def process_whisk_opening_proof(state: BeaconState, block: BeaconBlock) -&gt; None:\ntracker = state.whisk_proposer_trackers[state.slot % WHISK_PROPOSER_TRACKERS_COUNT]\nk_commitment = state.whisk_k_commitments[block.proposer_index]\nassert IsValidWhiskOpeningProof(tracker, k_commitment, block.body.whisk_opening_proof)\n</code></pre> <p>Removed <code>assert block.proposer_index == get_beacon_proposer_index(state)</code> check in Whisk.</p> <pre><code>def process_block_header(state: BeaconState, block: BeaconBlock) -&gt; None:\n# Verify that the slots match\nassert block.slot == state.slot\n# Verify that the block is newer than latest block header\nassert block.slot &gt; state.latest_block_header.slot\n# # Verify that proposer index is the correct index\n# assert block.proposer_index == get_beacon_proposer_index(state)\n# Verify that the parent matches\nassert block.parent_root == hash_tree_root(state.latest_block_header)\n# Cache current block as the new latest block\nstate.latest_block_header = BeaconBlockHeader(\nslot=block.slot,\nproposer_index=block.proposer_index,\nparent_root=block.parent_root,\nstate_root=Bytes32(),  # Overwritten in the next process_slot call\nbody_root=hash_tree_root(block.body),\n)\n# Verify proposer is not slashed\nproposer = state.validators[block.proposer_index]\nassert not proposer.slashed\nprocess_whisk_opening_proof(state, block)   # [New in Whisk]\n</code></pre>"},{"location":"specs/_features/whisk/beacon-chain/#whisk","title":"Whisk","text":""},{"location":"specs/_features/whisk/beacon-chain/#beaconblockbody","title":"<code>BeaconBlockBody</code>","text":"<pre><code>class BeaconBlockBody(Container):\nrandao_reveal: BLSSignature\neth1_data: Eth1Data  # Eth1 data vote\ngraffiti: Bytes32  # Arbitrary data\n# Operations\nproposer_slashings: List[ProposerSlashing, MAX_PROPOSER_SLASHINGS]\nattester_slashings: List[AttesterSlashing, MAX_ATTESTER_SLASHINGS]\nattestations: List[Attestation, MAX_ATTESTATIONS]\ndeposits: List[Deposit, MAX_DEPOSITS]\nvoluntary_exits: List[SignedVoluntaryExit, MAX_VOLUNTARY_EXITS]\nsync_aggregate: SyncAggregate\n# Execution\nexecution_payload: ExecutionPayload\nbls_to_execution_changes: List[SignedBLSToExecutionChange, MAX_BLS_TO_EXECUTION_CHANGES]\n# Whisk\nwhisk_opening_proof: WhiskTrackerProof  # [New in Whisk]\nwhisk_post_shuffle_trackers: Vector[WhiskTracker, WHISK_VALIDATORS_PER_SHUFFLE]  # [New in Whisk]\nwhisk_shuffle_proof: WhiskShuffleProof  # [New in Whisk]\nwhisk_registration_proof: WhiskTrackerProof  # [New in Whisk]\nwhisk_tracker: WhiskTracker  # [New in Whisk]\nwhisk_k_commitment: BLSG1Point  # k * BLS_G1_GENERATOR [New in Whisk]\n</code></pre> <pre><code>def get_shuffle_indices(randao_reveal: BLSSignature) -&gt; Sequence[uint64]:\n\"\"\"\n    Given a `randao_reveal` return the list of indices that got shuffled from the entire candidate set.\n    \"\"\"\nindices = []\nfor i in range(0, WHISK_VALIDATORS_PER_SHUFFLE):\n# XXX ensure we are not suffering from modulo bias\npre_image = randao_reveal + uint_to_bytes(uint64(i))\nshuffle_index = bytes_to_uint64(hash(pre_image)[0:8]) % WHISK_CANDIDATE_TRACKERS_COUNT\nindices.append(shuffle_index)\nreturn indices\n</code></pre> <pre><code>def process_shuffled_trackers(state: BeaconState, body: BeaconBlockBody) -&gt; None:\nshuffle_epoch = get_current_epoch(state) % WHISK_EPOCHS_PER_SHUFFLING_PHASE\nif shuffle_epoch + WHISK_PROPOSER_SELECTION_GAP + 1 &gt;= WHISK_EPOCHS_PER_SHUFFLING_PHASE:\n# Require trackers set to zero during cooldown\nassert body.whisk_post_shuffle_trackers == Vector[WhiskTracker, WHISK_VALIDATORS_PER_SHUFFLE]()\nassert body.whisk_shuffle_proof == WhiskShuffleProof()\nelse:\n# Require shuffled trackers during shuffle\nshuffle_indices = get_shuffle_indices(body.randao_reveal)\npre_shuffle_trackers = [state.whisk_candidate_trackers[i] for i in shuffle_indices]\nassert IsValidWhiskShuffleProof(\npre_shuffle_trackers,\nbody.whisk_post_shuffle_trackers,\nbody.whisk_shuffle_proof,\n)\n# Shuffle candidate trackers\nfor i, shuffle_index in enumerate(shuffle_indices):\nstate.whisk_candidate_trackers[shuffle_index] = body.whisk_post_shuffle_trackers[i]\n</code></pre> <pre><code>def is_k_commitment_unique(state: BeaconState, k_commitment: BLSG1Point) -&gt; bool:\nreturn all([whisk_k_commitment != k_commitment for whisk_k_commitment in state.whisk_k_commitments])\n</code></pre> <pre><code>def process_whisk_registration(state: BeaconState, body: BeaconBlockBody) -&gt; None:\nproposer_index = get_beacon_proposer_index(state)\nif state.whisk_trackers[proposer_index].r_G == BLS_G1_GENERATOR:  # first Whisk proposal\nassert body.whisk_tracker.r_G != BLS_G1_GENERATOR\nassert is_k_commitment_unique(state, body.whisk_k_commitment)\nassert IsValidWhiskOpeningProof(\nbody.whisk_tracker,\nbody.whisk_k_commitment,\nbody.whisk_registration_proof,\n)\nstate.whisk_trackers[proposer_index] = body.whisk_tracker\nstate.whisk_k_commitments[proposer_index] = body.whisk_k_commitment\nelse:  # next Whisk proposals\nassert body.whisk_registration_proof == WhiskTrackerProof()\nassert body.whisk_tracker == WhiskTracker()\nassert body.whisk_k_commitment == BLSG1Point()\n</code></pre> <pre><code>def process_block(state: BeaconState, block: BeaconBlock) -&gt; None:\nprocess_block_header(state, block)\nprocess_withdrawals(state, block.body.execution_payload)\nprocess_execution_payload(state, block.body, EXECUTION_ENGINE)\nprocess_randao(state, block.body)\nprocess_eth1_data(state, block.body)\nprocess_operations(state, block.body)\nprocess_sync_aggregate(state, block.body.sync_aggregate)\nprocess_shuffled_trackers(state, block.body)  # [New in Whisk]\nprocess_whisk_registration(state, block.body)  # [New in Whisk]\n</code></pre>"},{"location":"specs/_features/whisk/beacon-chain/#deposits","title":"Deposits","text":"<pre><code>def get_initial_whisk_k(validator_index: ValidatorIndex, counter: int) -&gt; BLSFieldElement:\n# hash `validator_index || counter`\nreturn BLSFieldElement(bytes_to_bls_field(hash(uint_to_bytes(validator_index) + uint_to_bytes(uint64(counter)))))\n</code></pre> <pre><code>def get_unique_whisk_k(state: BeaconState, validator_index: ValidatorIndex) -&gt; BLSFieldElement:\ncounter = 0\nwhile True:\nk = get_initial_whisk_k(validator_index, counter)\nif is_k_commitment_unique(state, BLSG1ScalarMultiply(k, BLS_G1_GENERATOR)):\nreturn k  # unique by trial and error\ncounter += 1\n</code></pre> <pre><code>def get_k_commitment(k: BLSFieldElement) -&gt; BLSG1Point:\nreturn BLSG1ScalarMultiply(k, BLS_G1_GENERATOR)\n</code></pre> <pre><code>def get_initial_tracker(k: BLSFieldElement) -&gt; WhiskTracker:\nreturn WhiskTracker(r_G=BLS_G1_GENERATOR, k_r_G=BLSG1ScalarMultiply(k, BLS_G1_GENERATOR))\n</code></pre> <pre><code>def add_validator_to_registry(state: BeaconState,\npubkey: BLSPubkey,\nwithdrawal_credentials: Bytes32,\namount: uint64) -&gt; None:\nindex = get_index_for_new_validator(state)\nvalidator = get_validator_from_deposit(pubkey, withdrawal_credentials, amount)\nset_or_append_list(state.validators, index, validator)\nset_or_append_list(state.balances, index, amount)\nset_or_append_list(state.previous_epoch_participation, index, ParticipationFlags(0b0000_0000))\nset_or_append_list(state.current_epoch_participation, index, ParticipationFlags(0b0000_0000))\nset_or_append_list(state.inactivity_scores, index, uint64(0))\n# [New in Whisk]\nk = get_unique_whisk_k(state, ValidatorIndex(len(state.validators) - 1))\nstate.whisk_trackers.append(get_initial_tracker(k))\nstate.whisk_k_commitments.append(get_k_commitment(k)) \n</code></pre>"},{"location":"specs/_features/whisk/beacon-chain/#get_beacon_proposer_index","title":"<code>get_beacon_proposer_index</code>","text":"<pre><code>def get_beacon_proposer_index(state: BeaconState) -&gt; ValidatorIndex:\n\"\"\"\n    Return the beacon proposer index at the current slot.\n    \"\"\"\nassert state.latest_block_header.slot == state.slot  # sanity check `process_block_header` has been called\nreturn state.latest_block_header.proposer_index\n</code></pre>"},{"location":"specs/_features/whisk/beacon-chain/#testing","title":"Testing","text":"<p>Note: The function <code>initialize_beacon_state_from_eth1</code> is modified purely for Whisk testing.</p> <pre><code>def initialize_beacon_state_from_eth1(eth1_block_hash: Hash32,\neth1_timestamp: uint64,\ndeposits: Sequence[Deposit],\nexecution_payload_header: ExecutionPayloadHeader=ExecutionPayloadHeader()\n) -&gt; BeaconState:\nstate_capella = capella.initialize_beacon_state_from_eth1(\neth1_block_hash,\neth1_timestamp,\ndeposits,\nexecution_payload_header,\n)\nstate = upgrade_to_whisk(state_capella)\nstate.fork.previous_version = WHISK_FORK_VERSION\nstate.fork.current_version = WHISK_FORK_VERSION\nreturn state\n</code></pre>"},{"location":"specs/_features/whisk/fork/","title":"Whisk -- Fork Logic","text":"<p>Notice: This document is a work-in-progress for researchers and implementers.</p>"},{"location":"specs/_features/whisk/fork/#table-of-contents","title":"Table of contents","text":"<ul> <li>Introduction</li> <li>Configuration</li> <li>Fork to Whisk</li> </ul>"},{"location":"specs/_features/whisk/fork/#introduction","title":"Introduction","text":"<p>This document describes the process of Whisk upgrade.</p> <pre><code>\"\"\"\n    WHISK_FORK_EPOCH\n        |                     cooldown\n        |                     | ||\n        v                     vsvv\n      --+~~~~~~~~~~~~~~~~~~~~~----+-\n               shuffling          ^\n                                  |\n                                  |\n                         proposer selection\n                        candidate selection\n\"\"\"\n</code></pre>"},{"location":"specs/_features/whisk/fork/#configuration","title":"Configuration","text":"<p>Warning: this configuration is not definitive.</p> Name Value <code>WHISK_FORK_VERSION</code> <code>Version('0x08000000')</code> <code>WHISK_FORK_EPOCH</code> <code>Epoch(18446744073709551615)</code> TBD"},{"location":"specs/_features/whisk/fork/#fork-to-whisk","title":"Fork to Whisk","text":"<p>If <code>state.slot % SLOTS_PER_EPOCH == 0</code> and <code>compute_epoch_at_slot(state.slot) == WHISK_FORK_EPOCH</code>, an irregular state change is made to upgrade to Whisk. <code>WHISK_FORK_EPOCH</code> must be a multiple of <code>WHISK_RUN_DURATION_IN_EPOCHS</code>.</p> <p>The upgrade occurs after the completion of the inner loop of <code>process_slots</code> that sets <code>state.slot</code> equal to <code>WHISK_FORK_EPOCH * SLOTS_PER_EPOCH</code>.</p> <p>This ensures that we drop right into the beginning of the shuffling phase but without <code>process_whisk_epoch()</code> triggering for this Whisk run. Hence we handle all the setup ourselves in <code>upgrade_to_whisk()</code> below.</p> <pre><code>def upgrade_to_whisk(pre: capella.BeaconState) -&gt; BeaconState:\n# Compute initial unsafe trackers for all validators\nks = [get_initial_whisk_k(ValidatorIndex(validator_index), 0) for validator_index in range(len(pre.validators))]\nwhisk_k_commitments = [get_k_commitment(k) for k in ks]\nwhisk_trackers = [get_initial_tracker(k) for k in ks]\nepoch = get_current_epoch(pre)\npost = BeaconState(\n# Versioning\ngenesis_time=pre.genesis_time,\ngenesis_validators_root=pre.genesis_validators_root,\nslot=pre.slot,\nfork=Fork(\nprevious_version=pre.fork.current_version,\ncurrent_version=WHISK_FORK_VERSION,\nepoch=epoch,\n),\n# History\nlatest_block_header=pre.latest_block_header,\nblock_roots=pre.block_roots,\nstate_roots=pre.state_roots,\nhistorical_roots=pre.historical_roots,\n# Eth1\neth1_data=pre.eth1_data,\neth1_data_votes=pre.eth1_data_votes,\neth1_deposit_index=pre.eth1_deposit_index,\n# Registry\nvalidators=[],\nbalances=pre.balances,\n# Randomness\nrandao_mixes=pre.randao_mixes,\n# Slashings\nslashings=pre.slashings,\n# Participation\nprevious_epoch_participation=pre.previous_epoch_participation,\ncurrent_epoch_participation=pre.current_epoch_participation,\n# Finality\njustification_bits=pre.justification_bits,\nprevious_justified_checkpoint=pre.previous_justified_checkpoint,\ncurrent_justified_checkpoint=pre.current_justified_checkpoint,\nfinalized_checkpoint=pre.finalized_checkpoint,\n# Inactivity\ninactivity_scores=pre.inactivity_scores,\n# Sync\ncurrent_sync_committee=pre.current_sync_committee,\nnext_sync_committee=pre.next_sync_committee,\n# Execution-layer\nlatest_execution_payload_header=pre.latest_execution_payload_header,\n# Withdrawals\nnext_withdrawal_index=pre.next_withdrawal_index,\nnext_withdrawal_validator_index=pre.next_withdrawal_validator_index,\n# Deep history valid from Capella onwards\nhistorical_summaries=pre.historical_summaries,\n# Whisk\nwhisk_proposer_trackers=[WhiskTracker() for _ in range(WHISK_PROPOSER_TRACKERS_COUNT)],  # [New in Whisk]\nwhisk_candidate_trackers=[WhiskTracker() for _ in range(WHISK_CANDIDATE_TRACKERS_COUNT)],  # [New in Whisk]\nwhisk_trackers=whisk_trackers,  # [New in Whisk]\nwhisk_k_commitments=whisk_k_commitments,  # [New in Whisk]\n)\n# Do a candidate selection followed by a proposer selection so that we have proposers for the upcoming day\n# Use an old epoch when selecting candidates so that we don't get the same seed as in the next candidate selection\nselect_whisk_candidate_trackers(post, Epoch(saturating_sub(epoch, WHISK_PROPOSER_SELECTION_GAP + 1)))\nselect_whisk_proposer_trackers(post, epoch)\n# Do a final round of candidate selection.\n# We need it so that we have something to shuffle over the upcoming shuffling phase.\nselect_whisk_candidate_trackers(post, epoch)\nreturn post\n</code></pre>"},{"location":"specs/altair/beacon-chain/","title":"Altair -- The Beacon Chain","text":""},{"location":"specs/altair/beacon-chain/#table-of-contents","title":"Table of contents","text":"<ul> <li>Introduction</li> <li>Custom types</li> <li>Constants</li> <li>Participation flag indices</li> <li>Incentivization weights</li> <li>Domain types</li> <li>Misc</li> <li>Preset</li> <li>Updated penalty values</li> <li>Sync committee</li> <li>Configuration</li> <li>Inactivity penalties</li> <li>Containers</li> <li>Modified containers<ul> <li><code>BeaconBlockBody</code></li> <li><code>BeaconState</code></li> </ul> </li> <li>New containers<ul> <li><code>SyncAggregate</code></li> <li><code>SyncCommittee</code></li> </ul> </li> <li>Helper functions</li> <li>Crypto</li> <li>Misc<ul> <li><code>add_flag</code></li> <li><code>has_flag</code></li> <li><code>get_index_for_new_validator</code></li> <li><code>set_or_append_list</code></li> </ul> </li> <li>Beacon state accessors<ul> <li><code>get_next_sync_committee_indices</code></li> <li><code>get_next_sync_committee</code></li> <li><code>get_base_reward_per_increment</code></li> <li><code>get_base_reward</code></li> <li><code>get_unslashed_participating_indices</code></li> <li><code>get_attestation_participation_flag_indices</code></li> <li><code>get_flag_index_deltas</code></li> <li>Modified <code>get_inactivity_penalty_deltas</code></li> </ul> </li> <li>Beacon state mutators<ul> <li>Modified <code>slash_validator</code></li> </ul> </li> <li>Block processing<ul> <li>Modified <code>process_attestation</code></li> <li>Modified <code>add_validator_to_registry</code></li> <li>Sync aggregate processing</li> </ul> </li> <li>Epoch processing<ul> <li>Justification and finalization</li> <li>Inactivity scores</li> <li>Rewards and penalties</li> <li>Slashings</li> <li>Participation flags updates</li> <li>Sync committee updates</li> </ul> </li> <li>Initialize state for pure Altair testnets and test vectors</li> </ul>"},{"location":"specs/altair/beacon-chain/#introduction","title":"Introduction","text":"<p>Altair is the first beacon chain hard fork. Its main features are:</p> <ul> <li>sync committees to support light clients</li> <li>incentive accounting reforms to reduce spec complexity</li> <li>penalty parameter updates towards their planned maximally punitive values</li> </ul>"},{"location":"specs/altair/beacon-chain/#custom-types","title":"Custom types","text":"Name SSZ equivalent Description <code>ParticipationFlags</code> <code>uint8</code> a succinct representation of 8 boolean participation flags"},{"location":"specs/altair/beacon-chain/#constants","title":"Constants","text":""},{"location":"specs/altair/beacon-chain/#participation-flag-indices","title":"Participation flag indices","text":"Name Value <code>TIMELY_SOURCE_FLAG_INDEX</code> <code>0</code> <code>TIMELY_TARGET_FLAG_INDEX</code> <code>1</code> <code>TIMELY_HEAD_FLAG_INDEX</code> <code>2</code>"},{"location":"specs/altair/beacon-chain/#incentivization-weights","title":"Incentivization weights","text":"Name Value <code>TIMELY_SOURCE_WEIGHT</code> <code>uint64(14)</code> <code>TIMELY_TARGET_WEIGHT</code> <code>uint64(26)</code> <code>TIMELY_HEAD_WEIGHT</code> <code>uint64(14)</code> <code>SYNC_REWARD_WEIGHT</code> <code>uint64(2)</code> <code>PROPOSER_WEIGHT</code> <code>uint64(8)</code> <code>WEIGHT_DENOMINATOR</code> <code>uint64(64)</code> <p>Note: The sum of the weights equal <code>WEIGHT_DENOMINATOR</code>.</p>"},{"location":"specs/altair/beacon-chain/#domain-types","title":"Domain types","text":"Name Value <code>DOMAIN_SYNC_COMMITTEE</code> <code>DomainType('0x07000000')</code> <code>DOMAIN_SYNC_COMMITTEE_SELECTION_PROOF</code> <code>DomainType('0x08000000')</code> <code>DOMAIN_CONTRIBUTION_AND_PROOF</code> <code>DomainType('0x09000000')</code>"},{"location":"specs/altair/beacon-chain/#misc","title":"Misc","text":"Name Value <code>PARTICIPATION_FLAG_WEIGHTS</code> <code>[TIMELY_SOURCE_WEIGHT, TIMELY_TARGET_WEIGHT, TIMELY_HEAD_WEIGHT]</code>"},{"location":"specs/altair/beacon-chain/#preset","title":"Preset","text":""},{"location":"specs/altair/beacon-chain/#updated-penalty-values","title":"Updated penalty values","text":"<p>This patch updates a few configuration values to move penalty parameters closer to their final, maximum security values.</p> <p>Note: The spec does not override previous configuration values but instead creates new values and replaces usage throughout.</p> Name Value <code>INACTIVITY_PENALTY_QUOTIENT_ALTAIR</code> <code>uint64(3 * 2**24)</code> (= 50,331,648) <code>MIN_SLASHING_PENALTY_QUOTIENT_ALTAIR</code> <code>uint64(2**6)</code> (= 64) <code>PROPORTIONAL_SLASHING_MULTIPLIER_ALTAIR</code> <code>uint64(2)</code>"},{"location":"specs/altair/beacon-chain/#sync-committee","title":"Sync committee","text":"Name Value Unit Duration <code>SYNC_COMMITTEE_SIZE</code> <code>uint64(2**9)</code> (= 512) validators <code>EPOCHS_PER_SYNC_COMMITTEE_PERIOD</code> <code>uint64(2**8)</code> (= 256) epochs ~27 hours"},{"location":"specs/altair/beacon-chain/#configuration","title":"Configuration","text":""},{"location":"specs/altair/beacon-chain/#inactivity-penalties","title":"Inactivity penalties","text":"Name Value Description <code>INACTIVITY_SCORE_BIAS</code> <code>uint64(2**2)</code> (= 4) score points per inactive epoch <code>INACTIVITY_SCORE_RECOVERY_RATE</code> <code>uint64(2**4)</code> (= 16) score points per leak-free epoch"},{"location":"specs/altair/beacon-chain/#containers","title":"Containers","text":""},{"location":"specs/altair/beacon-chain/#modified-containers","title":"Modified containers","text":""},{"location":"specs/altair/beacon-chain/#beaconblockbody","title":"<code>BeaconBlockBody</code>","text":"<pre><code>class BeaconBlockBody(Container):\nrandao_reveal: BLSSignature\neth1_data: Eth1Data  # Eth1 data vote\ngraffiti: Bytes32  # Arbitrary data\n# Operations\nproposer_slashings: List[ProposerSlashing, MAX_PROPOSER_SLASHINGS]\nattester_slashings: List[AttesterSlashing, MAX_ATTESTER_SLASHINGS]\nattestations: List[Attestation, MAX_ATTESTATIONS]\ndeposits: List[Deposit, MAX_DEPOSITS]\nvoluntary_exits: List[SignedVoluntaryExit, MAX_VOLUNTARY_EXITS]\nsync_aggregate: SyncAggregate  # [New in Altair]\n</code></pre>"},{"location":"specs/altair/beacon-chain/#beaconstate","title":"<code>BeaconState</code>","text":"<pre><code>class BeaconState(Container):\n# Versioning\ngenesis_time: uint64\ngenesis_validators_root: Root\nslot: Slot\nfork: Fork\n# History\nlatest_block_header: BeaconBlockHeader\nblock_roots: Vector[Root, SLOTS_PER_HISTORICAL_ROOT]\nstate_roots: Vector[Root, SLOTS_PER_HISTORICAL_ROOT]\nhistorical_roots: List[Root, HISTORICAL_ROOTS_LIMIT]\n# Eth1\neth1_data: Eth1Data\neth1_data_votes: List[Eth1Data, EPOCHS_PER_ETH1_VOTING_PERIOD * SLOTS_PER_EPOCH]\neth1_deposit_index: uint64\n# Registry\nvalidators: List[Validator, VALIDATOR_REGISTRY_LIMIT]\nbalances: List[Gwei, VALIDATOR_REGISTRY_LIMIT]\n# Randomness\nrandao_mixes: Vector[Bytes32, EPOCHS_PER_HISTORICAL_VECTOR]\n# Slashings\nslashings: Vector[Gwei, EPOCHS_PER_SLASHINGS_VECTOR]  # Per-epoch sums of slashed effective balances\n# Participation\nprevious_epoch_participation: List[ParticipationFlags, VALIDATOR_REGISTRY_LIMIT]  # [Modified in Altair]\ncurrent_epoch_participation: List[ParticipationFlags, VALIDATOR_REGISTRY_LIMIT]  # [Modified in Altair]\n# Finality\njustification_bits: Bitvector[JUSTIFICATION_BITS_LENGTH]  # Bit set for every recent justified epoch\nprevious_justified_checkpoint: Checkpoint\ncurrent_justified_checkpoint: Checkpoint\nfinalized_checkpoint: Checkpoint\n# Inactivity\ninactivity_scores: List[uint64, VALIDATOR_REGISTRY_LIMIT]  # [New in Altair]\n# Sync\ncurrent_sync_committee: SyncCommittee  # [New in Altair]\nnext_sync_committee: SyncCommittee  # [New in Altair]\n</code></pre>"},{"location":"specs/altair/beacon-chain/#new-containers","title":"New containers","text":""},{"location":"specs/altair/beacon-chain/#syncaggregate","title":"<code>SyncAggregate</code>","text":"<pre><code>class SyncAggregate(Container):\nsync_committee_bits: Bitvector[SYNC_COMMITTEE_SIZE]\nsync_committee_signature: BLSSignature\n</code></pre>"},{"location":"specs/altair/beacon-chain/#synccommittee","title":"<code>SyncCommittee</code>","text":"<pre><code>class SyncCommittee(Container):\npubkeys: Vector[BLSPubkey, SYNC_COMMITTEE_SIZE]\naggregate_pubkey: BLSPubkey\n</code></pre>"},{"location":"specs/altair/beacon-chain/#helper-functions","title":"Helper functions","text":""},{"location":"specs/altair/beacon-chain/#crypto","title":"Crypto","text":"<p>Refer to the definitions in the phase 0 document regarding BLS signatures and the extensions defined in the Altair BLS document. This specification assumes knowledge of the functionality described in those documents.</p>"},{"location":"specs/altair/beacon-chain/#misc_1","title":"Misc","text":""},{"location":"specs/altair/beacon-chain/#add_flag","title":"<code>add_flag</code>","text":"<pre><code>def add_flag(flags: ParticipationFlags, flag_index: int) -&gt; ParticipationFlags:\n\"\"\"\n    Return a new ``ParticipationFlags`` adding ``flag_index`` to ``flags``.\n    \"\"\"\nflag = ParticipationFlags(2**flag_index)\nreturn flags | flag\n</code></pre>"},{"location":"specs/altair/beacon-chain/#has_flag","title":"<code>has_flag</code>","text":"<pre><code>def has_flag(flags: ParticipationFlags, flag_index: int) -&gt; bool:\n\"\"\"\n    Return whether ``flags`` has ``flag_index`` set.\n    \"\"\"\nflag = ParticipationFlags(2**flag_index)\nreturn flags &amp; flag == flag\n</code></pre>"},{"location":"specs/altair/beacon-chain/#get_index_for_new_validator","title":"<code>get_index_for_new_validator</code>","text":"<pre><code>def get_index_for_new_validator(state: BeaconState) -&gt; ValidatorIndex:\nreturn ValidatorIndex(len(state.validators))\n</code></pre>"},{"location":"specs/altair/beacon-chain/#set_or_append_list","title":"<code>set_or_append_list</code>","text":"<pre><code>def set_or_append_list(list: List, index: ValidatorIndex, value: Any) -&gt; None:\nif index == len(list):\nlist.append(value)\nelse:\nlist[index] = value\n</code></pre>"},{"location":"specs/altair/beacon-chain/#beacon-state-accessors","title":"Beacon state accessors","text":""},{"location":"specs/altair/beacon-chain/#get_next_sync_committee_indices","title":"<code>get_next_sync_committee_indices</code>","text":"<pre><code>def get_next_sync_committee_indices(state: BeaconState) -&gt; Sequence[ValidatorIndex]:\n\"\"\"\n    Return the sync committee indices, with possible duplicates, for the next sync committee.\n    \"\"\"\nepoch = Epoch(get_current_epoch(state) + 1)\nMAX_RANDOM_BYTE = 2**8 - 1\nactive_validator_indices = get_active_validator_indices(state, epoch)\nactive_validator_count = uint64(len(active_validator_indices))\nseed = get_seed(state, epoch, DOMAIN_SYNC_COMMITTEE)\ni = 0\nsync_committee_indices: List[ValidatorIndex] = []\nwhile len(sync_committee_indices) &lt; SYNC_COMMITTEE_SIZE:\nshuffled_index = compute_shuffled_index(uint64(i % active_validator_count), active_validator_count, seed)\ncandidate_index = active_validator_indices[shuffled_index]\nrandom_byte = hash(seed + uint_to_bytes(uint64(i // 32)))[i % 32]\neffective_balance = state.validators[candidate_index].effective_balance\nif effective_balance * MAX_RANDOM_BYTE &gt;= MAX_EFFECTIVE_BALANCE * random_byte:\nsync_committee_indices.append(candidate_index)\ni += 1\nreturn sync_committee_indices\n</code></pre>"},{"location":"specs/altair/beacon-chain/#get_next_sync_committee","title":"<code>get_next_sync_committee</code>","text":"<p>Note: The function <code>get_next_sync_committee</code> should only be called at sync committee period boundaries and when upgrading state to Altair.</p> <pre><code>def get_next_sync_committee(state: BeaconState) -&gt; SyncCommittee:\n\"\"\"\n    Return the next sync committee, with possible pubkey duplicates.\n    \"\"\"\nindices = get_next_sync_committee_indices(state)\npubkeys = [state.validators[index].pubkey for index in indices]\naggregate_pubkey = eth_aggregate_pubkeys(pubkeys)\nreturn SyncCommittee(pubkeys=pubkeys, aggregate_pubkey=aggregate_pubkey)\n</code></pre>"},{"location":"specs/altair/beacon-chain/#get_base_reward_per_increment","title":"<code>get_base_reward_per_increment</code>","text":"<pre><code>def get_base_reward_per_increment(state: BeaconState) -&gt; Gwei:\nreturn Gwei(EFFECTIVE_BALANCE_INCREMENT * BASE_REWARD_FACTOR // integer_squareroot(get_total_active_balance(state)))\n</code></pre>"},{"location":"specs/altair/beacon-chain/#get_base_reward","title":"<code>get_base_reward</code>","text":"<p>Note: The function <code>get_base_reward</code> is modified with the removal of <code>BASE_REWARDS_PER_EPOCH</code> and the use of increment based accounting.</p> <p>Note: On average an optimally performing validator earns one base reward per epoch.</p> <pre><code>def get_base_reward(state: BeaconState, index: ValidatorIndex) -&gt; Gwei:\n\"\"\"\n    Return the base reward for the validator defined by ``index`` with respect to the current ``state``.\n    \"\"\"\nincrements = state.validators[index].effective_balance // EFFECTIVE_BALANCE_INCREMENT\nreturn Gwei(increments * get_base_reward_per_increment(state))\n</code></pre>"},{"location":"specs/altair/beacon-chain/#get_unslashed_participating_indices","title":"<code>get_unslashed_participating_indices</code>","text":"<pre><code>def get_unslashed_participating_indices(state: BeaconState, flag_index: int, epoch: Epoch) -&gt; Set[ValidatorIndex]:\n\"\"\"\n    Return the set of validator indices that are both active and unslashed for the given ``flag_index`` and ``epoch``.\n    \"\"\"\nassert epoch in (get_previous_epoch(state), get_current_epoch(state))\nif epoch == get_current_epoch(state):\nepoch_participation = state.current_epoch_participation\nelse:\nepoch_participation = state.previous_epoch_participation\nactive_validator_indices = get_active_validator_indices(state, epoch)\nparticipating_indices = [i for i in active_validator_indices if has_flag(epoch_participation[i], flag_index)]\nreturn set(filter(lambda index: not state.validators[index].slashed, participating_indices))\n</code></pre>"},{"location":"specs/altair/beacon-chain/#get_attestation_participation_flag_indices","title":"<code>get_attestation_participation_flag_indices</code>","text":"<pre><code>def get_attestation_participation_flag_indices(state: BeaconState,\ndata: AttestationData,\ninclusion_delay: uint64) -&gt; Sequence[int]:\n\"\"\"\n    Return the flag indices that are satisfied by an attestation.\n    \"\"\"\nif data.target.epoch == get_current_epoch(state):\njustified_checkpoint = state.current_justified_checkpoint\nelse:\njustified_checkpoint = state.previous_justified_checkpoint\n# Matching roots\nis_matching_source = data.source == justified_checkpoint\nis_matching_target = is_matching_source and data.target.root == get_block_root(state, data.target.epoch)\nis_matching_head = is_matching_target and data.beacon_block_root == get_block_root_at_slot(state, data.slot)\nassert is_matching_source\nparticipation_flag_indices = []\nif is_matching_source and inclusion_delay &lt;= integer_squareroot(SLOTS_PER_EPOCH):\nparticipation_flag_indices.append(TIMELY_SOURCE_FLAG_INDEX)\nif is_matching_target and inclusion_delay &lt;= SLOTS_PER_EPOCH:\nparticipation_flag_indices.append(TIMELY_TARGET_FLAG_INDEX)\nif is_matching_head and inclusion_delay == MIN_ATTESTATION_INCLUSION_DELAY:\nparticipation_flag_indices.append(TIMELY_HEAD_FLAG_INDEX)\nreturn participation_flag_indices\n</code></pre>"},{"location":"specs/altair/beacon-chain/#get_flag_index_deltas","title":"<code>get_flag_index_deltas</code>","text":"<pre><code>def get_flag_index_deltas(state: BeaconState, flag_index: int) -&gt; Tuple[Sequence[Gwei], Sequence[Gwei]]:\n\"\"\"\n    Return the deltas for a given ``flag_index`` by scanning through the participation flags.\n    \"\"\"\nrewards = [Gwei(0)] * len(state.validators)\npenalties = [Gwei(0)] * len(state.validators)\nprevious_epoch = get_previous_epoch(state)\nunslashed_participating_indices = get_unslashed_participating_indices(state, flag_index, previous_epoch)\nweight = PARTICIPATION_FLAG_WEIGHTS[flag_index]\nunslashed_participating_balance = get_total_balance(state, unslashed_participating_indices)\nunslashed_participating_increments = unslashed_participating_balance // EFFECTIVE_BALANCE_INCREMENT\nactive_increments = get_total_active_balance(state) // EFFECTIVE_BALANCE_INCREMENT\nfor index in get_eligible_validator_indices(state):\nbase_reward = get_base_reward(state, index)\nif index in unslashed_participating_indices:\nif not is_in_inactivity_leak(state):\nreward_numerator = base_reward * weight * unslashed_participating_increments\nrewards[index] += Gwei(reward_numerator // (active_increments * WEIGHT_DENOMINATOR))\nelif flag_index != TIMELY_HEAD_FLAG_INDEX:\npenalties[index] += Gwei(base_reward * weight // WEIGHT_DENOMINATOR)\nreturn rewards, penalties\n</code></pre>"},{"location":"specs/altair/beacon-chain/#modified-get_inactivity_penalty_deltas","title":"Modified <code>get_inactivity_penalty_deltas</code>","text":"<pre><code>def get_inactivity_penalty_deltas(state: BeaconState) -&gt; Tuple[Sequence[Gwei], Sequence[Gwei]]:\n\"\"\"\n    Return the inactivity penalty deltas by considering timely target participation flags and inactivity scores.\n    \"\"\"\nrewards = [Gwei(0) for _ in range(len(state.validators))]\npenalties = [Gwei(0) for _ in range(len(state.validators))]\nprevious_epoch = get_previous_epoch(state)\nmatching_target_indices = get_unslashed_participating_indices(state, TIMELY_TARGET_FLAG_INDEX, previous_epoch)\nfor index in get_eligible_validator_indices(state):\nif index not in matching_target_indices:\npenalty_numerator = state.validators[index].effective_balance * state.inactivity_scores[index]\npenalty_denominator = INACTIVITY_SCORE_BIAS * INACTIVITY_PENALTY_QUOTIENT_ALTAIR\npenalties[index] += Gwei(penalty_numerator // penalty_denominator)\nreturn rewards, penalties\n</code></pre>"},{"location":"specs/altair/beacon-chain/#beacon-state-mutators","title":"Beacon state mutators","text":""},{"location":"specs/altair/beacon-chain/#modified-slash_validator","title":"Modified <code>slash_validator</code>","text":"<p>Note: The function <code>slash_validator</code> is modified to use <code>MIN_SLASHING_PENALTY_QUOTIENT_ALTAIR</code> and use <code>PROPOSER_WEIGHT</code> when calculating the proposer reward.</p> <pre><code>def slash_validator(state: BeaconState,\nslashed_index: ValidatorIndex,\nwhistleblower_index: ValidatorIndex=None) -&gt; None:\n\"\"\"\n    Slash the validator with index ``slashed_index``.\n    \"\"\"\nepoch = get_current_epoch(state)\ninitiate_validator_exit(state, slashed_index)\nvalidator = state.validators[slashed_index]\nvalidator.slashed = True\nvalidator.withdrawable_epoch = max(validator.withdrawable_epoch, Epoch(epoch + EPOCHS_PER_SLASHINGS_VECTOR))\nstate.slashings[epoch % EPOCHS_PER_SLASHINGS_VECTOR] += validator.effective_balance\ndecrease_balance(state, slashed_index, validator.effective_balance // MIN_SLASHING_PENALTY_QUOTIENT_ALTAIR)\n# Apply proposer and whistleblower rewards\nproposer_index = get_beacon_proposer_index(state)\nif whistleblower_index is None:\nwhistleblower_index = proposer_index\nwhistleblower_reward = Gwei(validator.effective_balance // WHISTLEBLOWER_REWARD_QUOTIENT)\nproposer_reward = Gwei(whistleblower_reward * PROPOSER_WEIGHT // WEIGHT_DENOMINATOR)\nincrease_balance(state, proposer_index, proposer_reward)\nincrease_balance(state, whistleblower_index, Gwei(whistleblower_reward - proposer_reward))\n</code></pre>"},{"location":"specs/altair/beacon-chain/#block-processing","title":"Block processing","text":"<pre><code>def process_block(state: BeaconState, block: BeaconBlock) -&gt; None:\nprocess_block_header(state, block)\nprocess_randao(state, block.body)\nprocess_eth1_data(state, block.body)\nprocess_operations(state, block.body)  # [Modified in Altair]\nprocess_sync_aggregate(state, block.body.sync_aggregate)  # [New in Altair]\n</code></pre>"},{"location":"specs/altair/beacon-chain/#modified-process_attestation","title":"Modified <code>process_attestation</code>","text":"<p>Note: The function <code>process_attestation</code> is modified to do incentive accounting with epoch participation flags.</p> <pre><code>def process_attestation(state: BeaconState, attestation: Attestation) -&gt; None:\ndata = attestation.data\nassert data.target.epoch in (get_previous_epoch(state), get_current_epoch(state))\nassert data.target.epoch == compute_epoch_at_slot(data.slot)\nassert data.slot + MIN_ATTESTATION_INCLUSION_DELAY &lt;= state.slot &lt;= data.slot + SLOTS_PER_EPOCH\nassert data.index &lt; get_committee_count_per_slot(state, data.target.epoch)\ncommittee = get_beacon_committee(state, data.slot, data.index)\nassert len(attestation.aggregation_bits) == len(committee)\n# Participation flag indices\nparticipation_flag_indices = get_attestation_participation_flag_indices(state, data, state.slot - data.slot)\n# Verify signature\nassert is_valid_indexed_attestation(state, get_indexed_attestation(state, attestation))\n# Update epoch participation flags\nif data.target.epoch == get_current_epoch(state):\nepoch_participation = state.current_epoch_participation\nelse:\nepoch_participation = state.previous_epoch_participation\nproposer_reward_numerator = 0\nfor index in get_attesting_indices(state, attestation):\nfor flag_index, weight in enumerate(PARTICIPATION_FLAG_WEIGHTS):\nif flag_index in participation_flag_indices and not has_flag(epoch_participation[index], flag_index):\nepoch_participation[index] = add_flag(epoch_participation[index], flag_index)\nproposer_reward_numerator += get_base_reward(state, index) * weight\n# Reward proposer\nproposer_reward_denominator = (WEIGHT_DENOMINATOR - PROPOSER_WEIGHT) * WEIGHT_DENOMINATOR // PROPOSER_WEIGHT\nproposer_reward = Gwei(proposer_reward_numerator // proposer_reward_denominator)\nincrease_balance(state, get_beacon_proposer_index(state), proposer_reward)\n</code></pre>"},{"location":"specs/altair/beacon-chain/#modified-add_validator_to_registry","title":"Modified <code>add_validator_to_registry</code>","text":"<p>Note: The function <code>add_validator_to_registry</code> is modified to initialize <code>inactivity_scores</code>, <code>previous_epoch_participation</code>, and <code>current_epoch_participation</code>.</p> <pre><code>def add_validator_to_registry(state: BeaconState,\npubkey: BLSPubkey,\nwithdrawal_credentials: Bytes32,\namount: uint64) -&gt; None:\nindex = get_index_for_new_validator(state)\nvalidator = get_validator_from_deposit(pubkey, withdrawal_credentials, amount)\nset_or_append_list(state.validators, index, validator)\nset_or_append_list(state.balances, index, amount)\n# [New in Altair]\nset_or_append_list(state.previous_epoch_participation, index, ParticipationFlags(0b0000_0000))\nset_or_append_list(state.current_epoch_participation, index, ParticipationFlags(0b0000_0000))\nset_or_append_list(state.inactivity_scores, index, uint64(0))\n</code></pre>"},{"location":"specs/altair/beacon-chain/#sync-aggregate-processing","title":"Sync aggregate processing","text":"<p>Note: The function <code>process_sync_aggregate</code> is new.</p> <pre><code>def process_sync_aggregate(state: BeaconState, sync_aggregate: SyncAggregate) -&gt; None:\n# Verify sync committee aggregate signature signing over the previous slot block root\ncommittee_pubkeys = state.current_sync_committee.pubkeys\nparticipant_pubkeys = [pubkey for pubkey, bit in zip(committee_pubkeys, sync_aggregate.sync_committee_bits) if bit]\nprevious_slot = max(state.slot, Slot(1)) - Slot(1)\ndomain = get_domain(state, DOMAIN_SYNC_COMMITTEE, compute_epoch_at_slot(previous_slot))\nsigning_root = compute_signing_root(get_block_root_at_slot(state, previous_slot), domain)\nassert eth_fast_aggregate_verify(participant_pubkeys, signing_root, sync_aggregate.sync_committee_signature)\n# Compute participant and proposer rewards\ntotal_active_increments = get_total_active_balance(state) // EFFECTIVE_BALANCE_INCREMENT\ntotal_base_rewards = Gwei(get_base_reward_per_increment(state) * total_active_increments)\nmax_participant_rewards = Gwei(total_base_rewards * SYNC_REWARD_WEIGHT // WEIGHT_DENOMINATOR // SLOTS_PER_EPOCH)\nparticipant_reward = Gwei(max_participant_rewards // SYNC_COMMITTEE_SIZE)\nproposer_reward = Gwei(participant_reward * PROPOSER_WEIGHT // (WEIGHT_DENOMINATOR - PROPOSER_WEIGHT))\n# Apply participant and proposer rewards\nall_pubkeys = [v.pubkey for v in state.validators]\ncommittee_indices = [ValidatorIndex(all_pubkeys.index(pubkey)) for pubkey in state.current_sync_committee.pubkeys]\nfor participant_index, participation_bit in zip(committee_indices, sync_aggregate.sync_committee_bits):\nif participation_bit:\nincrease_balance(state, participant_index, participant_reward)\nincrease_balance(state, get_beacon_proposer_index(state), proposer_reward)\nelse:\ndecrease_balance(state, participant_index, participant_reward)\n</code></pre>"},{"location":"specs/altair/beacon-chain/#epoch-processing","title":"Epoch processing","text":"<pre><code>def process_epoch(state: BeaconState) -&gt; None:\nprocess_justification_and_finalization(state)  # [Modified in Altair]\nprocess_inactivity_updates(state)  # [New in Altair]\nprocess_rewards_and_penalties(state)  # [Modified in Altair]\nprocess_registry_updates(state)\nprocess_slashings(state)  # [Modified in Altair]\nprocess_eth1_data_reset(state)\nprocess_effective_balance_updates(state)\nprocess_slashings_reset(state)\nprocess_randao_mixes_reset(state)\nprocess_historical_roots_update(state)\nprocess_participation_flag_updates(state)  # [New in Altair]\nprocess_sync_committee_updates(state)  # [New in Altair]\n</code></pre>"},{"location":"specs/altair/beacon-chain/#justification-and-finalization","title":"Justification and finalization","text":"<p>Note: The function <code>process_justification_and_finalization</code> is modified to adapt to the new participation records.</p> <pre><code>def process_justification_and_finalization(state: BeaconState) -&gt; None:\n# Initial FFG checkpoint values have a `0x00` stub for `root`.\n# Skip FFG updates in the first two epochs to avoid corner cases that might result in modifying this stub.\nif get_current_epoch(state) &lt;= GENESIS_EPOCH + 1:\nreturn\nprevious_indices = get_unslashed_participating_indices(state, TIMELY_TARGET_FLAG_INDEX, get_previous_epoch(state))\ncurrent_indices = get_unslashed_participating_indices(state, TIMELY_TARGET_FLAG_INDEX, get_current_epoch(state))\ntotal_active_balance = get_total_active_balance(state)\nprevious_target_balance = get_total_balance(state, previous_indices)\ncurrent_target_balance = get_total_balance(state, current_indices)\nweigh_justification_and_finalization(state, total_active_balance, previous_target_balance, current_target_balance)\n</code></pre>"},{"location":"specs/altair/beacon-chain/#inactivity-scores","title":"Inactivity scores","text":"<p>Note: The function <code>process_inactivity_updates</code> is new.</p> <pre><code>def process_inactivity_updates(state: BeaconState) -&gt; None:\n# Skip the genesis epoch as score updates are based on the previous epoch participation\nif get_current_epoch(state) == GENESIS_EPOCH:\nreturn\nfor index in get_eligible_validator_indices(state):\n# Increase the inactivity score of inactive validators\nif index in get_unslashed_participating_indices(state, TIMELY_TARGET_FLAG_INDEX, get_previous_epoch(state)):\nstate.inactivity_scores[index] -= min(1, state.inactivity_scores[index])\nelse:\nstate.inactivity_scores[index] += INACTIVITY_SCORE_BIAS\n# Decrease the inactivity score of all eligible validators during a leak-free epoch\nif not is_in_inactivity_leak(state):\nstate.inactivity_scores[index] -= min(INACTIVITY_SCORE_RECOVERY_RATE, state.inactivity_scores[index])\n</code></pre>"},{"location":"specs/altair/beacon-chain/#rewards-and-penalties","title":"Rewards and penalties","text":"<p>Note: The function <code>process_rewards_and_penalties</code> is modified to support the incentive accounting reforms.</p> <pre><code>def process_rewards_and_penalties(state: BeaconState) -&gt; None:\n# No rewards are applied at the end of `GENESIS_EPOCH` because rewards are for work done in the previous epoch\nif get_current_epoch(state) == GENESIS_EPOCH:\nreturn\nflag_deltas = [get_flag_index_deltas(state, flag_index) for flag_index in range(len(PARTICIPATION_FLAG_WEIGHTS))]\ndeltas = flag_deltas + [get_inactivity_penalty_deltas(state)]\nfor (rewards, penalties) in deltas:\nfor index in range(len(state.validators)):\nincrease_balance(state, ValidatorIndex(index), rewards[index])\ndecrease_balance(state, ValidatorIndex(index), penalties[index])\n</code></pre>"},{"location":"specs/altair/beacon-chain/#slashings","title":"Slashings","text":"<p>Note: The function <code>process_slashings</code> is modified to use <code>PROPORTIONAL_SLASHING_MULTIPLIER_ALTAIR</code>.</p> <pre><code>def process_slashings(state: BeaconState) -&gt; None:\nepoch = get_current_epoch(state)\ntotal_balance = get_total_active_balance(state)\nadjusted_total_slashing_balance = min(sum(state.slashings) * PROPORTIONAL_SLASHING_MULTIPLIER_ALTAIR, total_balance)\nfor index, validator in enumerate(state.validators):\nif validator.slashed and epoch + EPOCHS_PER_SLASHINGS_VECTOR // 2 == validator.withdrawable_epoch:\nincrement = EFFECTIVE_BALANCE_INCREMENT  # Factored out from penalty numerator to avoid uint64 overflow\npenalty_numerator = validator.effective_balance // increment * adjusted_total_slashing_balance\npenalty = penalty_numerator // total_balance * increment\ndecrease_balance(state, ValidatorIndex(index), penalty)\n</code></pre>"},{"location":"specs/altair/beacon-chain/#participation-flags-updates","title":"Participation flags updates","text":"<p>Note: The function <code>process_participation_flag_updates</code> is new.</p> <pre><code>def process_participation_flag_updates(state: BeaconState) -&gt; None:\nstate.previous_epoch_participation = state.current_epoch_participation\nstate.current_epoch_participation = [ParticipationFlags(0b0000_0000) for _ in range(len(state.validators))]\n</code></pre>"},{"location":"specs/altair/beacon-chain/#sync-committee-updates","title":"Sync committee updates","text":"<p>Note: The function <code>process_sync_committee_updates</code> is new.</p> <pre><code>def process_sync_committee_updates(state: BeaconState) -&gt; None:\nnext_epoch = get_current_epoch(state) + Epoch(1)\nif next_epoch % EPOCHS_PER_SYNC_COMMITTEE_PERIOD == 0:\nstate.current_sync_committee = state.next_sync_committee\nstate.next_sync_committee = get_next_sync_committee(state)\n</code></pre>"},{"location":"specs/altair/beacon-chain/#initialize-state-for-pure-altair-testnets-and-test-vectors","title":"Initialize state for pure Altair testnets and test vectors","text":"<p>This helper function is only for initializing the state for pure Altair testnets and tests.</p> <p>Note: The function <code>initialize_beacon_state_from_eth1</code> is modified: (1) using <code>ALTAIR_FORK_VERSION</code> as the previous and current fork version, (2) utilizing the Altair <code>BeaconBlockBody</code> when constructing the initial <code>latest_block_header</code>, and (3) adding initial sync committees.</p> <pre><code>def initialize_beacon_state_from_eth1(eth1_block_hash: Hash32,\neth1_timestamp: uint64,\ndeposits: Sequence[Deposit]) -&gt; BeaconState:\nfork = Fork(\nprevious_version=ALTAIR_FORK_VERSION,  # [Modified in Altair] for testing only\ncurrent_version=ALTAIR_FORK_VERSION,  # [Modified in Altair]\nepoch=GENESIS_EPOCH,\n)\nstate = BeaconState(\ngenesis_time=eth1_timestamp + GENESIS_DELAY,\nfork=fork,\neth1_data=Eth1Data(block_hash=eth1_block_hash, deposit_count=uint64(len(deposits))),\nlatest_block_header=BeaconBlockHeader(body_root=hash_tree_root(BeaconBlockBody())),\nrandao_mixes=[eth1_block_hash] * EPOCHS_PER_HISTORICAL_VECTOR,  # Seed RANDAO with Eth1 entropy\n)\n# Process deposits\nleaves = list(map(lambda deposit: deposit.data, deposits))\nfor index, deposit in enumerate(deposits):\ndeposit_data_list = List[DepositData, 2**DEPOSIT_CONTRACT_TREE_DEPTH](*leaves[:index + 1])\nstate.eth1_data.deposit_root = hash_tree_root(deposit_data_list)\nprocess_deposit(state, deposit)\n# Process activations\nfor index, validator in enumerate(state.validators):\nbalance = state.balances[index]\nvalidator.effective_balance = min(balance - balance % EFFECTIVE_BALANCE_INCREMENT, MAX_EFFECTIVE_BALANCE)\nif validator.effective_balance == MAX_EFFECTIVE_BALANCE:\nvalidator.activation_eligibility_epoch = GENESIS_EPOCH\nvalidator.activation_epoch = GENESIS_EPOCH\n# Set genesis validators root for domain separation and chain versioning\nstate.genesis_validators_root = hash_tree_root(state.validators)\n# [New in Altair] Fill in sync committees\n# Note: A duplicate committee is assigned for the current and next committee at genesis\nstate.current_sync_committee = get_next_sync_committee(state)\nstate.next_sync_committee = get_next_sync_committee(state)\nreturn state\n</code></pre>"},{"location":"specs/altair/bls/","title":"Altair -- BLS extensions","text":""},{"location":"specs/altair/bls/#table-of-contents","title":"Table of contents","text":"<ul> <li>Introduction</li> <li>Constants</li> <li>Extensions</li> <li><code>eth_aggregate_pubkeys</code></li> <li><code>eth_fast_aggregate_verify</code></li> </ul>"},{"location":"specs/altair/bls/#introduction","title":"Introduction","text":"<p>A number of extensions are defined to handle BLS signatures in the Altair upgrade.</p> <p>Knowledge of the phase 0 specification is assumed, including type definitions.</p>"},{"location":"specs/altair/bls/#constants","title":"Constants","text":"Name Value <code>G2_POINT_AT_INFINITY</code> <code>BLSSignature(b'\\xc0' + b'\\x00' * 95)</code>"},{"location":"specs/altair/bls/#extensions","title":"Extensions","text":""},{"location":"specs/altair/bls/#eth_aggregate_pubkeys","title":"<code>eth_aggregate_pubkeys</code>","text":"<p>An additional function <code>AggregatePKs</code> is defined to extend the IETF BLS signature draft standard v4 spec referenced in the phase 0 document.</p> <pre><code>def eth_aggregate_pubkeys(pubkeys: Sequence[BLSPubkey]) -&gt; BLSPubkey:\n\"\"\"\n    Return the aggregate public key for the public keys in ``pubkeys``.\n    NOTE: the ``+`` operation should be interpreted as elliptic curve point addition, which takes as input\n    elliptic curve points that must be decoded from the input ``BLSPubkey``s.\n    This implementation is for demonstrative purposes only and ignores encoding/decoding concerns.\n    Refer to the BLS signature draft standard for more information.\n    \"\"\"\nassert len(pubkeys) &gt; 0\n# Ensure that the given inputs are valid pubkeys\nassert all(bls.KeyValidate(pubkey) for pubkey in pubkeys)\nresult = copy(pubkeys[0])\nfor pubkey in pubkeys[1:]:\nresult += pubkey\nreturn result\n</code></pre>"},{"location":"specs/altair/bls/#eth_fast_aggregate_verify","title":"<code>eth_fast_aggregate_verify</code>","text":"<pre><code>def eth_fast_aggregate_verify(pubkeys: Sequence[BLSPubkey], message: Bytes32, signature: BLSSignature) -&gt; bool:\n\"\"\"\n    Wrapper to ``bls.FastAggregateVerify`` accepting the ``G2_POINT_AT_INFINITY`` signature when ``pubkeys`` is empty.\n    \"\"\"\nif len(pubkeys) == 0 and signature == G2_POINT_AT_INFINITY:\nreturn True\nreturn bls.FastAggregateVerify(pubkeys, message, signature)\n</code></pre>"},{"location":"specs/altair/fork/","title":"Altair -- Fork Logic","text":""},{"location":"specs/altair/fork/#table-of-contents","title":"Table of contents","text":"<ul> <li>Introduction</li> <li>Configuration</li> <li>Helper functions</li> <li>Misc<ul> <li><code>compute_fork_version</code></li> </ul> </li> <li>Fork to Altair</li> <li>Fork trigger</li> <li>Upgrading the state</li> </ul>"},{"location":"specs/altair/fork/#introduction","title":"Introduction","text":"<p>This document describes the process of the first upgrade of the beacon chain: the Altair hard fork, introducing light client support and other improvements.</p>"},{"location":"specs/altair/fork/#configuration","title":"Configuration","text":"Name Value <code>ALTAIR_FORK_VERSION</code> <code>Version('0x01000000')</code> <code>ALTAIR_FORK_EPOCH</code> <code>Epoch(74240)</code> (Oct 27, 2021, 10:56:23am UTC)"},{"location":"specs/altair/fork/#helper-functions","title":"Helper functions","text":""},{"location":"specs/altair/fork/#misc","title":"Misc","text":""},{"location":"specs/altair/fork/#compute_fork_version","title":"<code>compute_fork_version</code>","text":"<pre><code>def compute_fork_version(epoch: Epoch) -&gt; Version:\n\"\"\"\n    Return the fork version at the given ``epoch``.\n    \"\"\"\nif epoch &gt;= ALTAIR_FORK_EPOCH:\nreturn ALTAIR_FORK_VERSION\nreturn GENESIS_FORK_VERSION\n</code></pre>"},{"location":"specs/altair/fork/#fork-to-altair","title":"Fork to Altair","text":""},{"location":"specs/altair/fork/#fork-trigger","title":"Fork trigger","text":"<p>The fork is triggered at epoch <code>ALTAIR_FORK_EPOCH</code>.</p> <p>Note that for the pure Altair networks, we don't apply <code>upgrade_to_altair</code> since it starts with Altair version logic.</p>"},{"location":"specs/altair/fork/#upgrading-the-state","title":"Upgrading the state","text":"<p>If <code>state.slot % SLOTS_PER_EPOCH == 0</code> and <code>compute_epoch_at_slot(state.slot) == ALTAIR_FORK_EPOCH</code>, an irregular state change is made to upgrade to Altair.</p> <p>The upgrade occurs after the completion of the inner loop of <code>process_slots</code> that sets <code>state.slot</code> equal to <code>ALTAIR_FORK_EPOCH * SLOTS_PER_EPOCH</code>. Care must be taken when transitioning through the fork boundary as implementations will need a modified state transition function that deviates from the Phase 0 document. In particular, the outer <code>state_transition</code> function defined in the Phase 0 document will not expose the precise fork slot to execute the upgrade in the presence of skipped slots at the fork boundary. Instead the logic must be within <code>process_slots</code>.</p> <pre><code>def translate_participation(state: BeaconState, pending_attestations: Sequence[phase0.PendingAttestation]) -&gt; None:\nfor attestation in pending_attestations:\ndata = attestation.data\ninclusion_delay = attestation.inclusion_delay\n# Translate attestation inclusion info to flag indices\nparticipation_flag_indices = get_attestation_participation_flag_indices(state, data, inclusion_delay)\n# Apply flags to all attesting validators\nepoch_participation = state.previous_epoch_participation\nfor index in get_attesting_indices(state, attestation):\nfor flag_index in participation_flag_indices:\nepoch_participation[index] = add_flag(epoch_participation[index], flag_index)\ndef upgrade_to_altair(pre: phase0.BeaconState) -&gt; BeaconState:\nepoch = phase0.get_current_epoch(pre)\npost = BeaconState(\n# Versioning\ngenesis_time=pre.genesis_time,\ngenesis_validators_root=pre.genesis_validators_root,\nslot=pre.slot,\nfork=Fork(\nprevious_version=pre.fork.current_version,\ncurrent_version=ALTAIR_FORK_VERSION,\nepoch=epoch,\n),\n# History\nlatest_block_header=pre.latest_block_header,\nblock_roots=pre.block_roots,\nstate_roots=pre.state_roots,\nhistorical_roots=pre.historical_roots,\n# Eth1\neth1_data=pre.eth1_data,\neth1_data_votes=pre.eth1_data_votes,\neth1_deposit_index=pre.eth1_deposit_index,\n# Registry\nvalidators=pre.validators,\nbalances=pre.balances,\n# Randomness\nrandao_mixes=pre.randao_mixes,\n# Slashings\nslashings=pre.slashings,\n# Participation\nprevious_epoch_participation=[ParticipationFlags(0b0000_0000) for _ in range(len(pre.validators))],\ncurrent_epoch_participation=[ParticipationFlags(0b0000_0000) for _ in range(len(pre.validators))],\n# Finality\njustification_bits=pre.justification_bits,\nprevious_justified_checkpoint=pre.previous_justified_checkpoint,\ncurrent_justified_checkpoint=pre.current_justified_checkpoint,\nfinalized_checkpoint=pre.finalized_checkpoint,\n# Inactivity\ninactivity_scores=[uint64(0) for _ in range(len(pre.validators))],\n)\n# Fill in previous epoch participation from the pre state's pending attestations\ntranslate_participation(post, pre.previous_epoch_attestations)\n# Fill in sync committees\n# Note: A duplicate committee is assigned for the current and next committee at the fork boundary\npost.current_sync_committee = get_next_sync_committee(post)\npost.next_sync_committee = get_next_sync_committee(post)\nreturn post\n</code></pre>"},{"location":"specs/altair/p2p-interface/","title":"Altair -- Networking","text":"<p>This document contains the networking specification for Altair. This document should be viewed as additive to the document from Phase 0 and will be referred to as the \"Phase 0 document\" hereafter. Readers should understand the Phase 0 document and use it as a basis to understand the changes outlined in this document.</p> <p>Altair adds new messages, topics and data to the Req-Resp, Gossip and Discovery domain. Some Phase 0 features will be deprecated, but not removed immediately.</p>"},{"location":"specs/altair/p2p-interface/#table-of-contents","title":"Table of contents","text":"<ul> <li>Modifications in Altair</li> <li>MetaData</li> <li>The gossip domain: gossipsub<ul> <li>Topics and messages</li> <li>Global topics<ul> <li><code>beacon_block</code></li> <li><code>sync_committee_contribution_and_proof</code></li> </ul> </li> <li>Sync committee subnets<ul> <li><code>sync_committee_{subnet_id}</code></li> </ul> </li> <li>Sync committees and aggregation</li> <li>Transitioning the gossip</li> </ul> </li> <li>The Req/Resp domain<ul> <li>Req-Resp interaction</li> <li><code>ForkDigest</code>-context</li> <li>Messages</li> <li>BeaconBlocksByRange v2</li> <li>BeaconBlocksByRoot v2</li> <li>GetMetaData v2</li> <li>Transitioning from v1 to v2</li> </ul> </li> <li>The discovery domain: discv5<ul> <li>ENR structure</li> <li>Sync committee bitfield</li> </ul> </li> </ul>"},{"location":"specs/altair/p2p-interface/#modifications-in-altair","title":"Modifications in Altair","text":""},{"location":"specs/altair/p2p-interface/#metadata","title":"MetaData","text":"<p>The <code>MetaData</code> stored locally by clients is updated with an additional field to communicate the sync committee subnet subscriptions:</p> <pre><code>(\n  seq_number: uint64\n  attnets: Bitvector[ATTESTATION_SUBNET_COUNT]\n  syncnets: Bitvector[SYNC_COMMITTEE_SUBNET_COUNT]\n)\n</code></pre> <p>Where</p> <ul> <li><code>seq_number</code> and <code>attnets</code> have the same meaning defined in the Phase 0 document.</li> <li><code>syncnets</code> is a <code>Bitvector</code> representing the node's sync committee subnet subscriptions. This field should mirror the data in the node's ENR as outlined in the validator guide.</li> </ul>"},{"location":"specs/altair/p2p-interface/#the-gossip-domain-gossipsub","title":"The gossip domain: gossipsub","text":"<p>Gossip meshes are added in Altair to support the consensus activities of the sync committees. Validators use an aggregation scheme to balance the processing and networking load across all of the relevant actors.</p>"},{"location":"specs/altair/p2p-interface/#topics-and-messages","title":"Topics and messages","text":"<p>Topics follow the same specification as in the Phase 0 document. New topics are added in Altair to support the sync committees and the beacon block topic is updated with the modified type.</p> <p>The specification around the creation, validation, and dissemination of messages has not changed from the Phase 0 document.</p> <p>The derivation of the <code>message-id</code> has changed starting with Altair to incorporate the message <code>topic</code> along with the message <code>data</code>. These are fields of the <code>Message</code> Protobuf, and interpreted as empty byte strings if missing. The <code>message-id</code> MUST be the following 20 byte value computed from the message: * If <code>message.data</code> has a valid snappy decompression, set <code>message-id</code> to the first 20 bytes of the <code>SHA256</code> hash of   the concatenation of the following data: <code>MESSAGE_DOMAIN_VALID_SNAPPY</code>, the length of the topic byte string (encoded as little-endian <code>uint64</code>),   the topic byte string, and the snappy decompressed message data:   i.e. <code>SHA256(MESSAGE_DOMAIN_VALID_SNAPPY + uint_to_bytes(uint64(len(message.topic))) + message.topic + snappy_decompress(message.data))[:20]</code>. * Otherwise, set <code>message-id</code> to the first 20 bytes of the <code>SHA256</code> hash of   the concatenation of the following data: <code>MESSAGE_DOMAIN_INVALID_SNAPPY</code>, the length of the topic byte string (encoded as little-endian <code>uint64</code>),   the topic byte string, and the raw message data:   i.e. <code>SHA256(MESSAGE_DOMAIN_INVALID_SNAPPY + uint_to_bytes(uint64(len(message.topic))) + message.topic + message.data)[:20]</code>.</p> <p>Implementations may need to carefully handle the function that computes the <code>message-id</code>. In particular, messages on topics with the Phase 0 fork digest should use the <code>message-id</code> procedure specified in the Phase 0 document. Messages on topics with the Altair fork digest should use the <code>message-id</code> procedure defined here. If an implementation only supports a single <code>message-id</code> function, it can define a switch inline; for example, <code>if topic in phase0_topics: return phase0_msg_id_fn(message) else return altair_msg_id_fn(message)</code>.</p> <p>The new topics along with the type of the <code>data</code> field of a gossipsub message are given in this table:</p> Name Message Type <code>beacon_block</code> <code>SignedBeaconBlock</code> (modified) <code>sync_committee_contribution_and_proof</code> <code>SignedContributionAndProof</code> <code>sync_committee_{subnet_id}</code> <code>SyncCommitteeMessage</code> <p>Definitions of these new types can be found in the Altair validator guide.</p> <p>Note that the <code>ForkDigestValue</code> path segment of the topic separates the old and the new <code>beacon_block</code> topics.</p>"},{"location":"specs/altair/p2p-interface/#global-topics","title":"Global topics","text":"<p>Altair changes the type of the global beacon block topic and adds one global topic to propagate partially aggregated sync committee messages to all potential proposers of beacon blocks.</p>"},{"location":"specs/altair/p2p-interface/#beacon_block","title":"<code>beacon_block</code>","text":"<p>The existing specification for this topic does not change from the Phase 0 document, but the type of the payload does change to the (modified) <code>SignedBeaconBlock</code>. This type changes due to the inclusion of the inner <code>BeaconBlockBody</code> that is modified in Altair.</p> <p>See the state transition document for Altair for further details.</p>"},{"location":"specs/altair/p2p-interface/#sync_committee_contribution_and_proof","title":"<code>sync_committee_contribution_and_proof</code>","text":"<p>This topic is used to propagate partially aggregated sync committee messages to be included in future blocks.</p> <p>The following validations MUST pass before forwarding the <code>signed_contribution_and_proof</code> on the network; define <code>contribution_and_proof = signed_contribution_and_proof.message</code>, <code>contribution = contribution_and_proof.contribution</code>, and the following function <code>get_sync_subcommittee_pubkeys</code> for convenience:</p> <pre><code>def get_sync_subcommittee_pubkeys(state: BeaconState, subcommittee_index: uint64) -&gt; Sequence[BLSPubkey]:\n# Committees assigned to `slot` sign for `slot - 1`\n# This creates the exceptional logic below when transitioning between sync committee periods\nnext_slot_epoch = compute_epoch_at_slot(Slot(state.slot + 1))\nif compute_sync_committee_period(get_current_epoch(state)) == compute_sync_committee_period(next_slot_epoch):\nsync_committee = state.current_sync_committee\nelse:\nsync_committee = state.next_sync_committee\n# Return pubkeys for the subcommittee index\nsync_subcommittee_size = SYNC_COMMITTEE_SIZE // SYNC_COMMITTEE_SUBNET_COUNT\ni = subcommittee_index * sync_subcommittee_size\nreturn sync_committee.pubkeys[i:i + sync_subcommittee_size]\n</code></pre> <ul> <li>[IGNORE] The contribution's slot is for the current slot (with a <code>MAXIMUM_GOSSIP_CLOCK_DISPARITY</code> allowance), i.e. <code>contribution.slot == current_slot</code>.</li> <li>[REJECT] The subcommittee index is in the allowed range, i.e. <code>contribution.subcommittee_index &lt; SYNC_COMMITTEE_SUBNET_COUNT</code>.</li> <li>[REJECT] The contribution has participants --   that is, <code>any(contribution.aggregation_bits)</code>.</li> <li>[REJECT] <code>contribution_and_proof.selection_proof</code> selects the validator as an aggregator for the slot -- i.e. <code>is_sync_committee_aggregator(contribution_and_proof.selection_proof)</code> returns <code>True</code>.</li> <li>[REJECT] The aggregator's validator index is in the declared subcommittee of the current sync committee --   i.e. <code>state.validators[contribution_and_proof.aggregator_index].pubkey in get_sync_subcommittee_pubkeys(state, contribution.subcommittee_index)</code>.</li> <li>[IGNORE] A valid sync committee contribution with equal <code>slot</code>, <code>beacon_block_root</code> and <code>subcommittee_index</code> whose <code>aggregation_bits</code> is non-strict superset has not already been seen.</li> <li>[IGNORE] The sync committee contribution is the first valid contribution received for the aggregator with index <code>contribution_and_proof.aggregator_index</code>   for the slot <code>contribution.slot</code> and subcommittee index <code>contribution.subcommittee_index</code>   (this requires maintaining a cache of size <code>SYNC_COMMITTEE_SIZE</code> for this topic that can be flushed after each slot).</li> <li>[REJECT] The <code>contribution_and_proof.selection_proof</code> is a valid signature of the <code>SyncAggregatorSelectionData</code> derived from the <code>contribution</code> by the validator with index <code>contribution_and_proof.aggregator_index</code>.</li> <li>[REJECT] The aggregator signature, <code>signed_contribution_and_proof.signature</code>, is valid.</li> <li>[REJECT] The aggregate signature is valid for the message <code>beacon_block_root</code> and aggregate pubkey derived from the participation info in <code>aggregation_bits</code> for the subcommittee specified by the <code>contribution.subcommittee_index</code>.</li> </ul>"},{"location":"specs/altair/p2p-interface/#sync-committee-subnets","title":"Sync committee subnets","text":"<p>Sync committee subnets are used to propagate unaggregated sync committee messages to subsections of the network.</p>"},{"location":"specs/altair/p2p-interface/#sync_committee_subnet_id","title":"<code>sync_committee_{subnet_id}</code>","text":"<p>The <code>sync_committee_{subnet_id}</code> topics are used to propagate unaggregated sync committee messages to the subnet <code>subnet_id</code> to be aggregated before being gossiped to the global <code>sync_committee_contribution_and_proof</code> topic.</p> <p>The following validations MUST pass before forwarding the <code>sync_committee_message</code> on the network:</p> <ul> <li>[IGNORE] The message's slot is for the current slot (with a <code>MAXIMUM_GOSSIP_CLOCK_DISPARITY</code> allowance), i.e. <code>sync_committee_message.slot == current_slot</code>.</li> <li>[REJECT] The <code>subnet_id</code> is valid for the given validator, i.e. <code>subnet_id in compute_subnets_for_sync_committee(state, sync_committee_message.validator_index)</code>.   Note this validation implies the validator is part of the broader current sync committee along with the correct subcommittee.</li> <li>[IGNORE] There has been no other valid sync committee message for the declared <code>slot</code> for the validator referenced by <code>sync_committee_message.validator_index</code>   (this requires maintaining a cache of size <code>SYNC_COMMITTEE_SIZE // SYNC_COMMITTEE_SUBNET_COUNT</code> for each subnet that can be flushed after each slot).   Note this validation is per topic so that for a given <code>slot</code>, multiple messages could be forwarded with the same <code>validator_index</code> as long as the <code>subnet_id</code>s are distinct.</li> <li>[REJECT] The <code>signature</code> is valid for the message <code>beacon_block_root</code> for the validator referenced by <code>validator_index</code>.</li> </ul>"},{"location":"specs/altair/p2p-interface/#sync-committees-and-aggregation","title":"Sync committees and aggregation","text":"<p>The aggregation scheme closely follows the design of the attestation aggregation scheme. Sync committee messages are broadcast into \"subnets\" defined by a topic. The number of subnets is defined by <code>SYNC_COMMITTEE_SUBNET_COUNT</code> in the Altair validator guide. Sync committee members are divided into \"subcommittees\" which are then assigned to a subnet for the duration of tenure in the sync committee. Individual validators can be duplicated in the broader sync committee such that they are included multiple times in a given subcommittee or across multiple subcommittees.</p> <p>Unaggregated messages (along with metadata) are sent as <code>SyncCommitteeMessage</code>s on the <code>sync_committee_{subnet_id}</code> topics.</p> <p>Aggregated sync committee messages are packaged into (signed) <code>SyncCommitteeContribution</code> along with proofs and gossiped to the <code>sync_committee_contribution_and_proof</code> topic.</p>"},{"location":"specs/altair/p2p-interface/#transitioning-the-gossip","title":"Transitioning the gossip","text":"<p>With any fork, the fork version, and thus the <code>ForkDigestValue</code>, change. Message types are unique per topic, and so for a smooth transition a node must temporarily subscribe to both the old and new topics.</p> <p>The topics that are not removed in a fork are updated with a new <code>ForkDigestValue</code>. In advance of the fork, a node SHOULD subscribe to the post-fork variants of the topics.</p> <p>Subscriptions are expected to be well-received, all updated nodes should subscribe as well. Topic-meshes can be grafted quickly as the nodes are already connected and exchanging gossip control messages.</p> <p>Messages SHOULD NOT be re-broadcast from one fork to the other. A node's behavior before the fork and after the fork are as follows: Pre-fork: - Peers who propagate messages on the post-fork topics MAY be scored negatively proportionally to time till fork,   to account for clock discrepancy. - Messages can be IGNORED on the post-fork topics, with a <code>MAXIMUM_GOSSIP_CLOCK_DISPARITY</code> margin.</p> <p>Post-fork: - Peers who propagate messages on the pre-fork topics MUST NOT be scored negatively. Lagging IWANT may force them to. - Messages on pre and post-fork variants of topics share application-level caches.   E.g. an attestation on the both the old and new topic is ignored like any duplicate. - Two epochs after the fork, pre-fork topics SHOULD be unsubscribed from. This is well after the configured <code>seen_ttl</code>.</p>"},{"location":"specs/altair/p2p-interface/#the-reqresp-domain","title":"The Req/Resp domain","text":""},{"location":"specs/altair/p2p-interface/#req-resp-interaction","title":"Req-Resp interaction","text":"<p>An additional <code>&lt;context-bytes&gt;</code> field is introduced to the <code>response_chunk</code> as defined in the Phase 0 document:</p> <pre><code>response_chunk  ::= &lt;result&gt; | &lt;context-bytes&gt; | &lt;encoding-dependent-header&gt; | &lt;encoded-payload&gt;\n</code></pre> <p>All Phase 0 methods are compatible: <code>&lt;context-bytes&gt;</code> is empty by default. On a non-zero <code>&lt;result&gt;</code> with <code>ErrorMessage</code> payload, the <code>&lt;context-bytes&gt;</code> is also empty.</p> <p>In Altair and later forks, <code>&lt;context-bytes&gt;</code> functions as a short meta-data, defined per req-resp method, and can parametrize the payload decoder.</p>"},{"location":"specs/altair/p2p-interface/#forkdigest-context","title":"<code>ForkDigest</code>-context","text":"<p>Starting with Altair, and in future forks, SSZ type definitions may change. For this common case, we define the <code>ForkDigest</code>-context:</p> <p>A fixed-width 4 byte <code>&lt;context-bytes&gt;</code>, set to the <code>ForkDigest</code> matching the chunk:  <code>compute_fork_digest(fork_version, genesis_validators_root)</code>.</p>"},{"location":"specs/altair/p2p-interface/#messages","title":"Messages","text":""},{"location":"specs/altair/p2p-interface/#beaconblocksbyrange-v2","title":"BeaconBlocksByRange v2","text":"<p>Protocol ID: <code>/eth2/beacon_chain/req/beacon_blocks_by_range/2/</code></p> <p>Request and Response remain unchanged. A <code>ForkDigest</code>-context is used to select the fork namespace of the Response type.</p> <p>Per <code>context = compute_fork_digest(fork_version, genesis_validators_root)</code>:</p> <code>fork_version</code> Chunk SSZ type <code>GENESIS_FORK_VERSION</code> <code>phase0.SignedBeaconBlock</code> <code>ALTAIR_FORK_VERSION</code> <code>altair.SignedBeaconBlock</code>"},{"location":"specs/altair/p2p-interface/#beaconblocksbyroot-v2","title":"BeaconBlocksByRoot v2","text":"<p>Protocol ID: <code>/eth2/beacon_chain/req/beacon_blocks_by_root/2/</code></p> <p>Request and Response remain unchanged. A <code>ForkDigest</code>-context is used to select the fork namespace of the Response type.</p> <p>Per <code>context = compute_fork_digest(fork_version, genesis_validators_root)</code>:</p> <code>fork_version</code> Chunk SSZ type <code>GENESIS_FORK_VERSION</code> <code>phase0.SignedBeaconBlock</code> <code>ALTAIR_FORK_VERSION</code> <code>altair.SignedBeaconBlock</code>"},{"location":"specs/altair/p2p-interface/#getmetadata-v2","title":"GetMetaData v2","text":"<p>Protocol ID: <code>/eth2/beacon_chain/req/metadata/2/</code></p> <p>No Request Content.</p> <p>Response Content:</p> <pre><code>(\n  MetaData\n)\n</code></pre> <p>Requests the MetaData of a peer, using the new <code>MetaData</code> definition given above that is extended from phase 0 in Altair. Other conditions for the <code>GetMetaData</code> protocol are unchanged from the phase 0 p2p networking document.</p>"},{"location":"specs/altair/p2p-interface/#transitioning-from-v1-to-v2","title":"Transitioning from v1 to v2","text":"<p>In advance of the fork, implementations can opt in to both run the v1 and v2 for a smooth transition. This is non-breaking, and is recommended as soon as the fork specification is stable.</p> <p>The v1 variants will be deprecated, and implementations should use v2 when available (as negotiated with peers via LibP2P multistream-select).</p> <p>The v1 method MAY be unregistered at the fork boundary. In the event of a request on v1 for an Altair specific payload, the responder MUST return the InvalidRequest response code.</p>"},{"location":"specs/altair/p2p-interface/#the-discovery-domain-discv5","title":"The discovery domain: discv5","text":""},{"location":"specs/altair/p2p-interface/#enr-structure","title":"ENR structure","text":""},{"location":"specs/altair/p2p-interface/#sync-committee-bitfield","title":"Sync committee bitfield","text":"<p>An additional bitfield is added to the ENR under the key <code>syncnets</code> to facilitate sync committee subnet discovery. The length of this bitfield is <code>SYNC_COMMITTEE_SUBNET_COUNT</code> where each bit corresponds to a distinct <code>subnet_id</code> for a specific sync committee subnet. The <code>i</code>th bit is set in this bitfield if the validator is currently subscribed to the <code>sync_committee_{i}</code> topic.</p> Key Value <code>syncnets</code> SSZ <code>Bitvector[SYNC_COMMITTEE_SUBNET_COUNT]</code> <p>See the validator document for further details on how the new bits are used.</p>"},{"location":"specs/altair/validator/","title":"Altair -- Honest Validator","text":"<p>This is an accompanying document to Altair -- The Beacon Chain, which describes the expected actions of a \"validator\" participating in the Ethereum proof-of-stake protocol.</p>"},{"location":"specs/altair/validator/#table-of-contents","title":"Table of contents","text":"<ul> <li>Introduction</li> <li>Prerequisites</li> <li>Constants</li> <li>Misc</li> <li>Containers</li> <li><code>SyncCommitteeMessage</code></li> <li><code>SyncCommitteeContribution</code></li> <li><code>ContributionAndProof</code></li> <li><code>SignedContributionAndProof</code></li> <li><code>SyncAggregatorSelectionData</code></li> <li>Validator assignments</li> <li>Sync Committee</li> <li>Lookahead</li> <li>Beacon chain responsibilities</li> <li>Block proposal<ul> <li>Preparing a <code>BeaconBlock</code></li> <li>Constructing the <code>BeaconBlockBody</code></li> <li>Sync committee</li> <li>Packaging into a <code>SignedBeaconBlock</code></li> </ul> </li> <li>Attesting and attestation aggregation</li> <li>Sync committees<ul> <li>Sync committee messages</li> <li>Prepare sync committee message</li> <li>Broadcast sync committee message</li> <li>Sync committee contributions</li> <li>Aggregation selection</li> <li>Construct sync committee contribution<ul> <li>Slot</li> <li>Beacon block root</li> <li>Subcommittee index</li> <li>Aggregation bits</li> <li>Signature</li> </ul> </li> <li>Broadcast sync committee contribution</li> </ul> </li> <li>Sync committee subnet stability</li> </ul>"},{"location":"specs/altair/validator/#introduction","title":"Introduction","text":"<p>This document represents the expected behavior of an \"honest validator\" with respect to the Altair upgrade of the Ethereum proof-of-stake protocol. It builds on the previous document for the behavior of an \"honest validator\" from Phase 0 of the Ethereum proof-of-stake protocol. This previous document is referred to below as the \"Phase 0 document\".</p> <p>Altair introduces a new type of committee: the sync committee. Sync committees are responsible for signing each block of the canonical chain and there exists an efficient algorithm for light clients to sync the chain using the output of the sync committees. See the sync protocol for further details on the light client sync. Under this network upgrade, validators track their participation in this new committee type and produce the relevant signatures as required. Block proposers incorporate the (aggregated) sync committee signatures into each block they produce.</p>"},{"location":"specs/altair/validator/#prerequisites","title":"Prerequisites","text":"<p>All terminology, constants, functions, and protocol mechanics defined in the Altair -- The Beacon Chain doc are requisite for this document and used throughout. Please see this document before continuing and use as a reference throughout.</p>"},{"location":"specs/altair/validator/#constants","title":"Constants","text":""},{"location":"specs/altair/validator/#misc","title":"Misc","text":"Name Value Unit <code>TARGET_AGGREGATORS_PER_SYNC_SUBCOMMITTEE</code> <code>2**4</code> (= 16) validators <code>SYNC_COMMITTEE_SUBNET_COUNT</code> <code>4</code> The number of sync committee subnets used in the gossipsub aggregation protocol."},{"location":"specs/altair/validator/#containers","title":"Containers","text":""},{"location":"specs/altair/validator/#synccommitteemessage","title":"<code>SyncCommitteeMessage</code>","text":"<pre><code>class SyncCommitteeMessage(Container):\n# Slot to which this contribution pertains\nslot: Slot\n# Block root for this signature\nbeacon_block_root: Root\n# Index of the validator that produced this signature\nvalidator_index: ValidatorIndex\n# Signature by the validator over the block root of `slot`\nsignature: BLSSignature\n</code></pre>"},{"location":"specs/altair/validator/#synccommitteecontribution","title":"<code>SyncCommitteeContribution</code>","text":"<pre><code>class SyncCommitteeContribution(Container):\n# Slot to which this contribution pertains\nslot: Slot\n# Block root for this contribution\nbeacon_block_root: Root\n# The subcommittee this contribution pertains to out of the broader sync committee\nsubcommittee_index: uint64\n# A bit is set if a signature from the validator at the corresponding\n# index in the subcommittee is present in the aggregate `signature`.\naggregation_bits: Bitvector[SYNC_COMMITTEE_SIZE // SYNC_COMMITTEE_SUBNET_COUNT]\n# Signature by the validator(s) over the block root of `slot`\nsignature: BLSSignature\n</code></pre>"},{"location":"specs/altair/validator/#contributionandproof","title":"<code>ContributionAndProof</code>","text":"<pre><code>class ContributionAndProof(Container):\naggregator_index: ValidatorIndex\ncontribution: SyncCommitteeContribution\nselection_proof: BLSSignature\n</code></pre>"},{"location":"specs/altair/validator/#signedcontributionandproof","title":"<code>SignedContributionAndProof</code>","text":"<pre><code>class SignedContributionAndProof(Container):\nmessage: ContributionAndProof\nsignature: BLSSignature\n</code></pre>"},{"location":"specs/altair/validator/#syncaggregatorselectiondata","title":"<code>SyncAggregatorSelectionData</code>","text":"<pre><code>class SyncAggregatorSelectionData(Container):\nslot: Slot\nsubcommittee_index: uint64\n</code></pre>"},{"location":"specs/altair/validator/#validator-assignments","title":"Validator assignments","text":"<p>A validator determines beacon committee assignments and beacon block proposal duties as defined in the Phase 0 document.</p>"},{"location":"specs/altair/validator/#sync-committee","title":"Sync Committee","text":"<p>To determine sync committee assignments, a validator can run the following function: <code>is_assigned_to_sync_committee(state, epoch, validator_index)</code> where <code>epoch</code> is an epoch number within the current or next sync committee period. This function is a predicate indicating the presence or absence of the validator in the corresponding sync committee for the queried sync committee period.</p> <p>Note: Being assigned to a sync committee for a given <code>slot</code> means that the validator produces and broadcasts signatures for <code>slot - 1</code> for inclusion in <code>slot</code>. This means that when assigned to an <code>epoch</code> sync committee signatures must be produced and broadcast for slots on range <code>[compute_start_slot_at_epoch(epoch) - 1, compute_start_slot_at_epoch(epoch) + SLOTS_PER_EPOCH - 1)</code> rather than for the range <code>[compute_start_slot_at_epoch(epoch), compute_start_slot_at_epoch(epoch) + SLOTS_PER_EPOCH)</code>. To reduce complexity during the Altair fork, sync committees are not expected to produce signatures for <code>compute_start_slot_at_epoch(ALTAIR_FORK_EPOCH) - 1</code>.</p> <pre><code>def compute_sync_committee_period(epoch: Epoch) -&gt; uint64:\nreturn epoch // EPOCHS_PER_SYNC_COMMITTEE_PERIOD\n</code></pre> <pre><code>def is_assigned_to_sync_committee(state: BeaconState,\nepoch: Epoch,\nvalidator_index: ValidatorIndex) -&gt; bool:\nsync_committee_period = compute_sync_committee_period(epoch)\ncurrent_epoch = get_current_epoch(state)\ncurrent_sync_committee_period = compute_sync_committee_period(current_epoch)\nnext_sync_committee_period = current_sync_committee_period + 1\nassert sync_committee_period in (current_sync_committee_period, next_sync_committee_period)\npubkey = state.validators[validator_index].pubkey\nif sync_committee_period == current_sync_committee_period:\nreturn pubkey in state.current_sync_committee.pubkeys\nelse:  # sync_committee_period == next_sync_committee_period\nreturn pubkey in state.next_sync_committee.pubkeys\n</code></pre>"},{"location":"specs/altair/validator/#lookahead","title":"Lookahead","text":"<p>The sync committee shufflings give validators 1 sync committee period of lookahead which amounts to <code>EPOCHS_PER_SYNC_COMMITTEE_PERIOD</code> epochs. At any given <code>epoch</code>, the <code>BeaconState</code> contains the current <code>SyncCommittee</code> and the next <code>SyncCommittee</code>. Once every <code>EPOCHS_PER_SYNC_COMMITTEE_PERIOD</code> epochs, the next <code>SyncCommittee</code> becomes the current <code>SyncCommittee</code> and the next committee is computed and stored.</p> <p>Note: The data required to compute a given committee is not cached in the <code>BeaconState</code> after committees are calculated at the period boundaries. For this reason, always get committee assignments via the fields of the <code>BeaconState</code> (<code>current_sync_committee</code> and <code>next_sync_committee</code>) or use the above reference code.</p> <p>A validator should plan for future sync committee assignments by noting which sync committee periods they are selected for participation. Specifically, a validator should: * Upon (re)syncing the chain and upon sync committee period boundaries, check for assignments in the current and next sync committee periods. * If the validator is in the current sync committee period, then they perform the responsibilities below for sync committee rewards. * If the validator is in the next sync committee period, they should wait until the next <code>EPOCHS_PER_SYNC_COMMITTEE_PERIOD</code> boundary and then perform the responsibilities throughout that period.</p>"},{"location":"specs/altair/validator/#beacon-chain-responsibilities","title":"Beacon chain responsibilities","text":"<p>A validator maintains the responsibilities given in the Phase 0 document.</p> <p>Block proposals are modified to incorporate the sync committee signatures as detailed below.</p> <p>When assigned to a sync committee, validators have a new responsibility to sign and broadcast beacon block roots during each slot of the sync committee period. These signatures are aggregated and routed to the proposer over gossip for inclusion into a beacon block. Assignments to a particular sync committee are infrequent at normal validator counts; however, an action every slot is required when in the current active sync committee.</p>"},{"location":"specs/altair/validator/#block-proposal","title":"Block proposal","text":"<p>Refer to the phase 0 document for the majority of the block proposal responsibility. The validator should follow those instructions to prepare a <code>SignedBeaconBlock</code> for inclusion into the chain. All changes are additive to phase 0 and noted below.</p>"},{"location":"specs/altair/validator/#preparing-a-beaconblock","title":"Preparing a <code>BeaconBlock</code>","text":"<p>No change to Preparing for a <code>BeaconBlock</code>.</p>"},{"location":"specs/altair/validator/#constructing-the-beaconblockbody","title":"Constructing the <code>BeaconBlockBody</code>","text":"<p>Each section of Constructing the <code>BeaconBlockBody</code> should be followed. After constructing the <code>BeaconBlockBody</code> as per that section, the proposer has an additional task to include the sync committee signatures:</p>"},{"location":"specs/altair/validator/#sync-committee_1","title":"Sync committee","text":"<p>The proposer receives a number of <code>SyncCommitteeContribution</code>s (wrapped in <code>SignedContributionAndProof</code>s on the wire) from validators in the sync committee who are selected to partially aggregate signatures from independent subcommittees formed by breaking the full sync committee into <code>SYNC_COMMITTEE_SUBNET_COUNT</code> pieces (see below for details).</p> <p>The proposer collects the contributions that match their local view of the chain (i.e. <code>contribution.beacon_block_root == block.parent_root</code>) for further aggregation when preparing a block. Of these contributions, proposers should select the best contribution seen across all aggregators for each subnet/subcommittee. A contribution with more valid signatures is better than a contribution with fewer signatures.</p> <p>Recall <code>block.body.sync_aggregate.sync_committee_bits</code> is a <code>Bitvector</code> where the <code>i</code>th bit is <code>True</code> if the corresponding validator in the sync committee has produced a valid signature, and that <code>block.body.sync_aggregate.sync_committee_signature</code> is the aggregate BLS signature combining all of the valid signatures.</p> <p>Given a collection of the best seen <code>contributions</code> (with no repeating <code>subcommittee_index</code> values) and the <code>BeaconBlock</code> under construction, the proposer processes them as follows:</p> <pre><code>def process_sync_committee_contributions(block: BeaconBlock,\ncontributions: Set[SyncCommitteeContribution]) -&gt; None:\nsync_aggregate = SyncAggregate()\nsignatures = []\nsync_subcommittee_size = SYNC_COMMITTEE_SIZE // SYNC_COMMITTEE_SUBNET_COUNT\nfor contribution in contributions:\nsubcommittee_index = contribution.subcommittee_index\nfor index, participated in enumerate(contribution.aggregation_bits):\nif participated:\nparticipant_index = sync_subcommittee_size * subcommittee_index + index\nsync_aggregate.sync_committee_bits[participant_index] = True\nsignatures.append(contribution.signature)\nsync_aggregate.sync_committee_signature = bls.Aggregate(signatures)\nblock.body.sync_aggregate = sync_aggregate\n</code></pre> <p>Note: The resulting block must pass the validations for the <code>SyncAggregate</code> defined in <code>process_sync_aggregate</code> defined in the state transition document. In particular, this means <code>SyncCommitteeContribution</code>s received from gossip must have a <code>beacon_block_root</code> that matches the proposer's local view of the chain.</p>"},{"location":"specs/altair/validator/#packaging-into-a-signedbeaconblock","title":"Packaging into a <code>SignedBeaconBlock</code>","text":"<p>No change to Packaging into a <code>SignedBeaconBlock</code>.</p>"},{"location":"specs/altair/validator/#attesting-and-attestation-aggregation","title":"Attesting and attestation aggregation","text":"<p>Refer to the phase 0 document for the attesting and attestation aggregation responsibilities. There is no change compared to the phase 0 document.</p>"},{"location":"specs/altair/validator/#sync-committees","title":"Sync committees","text":"<p>Sync committee members employ an aggregation scheme to reduce load on the global proposer channel that is monitored by all potential proposers to be able to include the full output of the sync committee every slot. Sync committee members produce individual signatures on subnets (similar to the attestation subnets) via <code>SyncCommitteeMessage</code>s which are then collected by aggregators sampled from the sync subcommittees to produce a <code>SyncCommitteeContribution</code> which is gossiped to proposers. This process occurs each slot.</p>"},{"location":"specs/altair/validator/#sync-committee-messages","title":"Sync committee messages","text":""},{"location":"specs/altair/validator/#prepare-sync-committee-message","title":"Prepare sync committee message","text":"<p>If a validator is in the current sync committee (i.e. <code>is_assigned_to_sync_committee()</code> above returns <code>True</code>), then for every <code>slot</code> in the current sync committee period, the validator should prepare a <code>SyncCommitteeMessage</code> for the previous slot (<code>slot - 1</code>) according to the logic in <code>get_sync_committee_message</code> as soon as they have determined the head block of <code>slot - 1</code>. This means that when assigned to <code>slot</code> a <code>SyncCommitteeMessage</code> is prepared and broadcast in <code>slot-1</code> instead of <code>slot</code>.</p> <p>This logic is triggered upon the same conditions as when producing an attestation. Meaning, a sync committee member should produce and broadcast a <code>SyncCommitteeMessage</code> either when (a) the validator has received a valid block from the expected block proposer for the current <code>slot</code> or (b) one-third of the slot has transpired (<code>SECONDS_PER_SLOT / INTERVALS_PER_SLOT</code> seconds after the start of the slot) -- whichever comes first.</p> <p><code>get_sync_committee_message(state, block_root, validator_index, privkey)</code> assumes the parameter <code>state</code> is the head state corresponding to processing the block up to the current slot as determined by the fork choice (including any empty slots up to the current slot processed with <code>process_slots</code> on top of the latest block), <code>block_root</code> is the root of the head block, <code>validator_index</code> is the index of the validator in the registry <code>state.validators</code> controlled by <code>privkey</code>, and <code>privkey</code> is the BLS private key for the validator.</p> <pre><code>def get_sync_committee_message(state: BeaconState,\nblock_root: Root,\nvalidator_index: ValidatorIndex,\nprivkey: int) -&gt; SyncCommitteeMessage:\nepoch = get_current_epoch(state)\ndomain = get_domain(state, DOMAIN_SYNC_COMMITTEE, epoch)\nsigning_root = compute_signing_root(block_root, domain)\nsignature = bls.Sign(privkey, signing_root)\nreturn SyncCommitteeMessage(\nslot=state.slot,\nbeacon_block_root=block_root,\nvalidator_index=validator_index,\nsignature=signature,\n)\n</code></pre>"},{"location":"specs/altair/validator/#broadcast-sync-committee-message","title":"Broadcast sync committee message","text":"<p>The validator broadcasts the assembled signature to the assigned subnet, the <code>sync_committee_{subnet_id}</code> pubsub topic.</p> <p>The <code>subnet_id</code> is derived from the position in the sync committee such that the sync committee is divided into \"subcommittees\". <code>subnet_id</code> can be computed via <code>compute_subnets_for_sync_committee(state, validator_index)</code> where <code>state</code> is a <code>BeaconState</code> during the matching sync committee period.</p> <p>Note: This function returns multiple deduplicated subnets if a given validator index is included multiple times in a given sync committee across multiple subcommittees.</p> <pre><code>def compute_subnets_for_sync_committee(state: BeaconState, validator_index: ValidatorIndex) -&gt; Set[uint64]:\nnext_slot_epoch = compute_epoch_at_slot(Slot(state.slot + 1))\nif compute_sync_committee_period(get_current_epoch(state)) == compute_sync_committee_period(next_slot_epoch):\nsync_committee = state.current_sync_committee\nelse:\nsync_committee = state.next_sync_committee\ntarget_pubkey = state.validators[validator_index].pubkey\nsync_committee_indices = [index for index, pubkey in enumerate(sync_committee.pubkeys) if pubkey == target_pubkey]\nreturn set([\nuint64(index // (SYNC_COMMITTEE_SIZE // SYNC_COMMITTEE_SUBNET_COUNT))\nfor index in sync_committee_indices\n])\n</code></pre> <p>Note: Subnet assignment does not change during the duration of a validator's assignment to a given sync committee.</p> <p>Note: If a validator has multiple <code>subnet_id</code> results from <code>compute_subnets_for_sync_committee</code>, the validator should broadcast a copy of the <code>sync_committee_message</code> on each of the distinct subnets.</p>"},{"location":"specs/altair/validator/#sync-committee-contributions","title":"Sync committee contributions","text":"<p>Each slot, some sync committee members in each subcommittee are selected to aggregate the <code>SyncCommitteeMessage</code>s into a <code>SyncCommitteeContribution</code> which is broadcast on a global channel for inclusion into the next block.</p>"},{"location":"specs/altair/validator/#aggregation-selection","title":"Aggregation selection","text":"<p>A validator is selected to aggregate based on the value returned by <code>is_sync_committee_aggregator()</code> where <code>signature</code> is the BLS signature returned by <code>get_sync_committee_selection_proof()</code>. The signature function takes a <code>BeaconState</code> with the relevant sync committees for the queried <code>slot</code> (i.e. <code>state.slot</code> is within the span covered by the current or next sync committee period), the <code>subcommittee_index</code> equal to the <code>subnet_id</code>, and the <code>privkey</code> is the BLS private key associated with the validator.</p> <pre><code>def get_sync_committee_selection_proof(state: BeaconState,\nslot: Slot,\nsubcommittee_index: uint64,\nprivkey: int) -&gt; BLSSignature:\ndomain = get_domain(state, DOMAIN_SYNC_COMMITTEE_SELECTION_PROOF, compute_epoch_at_slot(slot))\nsigning_data = SyncAggregatorSelectionData(\nslot=slot,\nsubcommittee_index=subcommittee_index,\n)\nsigning_root = compute_signing_root(signing_data, domain)\nreturn bls.Sign(privkey, signing_root)\n</code></pre> <pre><code>def is_sync_committee_aggregator(signature: BLSSignature) -&gt; bool:\nmodulo = max(1, SYNC_COMMITTEE_SIZE // SYNC_COMMITTEE_SUBNET_COUNT // TARGET_AGGREGATORS_PER_SYNC_SUBCOMMITTEE)\nreturn bytes_to_uint64(hash(signature)[0:8]) % modulo == 0\n</code></pre> <p>NOTE: The set of aggregators generally changes every slot; however, the assignments can be computed ahead of time as soon as the committee is known.</p>"},{"location":"specs/altair/validator/#construct-sync-committee-contribution","title":"Construct sync committee contribution","text":"<p>If a validator is selected to aggregate the <code>SyncCommitteeMessage</code>s produced on a subnet during a given <code>slot</code>, they construct an aggregated <code>SyncCommitteeContribution</code>.</p> <p>Collect all of the (valid) <code>sync_committee_messages: Set[SyncCommitteeMessage]</code> from the <code>sync_committee_{subnet_id}</code> gossip during the selected <code>slot</code> with an equivalent <code>beacon_block_root</code> to that of the aggregator. If <code>len(sync_committee_messages) &gt; 0</code>, the aggregator creates a <code>contribution: SyncCommitteeContribution</code> with the following fields:</p>"},{"location":"specs/altair/validator/#slot","title":"Slot","text":"<p>Set <code>contribution.slot = state.slot</code> where <code>state</code> is the <code>BeaconState</code> for the slot in question.</p>"},{"location":"specs/altair/validator/#beacon-block-root","title":"Beacon block root","text":"<p>Set <code>contribution.beacon_block_root = beacon_block_root</code> from the <code>beacon_block_root</code> found in the <code>sync_committee_messages</code>.</p>"},{"location":"specs/altair/validator/#subcommittee-index","title":"Subcommittee index","text":"<p>Set <code>contribution.subcommittee_index</code> to the index for the subcommittee index corresponding to the subcommittee assigned to this subnet. This index matches the <code>subnet_id</code> used to derive the topic name.</p>"},{"location":"specs/altair/validator/#aggregation-bits","title":"Aggregation bits","text":"<p>Let <code>contribution.aggregation_bits</code> be a <code>Bitvector[SYNC_COMMITTEE_SIZE // SYNC_COMMITTEE_SUBNET_COUNT]</code>, where the <code>index</code>th bit is set in the <code>Bitvector</code> for each corresponding validator included in this aggregate from the corresponding subcommittee. An aggregator finds the index in the sync committee (as determined by a reverse pubkey lookup on <code>state.current_sync_committee.pubkeys</code>) for a given validator referenced by <code>sync_committee_message.validator_index</code> and maps the sync committee index to an index in the subcommittee (along with the prior <code>subcommittee_index</code>). This index within the subcommittee is set in <code>contribution.aggegration_bits</code>.</p> <p>For example, if a validator with index <code>2044</code> is pseudo-randomly sampled to sync committee index <code>135</code>. This sync committee index maps to <code>subcommittee_index</code> <code>1</code> with position <code>7</code> in the <code>Bitvector</code> for the contribution.</p> <p>Note: A validator could be included multiple times in a given subcommittee such that multiple bits are set for a single <code>SyncCommitteeMessage</code>.</p>"},{"location":"specs/altair/validator/#signature","title":"Signature","text":"<p>Set <code>contribution.signature = aggregate_signature</code> where <code>aggregate_signature</code> is obtained by assembling the appropriate collection of <code>BLSSignature</code>s from the set of <code>sync_committee_messages</code> and using the <code>bls.Aggregate()</code> function to produce an aggregate <code>BLSSignature</code>.</p> <p>The collection of input signatures should include one signature per validator who had a bit set in the <code>aggregation_bits</code> bitfield, with repeated signatures if one validator maps to multiple indices within the subcommittee.</p>"},{"location":"specs/altair/validator/#broadcast-sync-committee-contribution","title":"Broadcast sync committee contribution","text":"<p>If the validator is selected to aggregate (<code>is_sync_committee_aggregator()</code>), then they broadcast their best aggregate as a <code>SignedContributionAndProof</code> to the global aggregate channel (<code>sync_committee_contribution_and_proof</code> topic) two-thirds of the way through the <code>slot</code>-that is, <code>SECONDS_PER_SLOT * 2 / INTERVALS_PER_SLOT</code> seconds after the start of <code>slot</code>.</p> <p>Selection proofs are provided in <code>ContributionAndProof</code> to prove to the gossip channel that the validator has been selected as an aggregator.</p> <p><code>ContributionAndProof</code> messages are signed by the aggregator and broadcast inside of <code>SignedContributionAndProof</code> objects to prevent a class of DoS attacks and message forgeries.</p> <p>First, <code>contribution_and_proof = get_contribution_and_proof(state, validator_index, contribution, privkey)</code> is constructed.</p> <pre><code>def get_contribution_and_proof(state: BeaconState,\naggregator_index: ValidatorIndex,\ncontribution: SyncCommitteeContribution,\nprivkey: int) -&gt; ContributionAndProof:\nselection_proof = get_sync_committee_selection_proof(\nstate,\ncontribution.slot,\ncontribution.subcommittee_index,\nprivkey,\n)\nreturn ContributionAndProof(\naggregator_index=aggregator_index,\ncontribution=contribution,\nselection_proof=selection_proof,\n)\n</code></pre> <p>Then <code>signed_contribution_and_proof = SignedContributionAndProof(message=contribution_and_proof, signature=signature)</code> is constructed and broadcast. Where <code>signature</code> is obtained from:</p> <pre><code>def get_contribution_and_proof_signature(state: BeaconState,\ncontribution_and_proof: ContributionAndProof,\nprivkey: int) -&gt; BLSSignature:\ncontribution = contribution_and_proof.contribution\ndomain = get_domain(state, DOMAIN_CONTRIBUTION_AND_PROOF, compute_epoch_at_slot(contribution.slot))\nsigning_root = compute_signing_root(contribution_and_proof, domain)\nreturn bls.Sign(privkey, signing_root)\n</code></pre>"},{"location":"specs/altair/validator/#sync-committee-subnet-stability","title":"Sync committee subnet stability","text":"<p>The sync committee subnets need special care to ensure stability given the relatively low number of validators involved in the sync committee at any particular time. To provide this stability, a validator must do the following:</p> <ul> <li>Maintain advertisement of the subnet the validator in the sync committee is assigned to in their node's ENR as soon as they have joined the subnet. Subnet assignments are known <code>EPOCHS_PER_SYNC_COMMITTEE_PERIOD</code> epochs in advance and can be computed with <code>compute_subnets_for_sync_committee</code> defined above. ENR advertisement is indicated by setting the appropriate bit(s) of the bitfield found under the <code>syncnets</code> key in the ENR corresponding to the derived <code>subnet_id</code>(s). Any bits modified for the sync committee responsibilities are unset in the ENR once the node no longer has any validators in the subcommittee.</li> </ul> <p>Note: The first sync committee from phase 0 to the Altair fork will not be known until the fork happens, which implies subnet assignments are not known until then. Early sync committee members should listen for topic subscriptions from peers and employ discovery via the ENR advertisements near the fork boundary to form initial subnets. Some early sync committee rewards may be missed while the initial subnets form.</p> <ul> <li>To join a sync committee subnet, select a random number of epochs before the end of the current sync committee period between 1 and <code>SYNC_COMMITTEE_SUBNET_COUNT</code>, inclusive. Validators should join their member subnet at the beginning of the epoch they have randomly selected. For example, if the next sync committee period starts at epoch <code>853,248</code> and the validator randomly selects an offset of <code>3</code>, they should join the subnet at the beginning of epoch <code>853,245</code>. Validators should leverage the lookahead period on sync committee assignments so that they can join the appropriate subnets ahead of their assigned sync committee period.</li> </ul>"},{"location":"specs/altair/light-client/full-node/","title":"Altair Light Client -- Full Node","text":"<p>Notice: This document is a work-in-progress for researchers and implementers.</p>"},{"location":"specs/altair/light-client/full-node/#table-of-contents","title":"Table of contents","text":"<ul> <li>Introduction</li> <li>Helper functions</li> <li><code>compute_merkle_proof</code></li> <li><code>block_to_light_client_header</code></li> <li>Deriving light client data</li> <li><code>create_light_client_bootstrap</code></li> <li><code>create_light_client_update</code></li> <li><code>create_light_client_finality_update</code></li> <li><code>create_light_client_optimistic_update</code></li> </ul>"},{"location":"specs/altair/light-client/full-node/#introduction","title":"Introduction","text":"<p>This document provides helper functions to enable full nodes to serve light client data. Full nodes SHOULD implement the described functionality to enable light clients to sync with the network.</p>"},{"location":"specs/altair/light-client/full-node/#helper-functions","title":"Helper functions","text":""},{"location":"specs/altair/light-client/full-node/#compute_merkle_proof","title":"<code>compute_merkle_proof</code>","text":"<p>This function return the Merkle proof of the given SSZ object <code>object</code> at generalized index <code>index</code>.</p> <pre><code>def compute_merkle_proof(object: SSZObject,\nindex: GeneralizedIndex) -&gt; Sequence[Bytes32]:\n...\n</code></pre>"},{"location":"specs/altair/light-client/full-node/#block_to_light_client_header","title":"<code>block_to_light_client_header</code>","text":"<pre><code>def block_to_light_client_header(block: SignedBeaconBlock) -&gt; LightClientHeader:\nreturn LightClientHeader(\nbeacon=BeaconBlockHeader(\nslot=block.message.slot,\nproposer_index=block.message.proposer_index,\nparent_root=block.message.parent_root,\nstate_root=block.message.state_root,\nbody_root=hash_tree_root(block.message.body),\n),\n)\n</code></pre>"},{"location":"specs/altair/light-client/full-node/#deriving-light-client-data","title":"Deriving light client data","text":"<p>Full nodes are expected to derive light client data from historic blocks and states and provide it to other clients.</p>"},{"location":"specs/altair/light-client/full-node/#create_light_client_bootstrap","title":"<code>create_light_client_bootstrap</code>","text":"<p>To form a <code>LightClientBootstrap</code>, the following objects are needed: - <code>state</code>: the post state of any post-Altair block - <code>block</code>: the corresponding block</p> <pre><code>def create_light_client_bootstrap(state: BeaconState,\nblock: SignedBeaconBlock) -&gt; LightClientBootstrap:\nassert compute_epoch_at_slot(state.slot) &gt;= ALTAIR_FORK_EPOCH\nassert state.slot == state.latest_block_header.slot\nheader = state.latest_block_header.copy()\nheader.state_root = hash_tree_root(state)\nassert hash_tree_root(header) == hash_tree_root(block.message)\nreturn LightClientBootstrap(\nheader=block_to_light_client_header(block),\ncurrent_sync_committee=state.current_sync_committee,\ncurrent_sync_committee_branch=CurrentSyncCommitteeBranch(\ncompute_merkle_proof(state, CURRENT_SYNC_COMMITTEE_GINDEX)),\n)\n</code></pre> <p>Full nodes SHOULD provide <code>LightClientBootstrap</code> for all finalized epoch boundary blocks in the epoch range <code>[max(ALTAIR_FORK_EPOCH, current_epoch - MIN_EPOCHS_FOR_BLOCK_REQUESTS), current_epoch]</code> where <code>current_epoch</code> is defined by the current wall-clock time. Full nodes MAY also provide <code>LightClientBootstrap</code> for other blocks.</p> <p>Blocks are considered to be epoch boundary blocks if their block root can occur as part of a valid <code>Checkpoint</code>, i.e., if their slot is the initial slot of an epoch, or if all following slots through the initial slot of the next epoch are empty (no block proposed / orphaned).</p> <p><code>LightClientBootstrap</code> is computed from the block's immediate post state (without applying empty slots).</p>"},{"location":"specs/altair/light-client/full-node/#create_light_client_update","title":"<code>create_light_client_update</code>","text":"<p>To form a <code>LightClientUpdate</code>, the following historical states and blocks are needed: - <code>state</code>: the post state of any block with a post-Altair parent block - <code>block</code>: the corresponding block - <code>attested_state</code>: the post state of <code>attested_block</code> - <code>attested_block</code>: the block referred to by <code>block.parent_root</code> - <code>finalized_block</code>: the block referred to by <code>attested_state.finalized_checkpoint.root</code>, if locally available (may be unavailable, e.g., when using checkpoint sync, or if it was pruned locally)</p> <pre><code>def create_light_client_update(state: BeaconState,\nblock: SignedBeaconBlock,\nattested_state: BeaconState,\nattested_block: SignedBeaconBlock,\nfinalized_block: Optional[SignedBeaconBlock]) -&gt; LightClientUpdate:\nassert compute_epoch_at_slot(attested_state.slot) &gt;= ALTAIR_FORK_EPOCH\nassert sum(block.message.body.sync_aggregate.sync_committee_bits) &gt;= MIN_SYNC_COMMITTEE_PARTICIPANTS\nassert state.slot == state.latest_block_header.slot\nheader = state.latest_block_header.copy()\nheader.state_root = hash_tree_root(state)\nassert hash_tree_root(header) == hash_tree_root(block.message)\nupdate_signature_period = compute_sync_committee_period_at_slot(block.message.slot)\nassert attested_state.slot == attested_state.latest_block_header.slot\nattested_header = attested_state.latest_block_header.copy()\nattested_header.state_root = hash_tree_root(attested_state)\nassert hash_tree_root(attested_header) == hash_tree_root(attested_block.message) == block.message.parent_root\nupdate_attested_period = compute_sync_committee_period_at_slot(attested_block.message.slot)\nupdate = LightClientUpdate()\nupdate.attested_header = block_to_light_client_header(attested_block)\n# `next_sync_committee` is only useful if the message is signed by the current sync committee\nif update_attested_period == update_signature_period:\nupdate.next_sync_committee = attested_state.next_sync_committee\nupdate.next_sync_committee_branch = NextSyncCommitteeBranch(\ncompute_merkle_proof(attested_state, NEXT_SYNC_COMMITTEE_GINDEX))\n# Indicate finality whenever possible\nif finalized_block is not None:\nif finalized_block.message.slot != GENESIS_SLOT:\nupdate.finalized_header = block_to_light_client_header(finalized_block)\nassert hash_tree_root(update.finalized_header.beacon) == attested_state.finalized_checkpoint.root\nelse:\nassert attested_state.finalized_checkpoint.root == Bytes32()\nupdate.finality_branch = FinalityBranch(\ncompute_merkle_proof(attested_state, FINALIZED_ROOT_GINDEX))\nupdate.sync_aggregate = block.message.body.sync_aggregate\nupdate.signature_slot = block.message.slot\nreturn update\n</code></pre> <p>Full nodes SHOULD provide the best derivable <code>LightClientUpdate</code> (according to <code>is_better_update</code>) for each sync committee period covering any epochs in range <code>[max(ALTAIR_FORK_EPOCH, current_epoch - MIN_EPOCHS_FOR_BLOCK_REQUESTS), current_epoch]</code> where <code>current_epoch</code> is defined by the current wall-clock time. Full nodes MAY also provide <code>LightClientUpdate</code> for other sync committee periods.</p> <ul> <li><code>LightClientUpdate</code> are assigned to sync committee periods based on their <code>attested_header.beacon.slot</code></li> <li><code>LightClientUpdate</code> are only considered if <code>compute_sync_committee_period_at_slot(update.attested_header.beacon.slot) == compute_sync_committee_period_at_slot(update.signature_slot)</code></li> <li>Only <code>LightClientUpdate</code> with <code>next_sync_committee</code> as selected by fork choice are provided, regardless of ranking by <code>is_better_update</code>. To uniquely identify a non-finalized sync committee fork, all of <code>period</code>, <code>current_sync_committee</code> and <code>next_sync_committee</code> need to be incorporated, as sync committees may reappear over time.</li> </ul>"},{"location":"specs/altair/light-client/full-node/#create_light_client_finality_update","title":"<code>create_light_client_finality_update</code>","text":"<pre><code>def create_light_client_finality_update(update: LightClientUpdate) -&gt; LightClientFinalityUpdate:\nreturn LightClientFinalityUpdate(\nattested_header=update.attested_header,\nfinalized_header=update.finalized_header,\nfinality_branch=update.finality_branch,\nsync_aggregate=update.sync_aggregate,\nsignature_slot=update.signature_slot,\n)\n</code></pre> <p>Full nodes SHOULD provide the <code>LightClientFinalityUpdate</code> with the highest <code>attested_header.beacon.slot</code> (if multiple, highest <code>signature_slot</code>) as selected by fork choice, and SHOULD support a push mechanism to deliver new <code>LightClientFinalityUpdate</code> whenever <code>finalized_header</code> changes. If that <code>LightClientFinalityUpdate</code> does not have supermajority (&gt; 2/3) sync committee participation, a second <code>LightClientFinalityUpdate</code> SHOULD be delivered for the same <code>finalized_header</code> once supermajority participation is obtained.</p>"},{"location":"specs/altair/light-client/full-node/#create_light_client_optimistic_update","title":"<code>create_light_client_optimistic_update</code>","text":"<pre><code>def create_light_client_optimistic_update(update: LightClientUpdate) -&gt; LightClientOptimisticUpdate:\nreturn LightClientOptimisticUpdate(\nattested_header=update.attested_header,\nsync_aggregate=update.sync_aggregate,\nsignature_slot=update.signature_slot,\n)\n</code></pre> <p>Full nodes SHOULD provide the <code>LightClientOptimisticUpdate</code> with the highest <code>attested_header.beacon.slot</code> (if multiple, highest <code>signature_slot</code>) as selected by fork choice, and SHOULD support a push mechanism to deliver new <code>LightClientOptimisticUpdate</code> whenever <code>attested_header</code> changes.</p>"},{"location":"specs/altair/light-client/light-client/","title":"Altair Light Client -- Light Client","text":"<p>Notice: This document is a work-in-progress for researchers and implementers.</p>"},{"location":"specs/altair/light-client/light-client/#table-of-contents","title":"Table of contents","text":"<ul> <li>Introduction</li> <li>Light client sync process</li> </ul>"},{"location":"specs/altair/light-client/light-client/#introduction","title":"Introduction","text":"<p>This document explains how light clients MAY obtain light client data to sync with the network.</p>"},{"location":"specs/altair/light-client/light-client/#light-client-sync-process","title":"Light client sync process","text":"<ol> <li>The light client MUST be configured out-of-band with a spec/preset (including fork schedule), with <code>genesis_state</code> (including <code>genesis_time</code> and <code>genesis_validators_root</code>), and with a trusted block root. The trusted block SHOULD be within the weak subjectivity period, and its root SHOULD be from a finalized <code>Checkpoint</code>.</li> <li>The local clock is initialized based on the configured <code>genesis_time</code>, and the current fork digest is determined to browse for and connect to relevant light client data providers.</li> <li>The light client fetches a <code>LightClientBootstrap</code> object for the configured trusted block root. The <code>bootstrap</code> object is passed to <code>initialize_light_client_store</code> to obtain a local <code>LightClientStore</code>.</li> <li>The light client tracks the sync committee periods <code>finalized_period</code> from <code>store.finalized_header.beacon.slot</code>, <code>optimistic_period</code> from <code>store.optimistic_header.beacon.slot</code>, and <code>current_period</code> from <code>current_slot</code> based on the local clock.</li> <li>When <code>finalized_period == optimistic_period</code> and <code>is_next_sync_committee_known</code> indicates <code>False</code>, the light client fetches a <code>LightClientUpdate</code> for <code>finalized_period</code>. If <code>finalized_period == current_period</code>, this fetch SHOULD be scheduled at a random time before <code>current_period</code> advances.</li> <li>When <code>finalized_period + 1 &lt; current_period</code>, the light client fetches a <code>LightClientUpdate</code> for each sync committee period in range <code>[finalized_period + 1, current_period)</code> (current period excluded)</li> <li>When <code>finalized_period + 1 &gt;= current_period</code>, the light client keeps observing <code>LightClientFinalityUpdate</code> and <code>LightClientOptimisticUpdate</code>. Received objects are passed to <code>process_light_client_finality_update</code> and <code>process_light_client_optimistic_update</code>. This ensures that <code>finalized_header</code> and <code>optimistic_header</code> reflect the latest blocks.</li> <li><code>process_light_client_store_force_update</code> MAY be called based on use case dependent heuristics if light client sync appears stuck. If available, falling back to an alternative syncing mechanism to cover the affected sync committee period is preferred.</li> </ol>"},{"location":"specs/altair/light-client/p2p-interface/","title":"Altair Light Client -- Networking","text":"<p>Notice: This document is a work-in-progress for researchers and implementers.</p>"},{"location":"specs/altair/light-client/p2p-interface/#table-of-contents","title":"Table of contents","text":"<ul> <li>Networking</li> <li>Configuration</li> <li>The gossip domain: gossipsub<ul> <li>Topics and messages</li> <li>Global topics<ul> <li><code>light_client_finality_update</code></li> <li><code>light_client_optimistic_update</code></li> </ul> </li> </ul> </li> <li>The Req/Resp domain<ul> <li>Messages</li> <li>GetLightClientBootstrap</li> <li>LightClientUpdatesByRange</li> <li>GetLightClientFinalityUpdate</li> <li>GetLightClientOptimisticUpdate</li> </ul> </li> <li>Light clients</li> <li>Validator assignments</li> <li>Beacon chain responsibilities</li> <li>Sync committee</li> </ul>"},{"location":"specs/altair/light-client/p2p-interface/#networking","title":"Networking","text":"<p>This section extends the networking specification for Altair with additional messages, topics and data to the Req-Resp and Gossip domains.</p>"},{"location":"specs/altair/light-client/p2p-interface/#configuration","title":"Configuration","text":"Name Value Description <code>MAX_REQUEST_LIGHT_CLIENT_UPDATES</code> <code>2**7</code> (= 128) Maximum number of <code>LightClientUpdate</code> instances in a single request"},{"location":"specs/altair/light-client/p2p-interface/#the-gossip-domain-gossipsub","title":"The gossip domain: gossipsub","text":"<p>Gossip meshes are added to allow light clients to stay in sync with the network.</p>"},{"location":"specs/altair/light-client/p2p-interface/#topics-and-messages","title":"Topics and messages","text":"<p>New global topics are added to provide light clients with the latest updates.</p> name Message Type <code>light_client_finality_update</code> <code>LightClientFinalityUpdate</code> <code>light_client_optimistic_update</code> <code>LightClientOptimisticUpdate</code>"},{"location":"specs/altair/light-client/p2p-interface/#global-topics","title":"Global topics","text":""},{"location":"specs/altair/light-client/p2p-interface/#light_client_finality_update","title":"<code>light_client_finality_update</code>","text":"<p>This topic is used to propagate the latest <code>LightClientFinalityUpdate</code> to light clients, allowing them to keep track of the latest <code>finalized_header</code>.</p> <p>The following validations MUST pass before forwarding the <code>finality_update</code> on the network. - [IGNORE] The <code>finalized_header.beacon.slot</code> is greater than that of all previously forwarded <code>finality_update</code>s, or it matches the highest previously forwarded slot and also has a <code>sync_aggregate</code> indicating supermajority (&gt; 2/3) sync committee participation while the previously forwarded <code>finality_update</code> for that slot did not indicate supermajority - [IGNORE] The <code>finality_update</code> is received after the block at <code>signature_slot</code> was given enough time to propagate through the network -- i.e. validate that one-third of <code>finality_update.signature_slot</code> has transpired (<code>SECONDS_PER_SLOT / INTERVALS_PER_SLOT</code> seconds after the start of the slot, with a <code>MAXIMUM_GOSSIP_CLOCK_DISPARITY</code> allowance)</p> <p>For full nodes, the following validations MUST additionally pass before forwarding the <code>finality_update</code> on the network. - [IGNORE] The received <code>finality_update</code> matches the locally computed one exactly (as defined in <code>create_light_client_finality_update</code>)</p> <p>For light clients, the following validations MUST additionally pass before forwarding the <code>finality_update</code> on the network. - [REJECT] The <code>finality_update</code> is valid -- i.e. validate that <code>process_light_client_finality_update</code> does not indicate errors - [IGNORE] The <code>finality_update</code> advances the <code>finalized_header</code> of the local <code>LightClientStore</code> -- i.e. validate that processing <code>finality_update</code> increases <code>store.finalized_header.beacon.slot</code></p> <p>Light clients SHOULD call <code>process_light_client_finality_update</code> even if the message is ignored.</p> <p>The gossip <code>ForkDigest</code>-context is determined based on <code>compute_fork_version(compute_epoch_at_slot(finality_update.attested_header.beacon.slot))</code>.</p> <p>Per <code>context = compute_fork_digest(fork_version, genesis_validators_root)</code>:</p> <code>fork_version</code> Message SSZ type <code>GENESIS_FORK_VERSION</code> n/a <code>ALTAIR_FORK_VERSION</code> and later <code>altair.LightClientFinalityUpdate</code>"},{"location":"specs/altair/light-client/p2p-interface/#light_client_optimistic_update","title":"<code>light_client_optimistic_update</code>","text":"<p>This topic is used to propagate the latest <code>LightClientOptimisticUpdate</code> to light clients, allowing them to keep track of the latest <code>optimistic_header</code>.</p> <p>The following validations MUST pass before forwarding the <code>optimistic_update</code> on the network. - [IGNORE] The <code>attested_header.beacon.slot</code> is greater than that of all previously forwarded <code>optimistic_update</code>s - [IGNORE] The <code>optimistic_update</code> is received after the block at <code>signature_slot</code> was given enough time to propagate through the network -- i.e. validate that one-third of <code>optimistic_update.signature_slot</code> has transpired (<code>SECONDS_PER_SLOT / INTERVALS_PER_SLOT</code> seconds after the start of the slot, with a <code>MAXIMUM_GOSSIP_CLOCK_DISPARITY</code> allowance)</p> <p>For full nodes, the following validations MUST additionally pass before forwarding the <code>optimistic_update</code> on the network. - [IGNORE] The received <code>optimistic_update</code> matches the locally computed one exactly (as defined in <code>create_light_client_optimistic_update</code>)</p> <p>For light clients, the following validations MUST additionally pass before forwarding the <code>optimistic_update</code> on the network. - [REJECT] The <code>optimistic_update</code> is valid -- i.e. validate that <code>process_light_client_optimistic_update</code> does not indicate errors - [IGNORE] The <code>optimistic_update</code> either matches corresponding fields of the most recently forwarded <code>LightClientFinalityUpdate</code> (if any), or it advances the <code>optimistic_header</code> of the local <code>LightClientStore</code> -- i.e. validate that processing <code>optimistic_update</code> increases <code>store.optimistic_header.beacon.slot</code></p> <p>Light clients SHOULD call <code>process_light_client_optimistic_update</code> even if the message is ignored.</p> <p>The gossip <code>ForkDigest</code>-context is determined based on <code>compute_fork_version(compute_epoch_at_slot(optimistic_update.attested_header.beacon.slot))</code>.</p> <p>Per <code>context = compute_fork_digest(fork_version, genesis_validators_root)</code>:</p> <code>fork_version</code> Message SSZ type <code>GENESIS_FORK_VERSION</code> n/a <code>ALTAIR_FORK_VERSION</code> and later <code>altair.LightClientOptimisticUpdate</code>"},{"location":"specs/altair/light-client/p2p-interface/#the-reqresp-domain","title":"The Req/Resp domain","text":""},{"location":"specs/altair/light-client/p2p-interface/#messages","title":"Messages","text":""},{"location":"specs/altair/light-client/p2p-interface/#getlightclientbootstrap","title":"GetLightClientBootstrap","text":"<p>Protocol ID: <code>/eth2/beacon_chain/req/light_client_bootstrap/1/</code></p> <p>Request Content:</p> <pre><code>(\n  Root\n)\n</code></pre> <p>Response Content:</p> <pre><code>(\n  LightClientBootstrap\n)\n</code></pre> <p>Requests the <code>LightClientBootstrap</code> structure corresponding to a given post-Altair beacon block root.</p> <p>The request MUST be encoded as an SSZ-field.</p> <p>Peers SHOULD provide results as defined in <code>create_light_client_bootstrap</code>. To fulfill a request, the requested block and its post state need to be known.</p> <p>When a <code>LightClientBootstrap</code> instance cannot be produced for a given block root, peers SHOULD respond with error code <code>3: ResourceUnavailable</code>.</p> <p>A <code>ForkDigest</code>-context based on <code>compute_fork_version(compute_epoch_at_slot(bootstrap.header.beacon.slot))</code> is used to select the fork namespace of the Response type.</p> <p>Per <code>context = compute_fork_digest(fork_version, genesis_validators_root)</code>:</p> <code>fork_version</code> Response SSZ type <code>GENESIS_FORK_VERSION</code> n/a <code>ALTAIR_FORK_VERSION</code> and later <code>altair.LightClientBootstrap</code>"},{"location":"specs/altair/light-client/p2p-interface/#lightclientupdatesbyrange","title":"LightClientUpdatesByRange","text":"<p>Protocol ID: <code>/eth2/beacon_chain/req/light_client_updates_by_range/1/</code></p> <p>Request Content: <pre><code>(\n  start_period: uint64\n  count: uint64\n)\n</code></pre></p> <p>Response Content: <pre><code>(\n  List[LightClientUpdate, MAX_REQUEST_LIGHT_CLIENT_UPDATES]\n)\n</code></pre></p> <p>Requests the <code>LightClientUpdate</code> instances in the sync committee period range <code>[start_period, start_period + count)</code>, leading up to the current head sync committee period as selected by fork choice.</p> <p>The request MUST be encoded as an SSZ-container.</p> <p>The response MUST consist of zero or more <code>response_chunk</code>. Each successful <code>response_chunk</code> MUST contain a single <code>LightClientUpdate</code> payload.</p> <p>Peers SHOULD provide results as defined in <code>create_light_client_update</code>. They MUST respond with at least the earliest known result within the requested range, and MUST send results in consecutive order (by period). The response MUST NOT contain more than <code>min(MAX_REQUEST_LIGHT_CLIENT_UPDATES, count)</code> results.</p> <p>For each <code>response_chunk</code>, a <code>ForkDigest</code>-context based on <code>compute_fork_version(compute_epoch_at_slot(update.attested_header.beacon.slot))</code> is used to select the fork namespace of the Response type. Note that this <code>fork_version</code> may be different from the one used to verify the <code>update.sync_aggregate</code>, which is based on <code>update.signature_slot</code>.</p> <p>Per <code>context = compute_fork_digest(fork_version, genesis_validators_root)</code>:</p> <code>fork_version</code> Response chunk SSZ type <code>GENESIS_FORK_VERSION</code> n/a <code>ALTAIR_FORK_VERSION</code> and later <code>altair.LightClientUpdate</code>"},{"location":"specs/altair/light-client/p2p-interface/#getlightclientfinalityupdate","title":"GetLightClientFinalityUpdate","text":"<p>Protocol ID: <code>/eth2/beacon_chain/req/light_client_finality_update/1/</code></p> <p>No Request Content.</p> <p>Response Content:</p> <pre><code>(\n  LightClientFinalityUpdate\n)\n</code></pre> <p>Requests the latest <code>LightClientFinalityUpdate</code> known by a peer.</p> <p>Peers SHOULD provide results as defined in <code>create_light_client_finality_update</code>.</p> <p>When no <code>LightClientFinalityUpdate</code> is available, peers SHOULD respond with error code <code>3: ResourceUnavailable</code>.</p> <p>A <code>ForkDigest</code>-context based on <code>compute_fork_version(compute_epoch_at_slot(finality_update.attested_header.beacon.slot))</code> is used to select the fork namespace of the Response type. Note that this <code>fork_version</code> may be different from the one used to verify the <code>finality_update.sync_aggregate</code>, which is based on <code>finality_update.signature_slot</code>.</p> <p>Per <code>context = compute_fork_digest(fork_version, genesis_validators_root)</code>:</p> <code>fork_version</code> Response SSZ type <code>GENESIS_FORK_VERSION</code> n/a <code>ALTAIR_FORK_VERSION</code> and later <code>altair.LightClientFinalityUpdate</code>"},{"location":"specs/altair/light-client/p2p-interface/#getlightclientoptimisticupdate","title":"GetLightClientOptimisticUpdate","text":"<p>Protocol ID: <code>/eth2/beacon_chain/req/light_client_optimistic_update/1/</code></p> <p>No Request Content.</p> <p>Response Content:</p> <pre><code>(\n  LightClientOptimisticUpdate\n)\n</code></pre> <p>Requests the latest <code>LightClientOptimisticUpdate</code> known by a peer.</p> <p>Peers SHOULD provide results as defined in <code>create_light_client_optimistic_update</code>.</p> <p>When no <code>LightClientOptimisticUpdate</code> is available, peers SHOULD respond with error code <code>3: ResourceUnavailable</code>.</p> <p>A <code>ForkDigest</code>-context based on <code>compute_fork_version(compute_epoch_at_slot(optimistic_update.attested_header.beacon.slot))</code> is used to select the fork namespace of the Response type. Note that this <code>fork_version</code> may be different from the one used to verify the <code>optimistic_update.sync_aggregate</code>, which is based on <code>optimistic_update.signature_slot</code>.</p> <p>Per <code>context = compute_fork_digest(fork_version, genesis_validators_root)</code>:</p> <code>fork_version</code> Response SSZ type <code>GENESIS_FORK_VERSION</code> n/a <code>ALTAIR_FORK_VERSION</code> and later <code>altair.LightClientOptimisticUpdate</code>"},{"location":"specs/altair/light-client/p2p-interface/#light-clients","title":"Light clients","text":"<p>Light clients using libp2p to stay in sync with the network SHOULD subscribe to the <code>light_client_finality_update</code> and <code>light_client_optimistic_update</code> pubsub topics and validate all received messages while the light client sync process supports processing <code>LightClientFinalityUpdate</code> and <code>LightClientOptimisticUpdate</code> structures.</p> <p>Light clients MAY also collect historic light client data and make it available to other peers. If they do, they SHOULD advertise supported message endpoints in the Req/Resp domain, and MAY also update the contents of their <code>Status</code> message to reflect the locally available light client data.</p> <p>If only limited light client data is locally available, the light client SHOULD use data based on <code>genesis_block</code> and <code>GENESIS_SLOT</code> in its <code>Status</code> message. Hybrid peers that also implement full node functionality MUST only incorporate data based on their full node sync progress into their <code>Status</code> message.</p>"},{"location":"specs/altair/light-client/p2p-interface/#validator-assignments","title":"Validator assignments","text":"<p>This section extends the honest validator specification with additional responsibilities to enable light clients to sync with the network.</p>"},{"location":"specs/altair/light-client/p2p-interface/#beacon-chain-responsibilities","title":"Beacon chain responsibilities","text":"<p>All full nodes SHOULD subscribe to and provide stability on the <code>light_client_finality_update</code> and <code>light_client_optimistic_update</code> pubsub topics by validating all received messages.</p>"},{"location":"specs/altair/light-client/p2p-interface/#sync-committee","title":"Sync committee","text":"<p>Whenever fork choice selects a new head block with a sync aggregate participation <code>&gt;= MIN_SYNC_COMMITTEE_PARTICIPANTS</code> and a post-Altair parent block, full nodes with at least one validator assigned to the current sync committee at the block's <code>slot</code> SHOULD broadcast derived light client data as follows:</p> <ul> <li>If <code>finalized_header.beacon.slot</code> increased, a <code>LightClientFinalityUpdate</code> SHOULD be broadcasted to the pubsub topic <code>light_client_finality_update</code> if no matching message has not yet been forwarded as part of gossip validation.</li> <li>If <code>attested_header.beacon.slot</code> increased, a <code>LightClientOptimisticUpdate</code> SHOULD be broadcasted to the pubsub topic <code>light_client_optimistic_update</code> if no matching message has not yet been forwarded as part of gossip validation.</li> </ul> <p>These messages SHOULD be broadcasted after one-third of <code>slot</code> has transpired (<code>SECONDS_PER_SLOT / INTERVALS_PER_SLOT</code> seconds after the start of the slot). To ensure that the corresponding block was given enough time to propagate through the network, they SHOULD NOT be sent earlier. Note that this is different from how other messages are handled, e.g., attestations, which may be sent early.</p>"},{"location":"specs/altair/light-client/sync-protocol/","title":"Altair Light Client -- Sync Protocol","text":"<p>Notice: This document is a work-in-progress for researchers and implementers.</p>"},{"location":"specs/altair/light-client/sync-protocol/#table-of-contents","title":"Table of contents","text":"<ul> <li>Introduction</li> <li>Custom types</li> <li>Constants</li> <li>Preset</li> <li>Misc</li> <li>Containers</li> <li><code>LightClientHeader</code></li> <li><code>LightClientBootstrap</code></li> <li><code>LightClientUpdate</code></li> <li><code>LightClientFinalityUpdate</code></li> <li><code>LightClientOptimisticUpdate</code></li> <li><code>LightClientStore</code></li> <li>Helper functions</li> <li><code>is_valid_light_client_header</code></li> <li><code>is_sync_committee_update</code></li> <li><code>is_finality_update</code></li> <li><code>is_better_update</code></li> <li><code>is_next_sync_committee_known</code></li> <li><code>get_safety_threshold</code></li> <li><code>get_subtree_index</code></li> <li><code>compute_sync_committee_period_at_slot</code></li> <li>Light client initialization</li> <li><code>initialize_light_client_store</code></li> <li>Light client state updates</li> <li><code>validate_light_client_update</code></li> <li><code>apply_light_client_update</code></li> <li><code>process_light_client_store_force_update</code></li> <li><code>process_light_client_update</code></li> <li><code>process_light_client_finality_update</code></li> <li><code>process_light_client_optimistic_update</code></li> </ul>"},{"location":"specs/altair/light-client/sync-protocol/#introduction","title":"Introduction","text":"<p>The beacon chain is designed to be light client friendly for constrained environments to access Ethereum with reasonable safety and liveness. Such environments include resource-constrained devices (e.g. phones for trust-minimized wallets) and metered VMs (e.g. blockchain VMs for cross-chain bridges).</p> <p>This document suggests a minimal light client design for the beacon chain that uses sync committees introduced in this beacon chain extension.</p> <p>Additional documents describe how the light client sync protocol can be used: - Full node - Light client - Networking</p>"},{"location":"specs/altair/light-client/sync-protocol/#custom-types","title":"Custom types","text":"Name SSZ equivalent Description <code>FinalityBranch</code> <code>Vector[Bytes32, floorlog2(FINALIZED_ROOT_GINDEX)]</code> Merkle branch of <code>finalized_checkpoint.root</code> within <code>BeaconState</code> <code>CurrentSyncCommitteeBranch</code> <code>Vector[Bytes32, floorlog2(CURRENT_SYNC_COMMITTEE_GINDEX)]</code> Merkle branch of <code>current_sync_committee</code> within <code>BeaconState</code> <code>NextSyncCommitteeBranch</code> <code>Vector[Bytes32, floorlog2(NEXT_SYNC_COMMITTEE_GINDEX)]</code> Merkle branch of <code>next_sync_committee</code> within <code>BeaconState</code>"},{"location":"specs/altair/light-client/sync-protocol/#constants","title":"Constants","text":"Name Value <code>FINALIZED_ROOT_GINDEX</code> <code>get_generalized_index(BeaconState, 'finalized_checkpoint', 'root')</code> (= 105) <code>CURRENT_SYNC_COMMITTEE_GINDEX</code> <code>get_generalized_index(BeaconState, 'current_sync_committee')</code> (= 54) <code>NEXT_SYNC_COMMITTEE_GINDEX</code> <code>get_generalized_index(BeaconState, 'next_sync_committee')</code> (= 55)"},{"location":"specs/altair/light-client/sync-protocol/#preset","title":"Preset","text":""},{"location":"specs/altair/light-client/sync-protocol/#misc","title":"Misc","text":"Name Value Unit Duration <code>MIN_SYNC_COMMITTEE_PARTICIPANTS</code> <code>1</code> validators <code>UPDATE_TIMEOUT</code> <code>SLOTS_PER_EPOCH * EPOCHS_PER_SYNC_COMMITTEE_PERIOD</code> slots ~27.3 hours"},{"location":"specs/altair/light-client/sync-protocol/#containers","title":"Containers","text":""},{"location":"specs/altair/light-client/sync-protocol/#lightclientheader","title":"<code>LightClientHeader</code>","text":"<pre><code>class LightClientHeader(Container):\n# Beacon block header\nbeacon: BeaconBlockHeader\n</code></pre> <p>Future upgrades may introduce additional fields to this structure, and validate them by extending <code>is_valid_light_client_header</code>.</p>"},{"location":"specs/altair/light-client/sync-protocol/#lightclientbootstrap","title":"<code>LightClientBootstrap</code>","text":"<pre><code>class LightClientBootstrap(Container):\n# Header matching the requested beacon block root\nheader: LightClientHeader\n# Current sync committee corresponding to `header.beacon.state_root`\ncurrent_sync_committee: SyncCommittee\ncurrent_sync_committee_branch: CurrentSyncCommitteeBranch\n</code></pre>"},{"location":"specs/altair/light-client/sync-protocol/#lightclientupdate","title":"<code>LightClientUpdate</code>","text":"<pre><code>class LightClientUpdate(Container):\n# Header attested to by the sync committee\nattested_header: LightClientHeader\n# Next sync committee corresponding to `attested_header.beacon.state_root`\nnext_sync_committee: SyncCommittee\nnext_sync_committee_branch: NextSyncCommitteeBranch\n# Finalized header corresponding to `attested_header.beacon.state_root`\nfinalized_header: LightClientHeader\nfinality_branch: FinalityBranch\n# Sync committee aggregate signature\nsync_aggregate: SyncAggregate\n# Slot at which the aggregate signature was created (untrusted)\nsignature_slot: Slot\n</code></pre>"},{"location":"specs/altair/light-client/sync-protocol/#lightclientfinalityupdate","title":"<code>LightClientFinalityUpdate</code>","text":"<pre><code>class LightClientFinalityUpdate(Container):\n# Header attested to by the sync committee\nattested_header: LightClientHeader\n# Finalized header corresponding to `attested_header.beacon.state_root`\nfinalized_header: LightClientHeader\nfinality_branch: FinalityBranch\n# Sync committee aggregate signature\nsync_aggregate: SyncAggregate\n# Slot at which the aggregate signature was created (untrusted)\nsignature_slot: Slot\n</code></pre>"},{"location":"specs/altair/light-client/sync-protocol/#lightclientoptimisticupdate","title":"<code>LightClientOptimisticUpdate</code>","text":"<pre><code>class LightClientOptimisticUpdate(Container):\n# Header attested to by the sync committee\nattested_header: LightClientHeader\n# Sync committee aggregate signature\nsync_aggregate: SyncAggregate\n# Slot at which the aggregate signature was created (untrusted)\nsignature_slot: Slot\n</code></pre>"},{"location":"specs/altair/light-client/sync-protocol/#lightclientstore","title":"<code>LightClientStore</code>","text":"<pre><code>@dataclass\nclass LightClientStore(object):\n# Header that is finalized\nfinalized_header: LightClientHeader\n# Sync committees corresponding to the finalized header\ncurrent_sync_committee: SyncCommittee\nnext_sync_committee: SyncCommittee\n# Best available header to switch finalized head to if we see nothing else\nbest_valid_update: Optional[LightClientUpdate]\n# Most recent available reasonably-safe header\noptimistic_header: LightClientHeader\n# Max number of active participants in a sync committee (used to calculate safety threshold)\nprevious_max_active_participants: uint64\ncurrent_max_active_participants: uint64\n</code></pre>"},{"location":"specs/altair/light-client/sync-protocol/#helper-functions","title":"Helper functions","text":""},{"location":"specs/altair/light-client/sync-protocol/#is_valid_light_client_header","title":"<code>is_valid_light_client_header</code>","text":"<pre><code>def is_valid_light_client_header(header: LightClientHeader) -&gt; bool:\n# pylint: disable=unused-argument\nreturn True\n</code></pre>"},{"location":"specs/altair/light-client/sync-protocol/#is_sync_committee_update","title":"<code>is_sync_committee_update</code>","text":"<pre><code>def is_sync_committee_update(update: LightClientUpdate) -&gt; bool:\nreturn update.next_sync_committee_branch != NextSyncCommitteeBranch()\n</code></pre>"},{"location":"specs/altair/light-client/sync-protocol/#is_finality_update","title":"<code>is_finality_update</code>","text":"<pre><code>def is_finality_update(update: LightClientUpdate) -&gt; bool:\nreturn update.finality_branch != FinalityBranch()\n</code></pre>"},{"location":"specs/altair/light-client/sync-protocol/#is_better_update","title":"<code>is_better_update</code>","text":"<pre><code>def is_better_update(new_update: LightClientUpdate, old_update: LightClientUpdate) -&gt; bool:\n# Compare supermajority (&gt; 2/3) sync committee participation\nmax_active_participants = len(new_update.sync_aggregate.sync_committee_bits)\nnew_num_active_participants = sum(new_update.sync_aggregate.sync_committee_bits)\nold_num_active_participants = sum(old_update.sync_aggregate.sync_committee_bits)\nnew_has_supermajority = new_num_active_participants * 3 &gt;= max_active_participants * 2\nold_has_supermajority = old_num_active_participants * 3 &gt;= max_active_participants * 2\nif new_has_supermajority != old_has_supermajority:\nreturn new_has_supermajority &gt; old_has_supermajority\nif not new_has_supermajority and new_num_active_participants != old_num_active_participants:\nreturn new_num_active_participants &gt; old_num_active_participants\n# Compare presence of relevant sync committee\nnew_has_relevant_sync_committee = is_sync_committee_update(new_update) and (\ncompute_sync_committee_period_at_slot(new_update.attested_header.beacon.slot)\n== compute_sync_committee_period_at_slot(new_update.signature_slot)\n)\nold_has_relevant_sync_committee = is_sync_committee_update(old_update) and (\ncompute_sync_committee_period_at_slot(old_update.attested_header.beacon.slot)\n== compute_sync_committee_period_at_slot(old_update.signature_slot)\n)\nif new_has_relevant_sync_committee != old_has_relevant_sync_committee:\nreturn new_has_relevant_sync_committee\n# Compare indication of any finality\nnew_has_finality = is_finality_update(new_update)\nold_has_finality = is_finality_update(old_update)\nif new_has_finality != old_has_finality:\nreturn new_has_finality\n# Compare sync committee finality\nif new_has_finality:\nnew_has_sync_committee_finality = (\ncompute_sync_committee_period_at_slot(new_update.finalized_header.beacon.slot)\n== compute_sync_committee_period_at_slot(new_update.attested_header.beacon.slot)\n)\nold_has_sync_committee_finality = (\ncompute_sync_committee_period_at_slot(old_update.finalized_header.beacon.slot)\n== compute_sync_committee_period_at_slot(old_update.attested_header.beacon.slot)\n)\nif new_has_sync_committee_finality != old_has_sync_committee_finality:\nreturn new_has_sync_committee_finality\n# Tiebreaker 1: Sync committee participation beyond supermajority\nif new_num_active_participants != old_num_active_participants:\nreturn new_num_active_participants &gt; old_num_active_participants\n# Tiebreaker 2: Prefer older data (fewer changes to best)\nif new_update.attested_header.beacon.slot != old_update.attested_header.beacon.slot:\nreturn new_update.attested_header.beacon.slot &lt; old_update.attested_header.beacon.slot\nreturn new_update.signature_slot &lt; old_update.signature_slot\n</code></pre>"},{"location":"specs/altair/light-client/sync-protocol/#is_next_sync_committee_known","title":"<code>is_next_sync_committee_known</code>","text":"<pre><code>def is_next_sync_committee_known(store: LightClientStore) -&gt; bool:\nreturn store.next_sync_committee != SyncCommittee()\n</code></pre>"},{"location":"specs/altair/light-client/sync-protocol/#get_safety_threshold","title":"<code>get_safety_threshold</code>","text":"<pre><code>def get_safety_threshold(store: LightClientStore) -&gt; uint64:\nreturn max(\nstore.previous_max_active_participants,\nstore.current_max_active_participants,\n) // 2\n</code></pre>"},{"location":"specs/altair/light-client/sync-protocol/#get_subtree_index","title":"<code>get_subtree_index</code>","text":"<pre><code>def get_subtree_index(generalized_index: GeneralizedIndex) -&gt; uint64:\nreturn uint64(generalized_index % 2**(floorlog2(generalized_index)))\n</code></pre>"},{"location":"specs/altair/light-client/sync-protocol/#compute_sync_committee_period_at_slot","title":"<code>compute_sync_committee_period_at_slot</code>","text":"<pre><code>def compute_sync_committee_period_at_slot(slot: Slot) -&gt; uint64:\nreturn compute_sync_committee_period(compute_epoch_at_slot(slot))\n</code></pre>"},{"location":"specs/altair/light-client/sync-protocol/#light-client-initialization","title":"Light client initialization","text":"<p>A light client maintains its state in a <code>store</code> object of type <code>LightClientStore</code>. <code>initialize_light_client_store</code> initializes a new <code>store</code> with a received <code>LightClientBootstrap</code> derived from a given <code>trusted_block_root</code>.</p>"},{"location":"specs/altair/light-client/sync-protocol/#initialize_light_client_store","title":"<code>initialize_light_client_store</code>","text":"<pre><code>def initialize_light_client_store(trusted_block_root: Root,\nbootstrap: LightClientBootstrap) -&gt; LightClientStore:\nassert is_valid_light_client_header(bootstrap.header)\nassert hash_tree_root(bootstrap.header.beacon) == trusted_block_root\nassert is_valid_merkle_branch(\nleaf=hash_tree_root(bootstrap.current_sync_committee),\nbranch=bootstrap.current_sync_committee_branch,\ndepth=floorlog2(CURRENT_SYNC_COMMITTEE_GINDEX),\nindex=get_subtree_index(CURRENT_SYNC_COMMITTEE_GINDEX),\nroot=bootstrap.header.beacon.state_root,\n)\nreturn LightClientStore(\nfinalized_header=bootstrap.header,\ncurrent_sync_committee=bootstrap.current_sync_committee,\nnext_sync_committee=SyncCommittee(),\nbest_valid_update=None,\noptimistic_header=bootstrap.header,\nprevious_max_active_participants=0,\ncurrent_max_active_participants=0,\n)\n</code></pre>"},{"location":"specs/altair/light-client/sync-protocol/#light-client-state-updates","title":"Light client state updates","text":"<ul> <li>A light client receives objects of type <code>LightClientUpdate</code>, <code>LightClientFinalityUpdate</code> and <code>LightClientOptimisticUpdate</code>:<ul> <li><code>update: LightClientUpdate</code>: Every <code>update</code> triggers <code>process_light_client_update(store, update, current_slot, genesis_validators_root)</code> where <code>current_slot</code> is the current slot based on a local clock.</li> <li><code>finality_update: LightClientFinalityUpdate</code>: Every <code>finality_update</code> triggers <code>process_light_client_finality_update(store, finality_update, current_slot, genesis_validators_root)</code>.</li> <li><code>optimistic_update: LightClientOptimisticUpdate</code>: Every <code>optimistic_update</code> triggers <code>process_light_client_optimistic_update(store, optimistic_update, current_slot, genesis_validators_root)</code>.</li> </ul> </li> <li><code>process_light_client_store_force_update</code> MAY be called based on use case dependent heuristics if light client sync appears stuck.</li> </ul>"},{"location":"specs/altair/light-client/sync-protocol/#validate_light_client_update","title":"<code>validate_light_client_update</code>","text":"<pre><code>def validate_light_client_update(store: LightClientStore,\nupdate: LightClientUpdate,\ncurrent_slot: Slot,\ngenesis_validators_root: Root) -&gt; None:\n# Verify sync committee has sufficient participants\nsync_aggregate = update.sync_aggregate\nassert sum(sync_aggregate.sync_committee_bits) &gt;= MIN_SYNC_COMMITTEE_PARTICIPANTS\n# Verify update does not skip a sync committee period\nassert is_valid_light_client_header(update.attested_header)\nupdate_attested_slot = update.attested_header.beacon.slot\nupdate_finalized_slot = update.finalized_header.beacon.slot\nassert current_slot &gt;= update.signature_slot &gt; update_attested_slot &gt;= update_finalized_slot\nstore_period = compute_sync_committee_period_at_slot(store.finalized_header.beacon.slot)\nupdate_signature_period = compute_sync_committee_period_at_slot(update.signature_slot)\nif is_next_sync_committee_known(store):\nassert update_signature_period in (store_period, store_period + 1)\nelse:\nassert update_signature_period == store_period\n# Verify update is relevant\nupdate_attested_period = compute_sync_committee_period_at_slot(update_attested_slot)\nupdate_has_next_sync_committee = not is_next_sync_committee_known(store) and (\nis_sync_committee_update(update) and update_attested_period == store_period\n)\nassert (\nupdate_attested_slot &gt; store.finalized_header.beacon.slot\nor update_has_next_sync_committee\n)\n# Verify that the `finality_branch`, if present, confirms `finalized_header`\n# to match the finalized checkpoint root saved in the state of `attested_header`.\n# Note that the genesis finalized checkpoint root is represented as a zero hash.\nif not is_finality_update(update):\nassert update.finalized_header == LightClientHeader()\nelse:\nif update_finalized_slot == GENESIS_SLOT:\nassert update.finalized_header == LightClientHeader()\nfinalized_root = Bytes32()\nelse:\nassert is_valid_light_client_header(update.finalized_header)\nfinalized_root = hash_tree_root(update.finalized_header.beacon)\nassert is_valid_merkle_branch(\nleaf=finalized_root,\nbranch=update.finality_branch,\ndepth=floorlog2(FINALIZED_ROOT_GINDEX),\nindex=get_subtree_index(FINALIZED_ROOT_GINDEX),\nroot=update.attested_header.beacon.state_root,\n)\n# Verify that the `next_sync_committee`, if present, actually is the next sync committee saved in the\n# state of the `attested_header`\nif not is_sync_committee_update(update):\nassert update.next_sync_committee == SyncCommittee()\nelse:\nif update_attested_period == store_period and is_next_sync_committee_known(store):\nassert update.next_sync_committee == store.next_sync_committee\nassert is_valid_merkle_branch(\nleaf=hash_tree_root(update.next_sync_committee),\nbranch=update.next_sync_committee_branch,\ndepth=floorlog2(NEXT_SYNC_COMMITTEE_GINDEX),\nindex=get_subtree_index(NEXT_SYNC_COMMITTEE_GINDEX),\nroot=update.attested_header.beacon.state_root,\n)\n# Verify sync committee aggregate signature\nif update_signature_period == store_period:\nsync_committee = store.current_sync_committee\nelse:\nsync_committee = store.next_sync_committee\nparticipant_pubkeys = [\npubkey for (bit, pubkey) in zip(sync_aggregate.sync_committee_bits, sync_committee.pubkeys)\nif bit\n]\nfork_version_slot = max(update.signature_slot, Slot(1)) - Slot(1)\nfork_version = compute_fork_version(compute_epoch_at_slot(fork_version_slot))\ndomain = compute_domain(DOMAIN_SYNC_COMMITTEE, fork_version, genesis_validators_root)\nsigning_root = compute_signing_root(update.attested_header.beacon, domain)\nassert bls.FastAggregateVerify(participant_pubkeys, signing_root, sync_aggregate.sync_committee_signature)\n</code></pre>"},{"location":"specs/altair/light-client/sync-protocol/#apply_light_client_update","title":"<code>apply_light_client_update</code>","text":"<pre><code>def apply_light_client_update(store: LightClientStore, update: LightClientUpdate) -&gt; None:\nstore_period = compute_sync_committee_period_at_slot(store.finalized_header.beacon.slot)\nupdate_finalized_period = compute_sync_committee_period_at_slot(update.finalized_header.beacon.slot)\nif not is_next_sync_committee_known(store):\nassert update_finalized_period == store_period\nstore.next_sync_committee = update.next_sync_committee\nelif update_finalized_period == store_period + 1:\nstore.current_sync_committee = store.next_sync_committee\nstore.next_sync_committee = update.next_sync_committee\nstore.previous_max_active_participants = store.current_max_active_participants\nstore.current_max_active_participants = 0\nif update.finalized_header.beacon.slot &gt; store.finalized_header.beacon.slot:\nstore.finalized_header = update.finalized_header\nif store.finalized_header.beacon.slot &gt; store.optimistic_header.beacon.slot:\nstore.optimistic_header = store.finalized_header\n</code></pre>"},{"location":"specs/altair/light-client/sync-protocol/#process_light_client_store_force_update","title":"<code>process_light_client_store_force_update</code>","text":"<pre><code>def process_light_client_store_force_update(store: LightClientStore, current_slot: Slot) -&gt; None:\nif (\ncurrent_slot &gt; store.finalized_header.beacon.slot + UPDATE_TIMEOUT\nand store.best_valid_update is not None\n):\n# Forced best update when the update timeout has elapsed.\n# Because the apply logic waits for `finalized_header.beacon.slot` to indicate sync committee finality,\n# the `attested_header` may be treated as `finalized_header` in extended periods of non-finality\n# to guarantee progression into later sync committee periods according to `is_better_update`.\nif store.best_valid_update.finalized_header.beacon.slot &lt;= store.finalized_header.beacon.slot:\nstore.best_valid_update.finalized_header = store.best_valid_update.attested_header\napply_light_client_update(store, store.best_valid_update)\nstore.best_valid_update = None\n</code></pre>"},{"location":"specs/altair/light-client/sync-protocol/#process_light_client_update","title":"<code>process_light_client_update</code>","text":"<pre><code>def process_light_client_update(store: LightClientStore,\nupdate: LightClientUpdate,\ncurrent_slot: Slot,\ngenesis_validators_root: Root) -&gt; None:\nvalidate_light_client_update(store, update, current_slot, genesis_validators_root)\nsync_committee_bits = update.sync_aggregate.sync_committee_bits\n# Update the best update in case we have to force-update to it if the timeout elapses\nif (\nstore.best_valid_update is None\nor is_better_update(update, store.best_valid_update)\n):\nstore.best_valid_update = update\n# Track the maximum number of active participants in the committee signatures\nstore.current_max_active_participants = max(\nstore.current_max_active_participants,\nsum(sync_committee_bits),\n)\n# Update the optimistic header\nif (\nsum(sync_committee_bits) &gt; get_safety_threshold(store)\nand update.attested_header.beacon.slot &gt; store.optimistic_header.beacon.slot\n):\nstore.optimistic_header = update.attested_header\n# Update finalized header\nupdate_has_finalized_next_sync_committee = (\nnot is_next_sync_committee_known(store)\nand is_sync_committee_update(update) and is_finality_update(update) and (\ncompute_sync_committee_period_at_slot(update.finalized_header.beacon.slot)\n== compute_sync_committee_period_at_slot(update.attested_header.beacon.slot)\n)\n)\nif (\nsum(sync_committee_bits) * 3 &gt;= len(sync_committee_bits) * 2\nand (\nupdate.finalized_header.beacon.slot &gt; store.finalized_header.beacon.slot\nor update_has_finalized_next_sync_committee\n)\n):\n# Normal update through 2/3 threshold\napply_light_client_update(store, update)\nstore.best_valid_update = None\n</code></pre>"},{"location":"specs/altair/light-client/sync-protocol/#process_light_client_finality_update","title":"<code>process_light_client_finality_update</code>","text":"<pre><code>def process_light_client_finality_update(store: LightClientStore,\nfinality_update: LightClientFinalityUpdate,\ncurrent_slot: Slot,\ngenesis_validators_root: Root) -&gt; None:\nupdate = LightClientUpdate(\nattested_header=finality_update.attested_header,\nnext_sync_committee=SyncCommittee(),\nnext_sync_committee_branch=NextSyncCommitteeBranch(),\nfinalized_header=finality_update.finalized_header,\nfinality_branch=finality_update.finality_branch,\nsync_aggregate=finality_update.sync_aggregate,\nsignature_slot=finality_update.signature_slot,\n)\nprocess_light_client_update(store, update, current_slot, genesis_validators_root)\n</code></pre>"},{"location":"specs/altair/light-client/sync-protocol/#process_light_client_optimistic_update","title":"<code>process_light_client_optimistic_update</code>","text":"<pre><code>def process_light_client_optimistic_update(store: LightClientStore,\noptimistic_update: LightClientOptimisticUpdate,\ncurrent_slot: Slot,\ngenesis_validators_root: Root) -&gt; None:\nupdate = LightClientUpdate(\nattested_header=optimistic_update.attested_header,\nnext_sync_committee=SyncCommittee(),\nnext_sync_committee_branch=NextSyncCommitteeBranch(),\nfinalized_header=LightClientHeader(),\nfinality_branch=FinalityBranch(),\nsync_aggregate=optimistic_update.sync_aggregate,\nsignature_slot=optimistic_update.signature_slot,\n)\nprocess_light_client_update(store, update, current_slot, genesis_validators_root)\n</code></pre>"},{"location":"specs/bellatrix/beacon-chain/","title":"Bellatrix -- The Beacon Chain","text":""},{"location":"specs/bellatrix/beacon-chain/#table-of-contents","title":"Table of contents","text":"<ul> <li>Introduction</li> <li>Custom types</li> <li>Preset</li> <li>Execution</li> <li>Updated penalty values</li> <li>Configuration</li> <li>Transition settings</li> <li>Containers</li> <li>Extended containers<ul> <li><code>BeaconBlockBody</code></li> <li><code>BeaconState</code></li> </ul> </li> <li>New containers<ul> <li><code>ExecutionPayload</code></li> <li><code>ExecutionPayloadHeader</code></li> </ul> </li> <li>Helper functions</li> <li>Predicates<ul> <li><code>is_merge_transition_complete</code></li> <li><code>is_merge_transition_block</code></li> <li><code>is_execution_enabled</code></li> </ul> </li> <li>Misc<ul> <li><code>compute_timestamp_at_slot</code></li> </ul> </li> <li>Beacon state accessors<ul> <li>Modified <code>get_inactivity_penalty_deltas</code></li> </ul> </li> <li>Beacon state mutators<ul> <li>Modified <code>slash_validator</code></li> </ul> </li> <li>Beacon chain state transition function</li> <li>Execution engine<ul> <li>Request data</li> <li><code>NewPayloadRequest</code></li> <li>Engine APIs</li> <li><code>notify_new_payload</code></li> <li><code>is_valid_block_hash</code></li> <li><code>verify_and_notify_new_payload</code></li> </ul> </li> <li>Block processing<ul> <li>Execution payload</li> <li><code>process_execution_payload</code></li> </ul> </li> <li>Epoch processing<ul> <li>Slashings</li> </ul> </li> <li>Testing</li> </ul>"},{"location":"specs/bellatrix/beacon-chain/#introduction","title":"Introduction","text":"<p>This upgrade adds transaction execution to the beacon chain as part of Bellatrix upgrade.</p> <p>Additionally, this upgrade introduces the following minor changes: * Penalty parameter updates to their planned maximally punitive values</p>"},{"location":"specs/bellatrix/beacon-chain/#custom-types","title":"Custom types","text":"<p>Note: The <code>Transaction</code> type is a stub which is not final.</p> Name SSZ equivalent Description <code>Transaction</code> <code>ByteList[MAX_BYTES_PER_TRANSACTION]</code> either a typed transaction envelope or a legacy transaction <code>ExecutionAddress</code> <code>Bytes20</code> Address of account on the execution layer"},{"location":"specs/bellatrix/beacon-chain/#preset","title":"Preset","text":""},{"location":"specs/bellatrix/beacon-chain/#execution","title":"Execution","text":"Name Value <code>MAX_BYTES_PER_TRANSACTION</code> <code>uint64(2**30)</code> (= 1,073,741,824) <code>MAX_TRANSACTIONS_PER_PAYLOAD</code> <code>uint64(2**20)</code> (= 1,048,576) <code>BYTES_PER_LOGS_BLOOM</code> <code>uint64(2**8)</code> (= 256) <code>MAX_EXTRA_DATA_BYTES</code> <code>2**5</code> (= 32)"},{"location":"specs/bellatrix/beacon-chain/#updated-penalty-values","title":"Updated penalty values","text":"<p>Bellatrix updates a few configuration values to move penalty parameters to their final, maximum security values.</p> <p>Note: The spec does not override previous configuration values but instead creates new values and replaces usage throughout.</p> Name Value <code>INACTIVITY_PENALTY_QUOTIENT_BELLATRIX</code> <code>uint64(2**24)</code> (= 16,777,216) <code>MIN_SLASHING_PENALTY_QUOTIENT_BELLATRIX</code> <code>uint64(2**5)</code> (= 32) <code>PROPORTIONAL_SLASHING_MULTIPLIER_BELLATRIX</code> <code>uint64(3)</code>"},{"location":"specs/bellatrix/beacon-chain/#configuration","title":"Configuration","text":""},{"location":"specs/bellatrix/beacon-chain/#transition-settings","title":"Transition settings","text":"Name Value <code>TERMINAL_TOTAL_DIFFICULTY</code> <code>58750000000000000000000</code> (Estimated: Sept 15, 2022) <code>TERMINAL_BLOCK_HASH</code> <code>Hash32()</code> <code>TERMINAL_BLOCK_HASH_ACTIVATION_EPOCH</code> <code>FAR_FUTURE_EPOCH</code>"},{"location":"specs/bellatrix/beacon-chain/#containers","title":"Containers","text":""},{"location":"specs/bellatrix/beacon-chain/#extended-containers","title":"Extended containers","text":""},{"location":"specs/bellatrix/beacon-chain/#beaconblockbody","title":"<code>BeaconBlockBody</code>","text":"<pre><code>class BeaconBlockBody(Container):\nrandao_reveal: BLSSignature\neth1_data: Eth1Data  # Eth1 data vote\ngraffiti: Bytes32  # Arbitrary data\n# Operations\nproposer_slashings: List[ProposerSlashing, MAX_PROPOSER_SLASHINGS]\nattester_slashings: List[AttesterSlashing, MAX_ATTESTER_SLASHINGS]\nattestations: List[Attestation, MAX_ATTESTATIONS]\ndeposits: List[Deposit, MAX_DEPOSITS]\nvoluntary_exits: List[SignedVoluntaryExit, MAX_VOLUNTARY_EXITS]\nsync_aggregate: SyncAggregate\n# Execution\nexecution_payload: ExecutionPayload  # [New in Bellatrix]\n</code></pre>"},{"location":"specs/bellatrix/beacon-chain/#beaconstate","title":"<code>BeaconState</code>","text":"<pre><code>class BeaconState(Container):\n# Versioning\ngenesis_time: uint64\ngenesis_validators_root: Root\nslot: Slot\nfork: Fork\n# History\nlatest_block_header: BeaconBlockHeader\nblock_roots: Vector[Root, SLOTS_PER_HISTORICAL_ROOT]\nstate_roots: Vector[Root, SLOTS_PER_HISTORICAL_ROOT]\nhistorical_roots: List[Root, HISTORICAL_ROOTS_LIMIT]\n# Eth1\neth1_data: Eth1Data\neth1_data_votes: List[Eth1Data, EPOCHS_PER_ETH1_VOTING_PERIOD * SLOTS_PER_EPOCH]\neth1_deposit_index: uint64\n# Registry\nvalidators: List[Validator, VALIDATOR_REGISTRY_LIMIT]\nbalances: List[Gwei, VALIDATOR_REGISTRY_LIMIT]\n# Randomness\nrandao_mixes: Vector[Bytes32, EPOCHS_PER_HISTORICAL_VECTOR]\n# Slashings\nslashings: Vector[Gwei, EPOCHS_PER_SLASHINGS_VECTOR]  # Per-epoch sums of slashed effective balances\n# Participation\nprevious_epoch_participation: List[ParticipationFlags, VALIDATOR_REGISTRY_LIMIT]\ncurrent_epoch_participation: List[ParticipationFlags, VALIDATOR_REGISTRY_LIMIT]\n# Finality\njustification_bits: Bitvector[JUSTIFICATION_BITS_LENGTH]  # Bit set for every recent justified epoch\nprevious_justified_checkpoint: Checkpoint\ncurrent_justified_checkpoint: Checkpoint\nfinalized_checkpoint: Checkpoint\n# Inactivity\ninactivity_scores: List[uint64, VALIDATOR_REGISTRY_LIMIT]\n# Sync\ncurrent_sync_committee: SyncCommittee\nnext_sync_committee: SyncCommittee\n# Execution\nlatest_execution_payload_header: ExecutionPayloadHeader  # [New in Bellatrix]\n</code></pre>"},{"location":"specs/bellatrix/beacon-chain/#new-containers","title":"New containers","text":""},{"location":"specs/bellatrix/beacon-chain/#executionpayload","title":"<code>ExecutionPayload</code>","text":"<pre><code>class ExecutionPayload(Container):\n# Execution block header fields\nparent_hash: Hash32\nfee_recipient: ExecutionAddress  # 'beneficiary' in the yellow paper\nstate_root: Bytes32\nreceipts_root: Bytes32\nlogs_bloom: ByteVector[BYTES_PER_LOGS_BLOOM]\nprev_randao: Bytes32  # 'difficulty' in the yellow paper\nblock_number: uint64  # 'number' in the yellow paper\ngas_limit: uint64\ngas_used: uint64\ntimestamp: uint64\nextra_data: ByteList[MAX_EXTRA_DATA_BYTES]\nbase_fee_per_gas: uint256\n# Extra payload fields\nblock_hash: Hash32  # Hash of execution block\ntransactions: List[Transaction, MAX_TRANSACTIONS_PER_PAYLOAD]\n</code></pre>"},{"location":"specs/bellatrix/beacon-chain/#executionpayloadheader","title":"<code>ExecutionPayloadHeader</code>","text":"<pre><code>class ExecutionPayloadHeader(Container):\n# Execution block header fields\nparent_hash: Hash32\nfee_recipient: ExecutionAddress\nstate_root: Bytes32\nreceipts_root: Bytes32\nlogs_bloom: ByteVector[BYTES_PER_LOGS_BLOOM]\nprev_randao: Bytes32\nblock_number: uint64\ngas_limit: uint64\ngas_used: uint64\ntimestamp: uint64\nextra_data: ByteList[MAX_EXTRA_DATA_BYTES]\nbase_fee_per_gas: uint256\n# Extra payload fields\nblock_hash: Hash32  # Hash of execution block\ntransactions_root: Root\n</code></pre>"},{"location":"specs/bellatrix/beacon-chain/#helper-functions","title":"Helper functions","text":""},{"location":"specs/bellatrix/beacon-chain/#predicates","title":"Predicates","text":""},{"location":"specs/bellatrix/beacon-chain/#is_merge_transition_complete","title":"<code>is_merge_transition_complete</code>","text":"<pre><code>def is_merge_transition_complete(state: BeaconState) -&gt; bool:\nreturn state.latest_execution_payload_header != ExecutionPayloadHeader()\n</code></pre>"},{"location":"specs/bellatrix/beacon-chain/#is_merge_transition_block","title":"<code>is_merge_transition_block</code>","text":"<pre><code>def is_merge_transition_block(state: BeaconState, body: BeaconBlockBody) -&gt; bool:\nreturn not is_merge_transition_complete(state) and body.execution_payload != ExecutionPayload()\n</code></pre>"},{"location":"specs/bellatrix/beacon-chain/#is_execution_enabled","title":"<code>is_execution_enabled</code>","text":"<pre><code>def is_execution_enabled(state: BeaconState, body: BeaconBlockBody) -&gt; bool:\nreturn is_merge_transition_block(state, body) or is_merge_transition_complete(state)\n</code></pre>"},{"location":"specs/bellatrix/beacon-chain/#misc","title":"Misc","text":""},{"location":"specs/bellatrix/beacon-chain/#compute_timestamp_at_slot","title":"<code>compute_timestamp_at_slot</code>","text":"<p>Note: This function is unsafe with respect to overflows and underflows.</p> <pre><code>def compute_timestamp_at_slot(state: BeaconState, slot: Slot) -&gt; uint64:\nslots_since_genesis = slot - GENESIS_SLOT\nreturn uint64(state.genesis_time + slots_since_genesis * SECONDS_PER_SLOT)\n</code></pre>"},{"location":"specs/bellatrix/beacon-chain/#beacon-state-accessors","title":"Beacon state accessors","text":""},{"location":"specs/bellatrix/beacon-chain/#modified-get_inactivity_penalty_deltas","title":"Modified <code>get_inactivity_penalty_deltas</code>","text":"<p>Note: The function <code>get_inactivity_penalty_deltas</code> is modified to use <code>INACTIVITY_PENALTY_QUOTIENT_BELLATRIX</code>.</p> <pre><code>def get_inactivity_penalty_deltas(state: BeaconState) -&gt; Tuple[Sequence[Gwei], Sequence[Gwei]]:\n\"\"\"\n    Return the inactivity penalty deltas by considering timely target participation flags and inactivity scores.\n    \"\"\"\nrewards = [Gwei(0) for _ in range(len(state.validators))]\npenalties = [Gwei(0) for _ in range(len(state.validators))]\nprevious_epoch = get_previous_epoch(state)\nmatching_target_indices = get_unslashed_participating_indices(state, TIMELY_TARGET_FLAG_INDEX, previous_epoch)\nfor index in get_eligible_validator_indices(state):\nif index not in matching_target_indices:\npenalty_numerator = state.validators[index].effective_balance * state.inactivity_scores[index]\n# [Modified in Bellatrix]\npenalty_denominator = INACTIVITY_SCORE_BIAS * INACTIVITY_PENALTY_QUOTIENT_BELLATRIX\npenalties[index] += Gwei(penalty_numerator // penalty_denominator)\nreturn rewards, penalties\n</code></pre>"},{"location":"specs/bellatrix/beacon-chain/#beacon-state-mutators","title":"Beacon state mutators","text":""},{"location":"specs/bellatrix/beacon-chain/#modified-slash_validator","title":"Modified <code>slash_validator</code>","text":"<p>Note: The function <code>slash_validator</code> is modified to use <code>MIN_SLASHING_PENALTY_QUOTIENT_BELLATRIX</code>.</p> <pre><code>def slash_validator(state: BeaconState,\nslashed_index: ValidatorIndex,\nwhistleblower_index: ValidatorIndex=None) -&gt; None:\n\"\"\"\n    Slash the validator with index ``slashed_index``.\n    \"\"\"\nepoch = get_current_epoch(state)\ninitiate_validator_exit(state, slashed_index)\nvalidator = state.validators[slashed_index]\nvalidator.slashed = True\nvalidator.withdrawable_epoch = max(validator.withdrawable_epoch, Epoch(epoch + EPOCHS_PER_SLASHINGS_VECTOR))\nstate.slashings[epoch % EPOCHS_PER_SLASHINGS_VECTOR] += validator.effective_balance\nslashing_penalty = validator.effective_balance // MIN_SLASHING_PENALTY_QUOTIENT_BELLATRIX  # [Modified in Bellatrix]\ndecrease_balance(state, slashed_index, slashing_penalty)\n# Apply proposer and whistleblower rewards\nproposer_index = get_beacon_proposer_index(state)\nif whistleblower_index is None:\nwhistleblower_index = proposer_index\nwhistleblower_reward = Gwei(validator.effective_balance // WHISTLEBLOWER_REWARD_QUOTIENT)\nproposer_reward = Gwei(whistleblower_reward * PROPOSER_WEIGHT // WEIGHT_DENOMINATOR)\nincrease_balance(state, proposer_index, proposer_reward)\nincrease_balance(state, whistleblower_index, Gwei(whistleblower_reward - proposer_reward))\n</code></pre>"},{"location":"specs/bellatrix/beacon-chain/#beacon-chain-state-transition-function","title":"Beacon chain state transition function","text":""},{"location":"specs/bellatrix/beacon-chain/#execution-engine","title":"Execution engine","text":""},{"location":"specs/bellatrix/beacon-chain/#request-data","title":"Request data","text":""},{"location":"specs/bellatrix/beacon-chain/#newpayloadrequest","title":"<code>NewPayloadRequest</code>","text":"<pre><code>@dataclass\nclass NewPayloadRequest(object):\nexecution_payload: ExecutionPayload\n</code></pre>"},{"location":"specs/bellatrix/beacon-chain/#engine-apis","title":"Engine APIs","text":"<p>The implementation-dependent <code>ExecutionEngine</code> protocol encapsulates the execution sub-system logic via:</p> <ul> <li>a state object <code>self.execution_state</code> of type <code>ExecutionState</code></li> <li>a notification function <code>self.notify_new_payload</code> which may apply changes to the <code>self.execution_state</code></li> </ul> <p>The body of these functions are implementation dependent. The Engine API may be used to implement this and similarly defined functions via an external execution engine.</p>"},{"location":"specs/bellatrix/beacon-chain/#notify_new_payload","title":"<code>notify_new_payload</code>","text":"<p><code>notify_new_payload</code> is a function accessed through the <code>EXECUTION_ENGINE</code> module which instantiates the <code>ExecutionEngine</code> protocol.</p> <pre><code>def notify_new_payload(self: ExecutionEngine, execution_payload: ExecutionPayload) -&gt; bool:\n\"\"\"\n    Return ``True`` if and only if ``execution_payload`` is valid with respect to ``self.execution_state``.\n    \"\"\"\n...\n</code></pre>"},{"location":"specs/bellatrix/beacon-chain/#is_valid_block_hash","title":"<code>is_valid_block_hash</code>","text":"<pre><code>def is_valid_block_hash(self: ExecutionEngine, execution_payload: ExecutionPayload) -&gt; bool:\n\"\"\"\n    Return ``True`` if and only if ``execution_payload.block_hash`` is computed correctly.\n    \"\"\"\n...\n</code></pre>"},{"location":"specs/bellatrix/beacon-chain/#verify_and_notify_new_payload","title":"<code>verify_and_notify_new_payload</code>","text":"<pre><code>def verify_and_notify_new_payload(self: ExecutionEngine,\nnew_payload_request: NewPayloadRequest) -&gt; bool:\n\"\"\"\n    Return ``True`` if and only if ``new_payload_request`` is valid with respect to ``self.execution_state``.\n    \"\"\"\nif not self.is_valid_block_hash(new_payload_request.execution_payload):\nreturn False\nif not self.notify_new_payload(new_payload_request.execution_payload):\nreturn False\nreturn True\n</code></pre>"},{"location":"specs/bellatrix/beacon-chain/#block-processing","title":"Block processing","text":"<p>Note: The call to the <code>process_execution_payload</code> must happen before the call to the <code>process_randao</code> as the former depends on the <code>randao_mix</code> computed with the reveal of the previous block.</p> <pre><code>def process_block(state: BeaconState, block: BeaconBlock) -&gt; None:\nprocess_block_header(state, block)\nif is_execution_enabled(state, block.body):\nprocess_execution_payload(state, block.body, EXECUTION_ENGINE)  # [New in Bellatrix]\nprocess_randao(state, block.body)\nprocess_eth1_data(state, block.body)\nprocess_operations(state, block.body)\nprocess_sync_aggregate(state, block.body.sync_aggregate)\n</code></pre>"},{"location":"specs/bellatrix/beacon-chain/#execution-payload","title":"Execution payload","text":""},{"location":"specs/bellatrix/beacon-chain/#process_execution_payload","title":"<code>process_execution_payload</code>","text":"<pre><code>def process_execution_payload(state: BeaconState, body: BeaconBlockBody, execution_engine: ExecutionEngine) -&gt; None:\npayload = body.execution_payload\n# Verify consistency of the parent hash with respect to the previous execution payload header\nif is_merge_transition_complete(state):\nassert payload.parent_hash == state.latest_execution_payload_header.block_hash\n# Verify prev_randao\nassert payload.prev_randao == get_randao_mix(state, get_current_epoch(state))\n# Verify timestamp\nassert payload.timestamp == compute_timestamp_at_slot(state, state.slot)\n# Verify the execution payload is valid\nassert execution_engine.verify_and_notify_new_payload(NewPayloadRequest(execution_payload=payload))\n# Cache execution payload header\nstate.latest_execution_payload_header = ExecutionPayloadHeader(\nparent_hash=payload.parent_hash,\nfee_recipient=payload.fee_recipient,\nstate_root=payload.state_root,\nreceipts_root=payload.receipts_root,\nlogs_bloom=payload.logs_bloom,\nprev_randao=payload.prev_randao,\nblock_number=payload.block_number,\ngas_limit=payload.gas_limit,\ngas_used=payload.gas_used,\ntimestamp=payload.timestamp,\nextra_data=payload.extra_data,\nbase_fee_per_gas=payload.base_fee_per_gas,\nblock_hash=payload.block_hash,\ntransactions_root=hash_tree_root(payload.transactions),\n)\n</code></pre>"},{"location":"specs/bellatrix/beacon-chain/#epoch-processing","title":"Epoch processing","text":""},{"location":"specs/bellatrix/beacon-chain/#slashings","title":"Slashings","text":"<p>Note: The function <code>process_slashings</code> is modified to use <code>PROPORTIONAL_SLASHING_MULTIPLIER_BELLATRIX</code>.</p> <pre><code>def process_slashings(state: BeaconState) -&gt; None:\nepoch = get_current_epoch(state)\ntotal_balance = get_total_active_balance(state)\nadjusted_total_slashing_balance = min(\nsum(state.slashings) * PROPORTIONAL_SLASHING_MULTIPLIER_BELLATRIX,  # [Modified in Bellatrix]\ntotal_balance\n)\nfor index, validator in enumerate(state.validators):\nif validator.slashed and epoch + EPOCHS_PER_SLASHINGS_VECTOR // 2 == validator.withdrawable_epoch:\nincrement = EFFECTIVE_BALANCE_INCREMENT  # Factored out from penalty numerator to avoid uint64 overflow\npenalty_numerator = validator.effective_balance // increment * adjusted_total_slashing_balance\npenalty = penalty_numerator // total_balance * increment\ndecrease_balance(state, ValidatorIndex(index), penalty)\n</code></pre>"},{"location":"specs/bellatrix/beacon-chain/#testing","title":"Testing","text":"<p>Note: The function <code>initialize_beacon_state_from_eth1</code> is modified for pure Bellatrix testing only. Modifications include: 1. Use <code>BELLATRIX_FORK_VERSION</code> as the previous and current fork version. 2. Utilize the Bellatrix <code>BeaconBlockBody</code> when constructing the initial <code>latest_block_header</code>. 3. Initialize <code>latest_execution_payload_header</code>.   If <code>execution_payload_header == ExecutionPayloadHeader()</code>, then the Merge has not yet occurred.   Else, the Merge starts from genesis and the transition is incomplete.</p> <pre><code>def initialize_beacon_state_from_eth1(eth1_block_hash: Hash32,\neth1_timestamp: uint64,\ndeposits: Sequence[Deposit],\nexecution_payload_header: ExecutionPayloadHeader=ExecutionPayloadHeader()\n) -&gt; BeaconState:\nfork = Fork(\nprevious_version=BELLATRIX_FORK_VERSION,  # [Modified in Bellatrix] for testing only\ncurrent_version=BELLATRIX_FORK_VERSION,  # [Modified in Bellatrix]\nepoch=GENESIS_EPOCH,\n)\nstate = BeaconState(\ngenesis_time=eth1_timestamp + GENESIS_DELAY,\nfork=fork,\neth1_data=Eth1Data(block_hash=eth1_block_hash, deposit_count=uint64(len(deposits))),\nlatest_block_header=BeaconBlockHeader(body_root=hash_tree_root(BeaconBlockBody())),\nrandao_mixes=[eth1_block_hash] * EPOCHS_PER_HISTORICAL_VECTOR,  # Seed RANDAO with Eth1 entropy\n)\n# Process deposits\nleaves = list(map(lambda deposit: deposit.data, deposits))\nfor index, deposit in enumerate(deposits):\ndeposit_data_list = List[DepositData, 2**DEPOSIT_CONTRACT_TREE_DEPTH](*leaves[:index + 1])\nstate.eth1_data.deposit_root = hash_tree_root(deposit_data_list)\nprocess_deposit(state, deposit)\n# Process activations\nfor index, validator in enumerate(state.validators):\nbalance = state.balances[index]\nvalidator.effective_balance = min(balance - balance % EFFECTIVE_BALANCE_INCREMENT, MAX_EFFECTIVE_BALANCE)\nif validator.effective_balance == MAX_EFFECTIVE_BALANCE:\nvalidator.activation_eligibility_epoch = GENESIS_EPOCH\nvalidator.activation_epoch = GENESIS_EPOCH\n# Set genesis validators root for domain separation and chain versioning\nstate.genesis_validators_root = hash_tree_root(state.validators)\n# Fill in sync committees\n# Note: A duplicate committee is assigned for the current and next committee at genesis\nstate.current_sync_committee = get_next_sync_committee(state)\nstate.next_sync_committee = get_next_sync_committee(state)\n# [New in Bellatrix] Initialize the execution payload header\n# If empty, will initialize a chain that has not yet gone through the Merge transition\nstate.latest_execution_payload_header = execution_payload_header\nreturn state\n</code></pre>"},{"location":"specs/bellatrix/fork-choice/","title":"Bellatrix -- Fork Choice","text":""},{"location":"specs/bellatrix/fork-choice/#table-of-contents","title":"Table of contents","text":"<ul> <li>Introduction</li> <li>Custom types</li> <li>Protocols</li> <li><code>ExecutionEngine</code><ul> <li><code>notify_forkchoice_updated</code></li> <li><code>safe_block_hash</code></li> <li><code>should_override_forkchoice_update</code></li> </ul> </li> <li>Helpers</li> <li><code>PayloadAttributes</code></li> <li><code>PowBlock</code></li> <li><code>get_pow_block</code></li> <li><code>is_valid_terminal_pow_block</code></li> <li><code>validate_merge_block</code></li> <li>Updated fork-choice handlers</li> <li><code>on_block</code></li> </ul>"},{"location":"specs/bellatrix/fork-choice/#introduction","title":"Introduction","text":"<p>This is the modification of the fork choice according to the executable beacon chain proposal.</p> <p>Note: It introduces the process of transition from the last PoW block to the first PoS block.</p>"},{"location":"specs/bellatrix/fork-choice/#custom-types","title":"Custom types","text":"Name SSZ equivalent Description <code>PayloadId</code> <code>Bytes8</code> Identifier of a payload building process"},{"location":"specs/bellatrix/fork-choice/#protocols","title":"Protocols","text":""},{"location":"specs/bellatrix/fork-choice/#executionengine","title":"<code>ExecutionEngine</code>","text":"<p>Note: The <code>notify_forkchoice_updated</code> function is added to the <code>ExecutionEngine</code> protocol to signal the fork choice updates.</p> <p>The body of this function is implementation dependent. The Engine API may be used to implement it with an external execution engine.</p>"},{"location":"specs/bellatrix/fork-choice/#notify_forkchoice_updated","title":"<code>notify_forkchoice_updated</code>","text":"<p>This function performs three actions atomically: * Re-organizes the execution payload chain and corresponding state to make <code>head_block_hash</code> the head. * Updates safe block hash with the value provided by <code>safe_block_hash</code> parameter. * Applies finality to the execution state: it irreversibly persists the chain of all execution payloads and corresponding state, up to and including <code>finalized_block_hash</code>.</p> <p>Additionally, if <code>payload_attributes</code> is provided, this function sets in motion a payload build process on top of <code>head_block_hash</code> and returns an identifier of initiated process.</p> <pre><code>def notify_forkchoice_updated(self: ExecutionEngine,\nhead_block_hash: Hash32,\nsafe_block_hash: Hash32,\nfinalized_block_hash: Hash32,\npayload_attributes: Optional[PayloadAttributes]) -&gt; Optional[PayloadId]:\n...\n</code></pre> <p>Note: The <code>(head_block_hash, finalized_block_hash)</code> values of the <code>notify_forkchoice_updated</code> function call maps on the <code>POS_FORKCHOICE_UPDATED</code> event defined in the EIP-3675. As per EIP-3675, before a post-transition block is finalized, <code>notify_forkchoice_updated</code> MUST be called with <code>finalized_block_hash = Hash32()</code>.</p> <p>Note: Client software MUST NOT call this function until the transition conditions are met on the PoW network, i.e. there exists a block for which <code>is_valid_terminal_pow_block</code> function returns <code>True</code>.</p> <p>Note: Client software MUST call this function to initiate the payload build process to produce the merge transition block; the <code>head_block_hash</code> parameter MUST be set to the hash of a terminal PoW block in this case.</p>"},{"location":"specs/bellatrix/fork-choice/#safe_block_hash","title":"<code>safe_block_hash</code>","text":"<p>The <code>safe_block_hash</code> parameter MUST be set to return value of <code>get_safe_execution_payload_hash(store: Store)</code> function.</p>"},{"location":"specs/bellatrix/fork-choice/#should_override_forkchoice_update","title":"<code>should_override_forkchoice_update</code>","text":"<p>If proposer boost re-orgs are implemented and enabled (see <code>get_proposer_head</code>) then additional care must be taken to ensure that the proposer is able to build an execution payload.</p> <p>If a beacon node knows it will propose the next block then it SHOULD NOT call <code>notify_forkchoice_updated</code> if it detects the current head to be weak and potentially capable of being re-orged. Complete information for evaluating <code>get_proposer_head</code> will not be available immediately after the receipt of a new block, so an approximation of those conditions should be used when deciding whether to send or suppress a fork choice notification. The exact conditions used may be implementation-specific, a suggested implementation is below.</p> <p>Let <code>validator_is_connected(validator_index: ValidatorIndex) -&gt; bool</code> be a function that indicates whether the validator with <code>validator_index</code> is connected to the node (e.g. has sent an unexpired proposer preparation message).</p> <pre><code>def should_override_forkchoice_update(store: Store, head_root: Root) -&gt; bool:\nhead_block = store.blocks[head_root]\nparent_root = head_block.parent_root\nparent_block = store.blocks[parent_root]\ncurrent_slot = get_current_slot(store)\nproposal_slot = head_block.slot + Slot(1)\n# Only re-org the head_block block if it arrived later than the attestation deadline.\nhead_late = is_head_late(store, head_root)\n# Shuffling stable.\nshuffling_stable = is_shuffling_stable(proposal_slot)\n# FFG information of the new head_block will be competitive with the current head.\nffg_competitive = is_ffg_competitive(store, head_root, parent_root)\n# Do not re-org if the chain is not finalizing with acceptable frequency.\nfinalization_ok = is_finalization_ok(store, proposal_slot)\n# Only suppress the fork choice update if we are confident that we will propose the next block.\nparent_state_advanced = store.block_states[parent_root].copy()\nprocess_slots(parent_state_advanced, proposal_slot)\nproposer_index = get_beacon_proposer_index(parent_state_advanced)\nproposing_reorg_slot = validator_is_connected(proposer_index)\n# Single slot re-org.\nparent_slot_ok = parent_block.slot + 1 == head_block.slot\nproposing_on_time = is_proposing_on_time(store)\n# Note that this condition is different from `get_proposer_head`\ncurrent_time_ok = (head_block.slot == current_slot\nor (proposal_slot == current_slot and proposing_on_time))\nsingle_slot_reorg = parent_slot_ok and current_time_ok\n# Check the head weight only if the attestations from the head slot have already been applied.\n# Implementations may want to do this in different ways, e.g. by advancing\n# `store.time` early, or by counting queued attestations during the head block's slot.\nif current_slot &gt; head_block.slot:\nhead_weak = is_head_weak(store, head_root)\nparent_strong = is_parent_strong(store, parent_root)\nelse:\nhead_weak = True\nparent_strong = True\nreturn all([head_late, shuffling_stable, ffg_competitive, finalization_ok,\nproposing_reorg_slot, single_slot_reorg,\nhead_weak, parent_strong])\n</code></pre> <p>Note: The ordering of conditions is a suggestion only. Implementations are free to optimize by re-ordering the conditions from least to most expensive and by returning early if any of the early conditions are <code>False</code>.</p> <p>In case <code>should_override_forkchoice_update</code> returns <code>True</code>, a node SHOULD instead call <code>notify_forkchoice_updated</code> with parameters appropriate for building upon the parent block. Care must be taken to compute the correct <code>payload_attributes</code>, as they may change depending on the slot of the block to be proposed (due to withdrawals).</p> <p>If <code>should_override_forkchoice_update</code> returns <code>True</code> but <code>get_proposer_head</code> later chooses the canonical head rather than its parent, then this is a misprediction that will cause the node to construct a payload with less notice. The result of <code>get_proposer_head</code> MUST be preferred over the result of <code>should_override_forkchoice_update</code> (when proposer reorgs are enabled).</p>"},{"location":"specs/bellatrix/fork-choice/#helpers","title":"Helpers","text":""},{"location":"specs/bellatrix/fork-choice/#payloadattributes","title":"<code>PayloadAttributes</code>","text":"<p>Used to signal to initiate the payload build process via <code>notify_forkchoice_updated</code>.</p> <pre><code>@dataclass\nclass PayloadAttributes(object):\ntimestamp: uint64\nprev_randao: Bytes32\nsuggested_fee_recipient: ExecutionAddress\n</code></pre>"},{"location":"specs/bellatrix/fork-choice/#powblock","title":"<code>PowBlock</code>","text":"<pre><code>class PowBlock(Container):\nblock_hash: Hash32\nparent_hash: Hash32\ntotal_difficulty: uint256\n</code></pre>"},{"location":"specs/bellatrix/fork-choice/#get_pow_block","title":"<code>get_pow_block</code>","text":"<p>Let <code>get_pow_block(block_hash: Hash32) -&gt; Optional[PowBlock]</code> be the function that given the hash of the PoW block returns its data. It may result in <code>None</code> if the requested block is not yet available.</p> <p>Note: The <code>eth_getBlockByHash</code> JSON-RPC method may be used to pull this information from an execution client.</p>"},{"location":"specs/bellatrix/fork-choice/#is_valid_terminal_pow_block","title":"<code>is_valid_terminal_pow_block</code>","text":"<p>Used by fork-choice handler, <code>on_block</code>.</p> <pre><code>def is_valid_terminal_pow_block(block: PowBlock, parent: PowBlock) -&gt; bool:\nis_total_difficulty_reached = block.total_difficulty &gt;= TERMINAL_TOTAL_DIFFICULTY\nis_parent_total_difficulty_valid = parent.total_difficulty &lt; TERMINAL_TOTAL_DIFFICULTY\nreturn is_total_difficulty_reached and is_parent_total_difficulty_valid\n</code></pre>"},{"location":"specs/bellatrix/fork-choice/#validate_merge_block","title":"<code>validate_merge_block</code>","text":"<pre><code>def validate_merge_block(block: BeaconBlock) -&gt; None:\n\"\"\"\n    Check the parent PoW block of execution payload is a valid terminal PoW block.\n    Note: Unavailable PoW block(s) may later become available,\n    and a client software MAY delay a call to ``validate_merge_block``\n    until the PoW block(s) become available.\n    \"\"\"\nif TERMINAL_BLOCK_HASH != Hash32():\n# If `TERMINAL_BLOCK_HASH` is used as an override, the activation epoch must be reached.\nassert compute_epoch_at_slot(block.slot) &gt;= TERMINAL_BLOCK_HASH_ACTIVATION_EPOCH\nassert block.body.execution_payload.parent_hash == TERMINAL_BLOCK_HASH\nreturn\npow_block = get_pow_block(block.body.execution_payload.parent_hash)\n# Check if `pow_block` is available\nassert pow_block is not None\npow_parent = get_pow_block(pow_block.parent_hash)\n# Check if `pow_parent` is available\nassert pow_parent is not None\n# Check if `pow_block` is a valid terminal PoW block\nassert is_valid_terminal_pow_block(pow_block, pow_parent)\n</code></pre>"},{"location":"specs/bellatrix/fork-choice/#updated-fork-choice-handlers","title":"Updated fork-choice handlers","text":""},{"location":"specs/bellatrix/fork-choice/#on_block","title":"<code>on_block</code>","text":"<p>Note: The only modification is the addition of the verification of transition block conditions.</p> <pre><code>def on_block(store: Store, signed_block: SignedBeaconBlock) -&gt; None:\n\"\"\"\n    Run ``on_block`` upon receiving a new block.\n    A block that is asserted as invalid due to unavailable PoW block may be valid at a later time,\n    consider scheduling it for later processing in such case.\n    \"\"\"\nblock = signed_block.message\n# Parent block must be known\nassert block.parent_root in store.block_states\n# Make a copy of the state to avoid mutability issues\npre_state = copy(store.block_states[block.parent_root])\n# Blocks cannot be in the future. If they are, their consideration must be delayed until they are in the past.\nassert get_current_slot(store) &gt;= block.slot\n# Check that block is later than the finalized epoch slot (optimization to reduce calls to get_ancestor)\nfinalized_slot = compute_start_slot_at_epoch(store.finalized_checkpoint.epoch)\nassert block.slot &gt; finalized_slot\n# Check block is a descendant of the finalized block at the checkpoint finalized slot\nfinalized_checkpoint_block = get_checkpoint_block(\nstore,\nblock.parent_root,\nstore.finalized_checkpoint.epoch,\n)\nassert store.finalized_checkpoint.root == finalized_checkpoint_block\n# Check the block is valid and compute the post-state\nstate = pre_state.copy()\nblock_root = hash_tree_root(block)\nstate_transition(state, signed_block, True)\n# [New in Bellatrix]\nif is_merge_transition_block(pre_state, block.body):\nvalidate_merge_block(block)\n# Add new block to the store\nstore.blocks[block_root] = block\n# Add new state for this block to the store\nstore.block_states[block_root] = state\n# Add block timeliness to the store\ntime_into_slot = (store.time - store.genesis_time) % SECONDS_PER_SLOT\nis_before_attesting_interval = time_into_slot &lt; SECONDS_PER_SLOT // INTERVALS_PER_SLOT\nis_timely = get_current_slot(store) == block.slot and is_before_attesting_interval\nstore.block_timeliness[hash_tree_root(block)] = is_timely\n# Add proposer score boost if the block is timely and not conflicting with an existing block\nis_first_block = store.proposer_boost_root == Root()\nif is_timely and is_first_block:\nstore.proposer_boost_root = hash_tree_root(block)\n# Update checkpoints in store if necessary\nupdate_checkpoints(store, state.current_justified_checkpoint, state.finalized_checkpoint)\n# Eagerly compute unrealized justification and finality.\ncompute_pulled_up_tip(store, block_root)\n</code></pre>"},{"location":"specs/bellatrix/fork/","title":"Bellatrix -- Fork Logic","text":""},{"location":"specs/bellatrix/fork/#table-of-contents","title":"Table of contents","text":"<ul> <li>Introduction</li> <li>Configuration</li> <li>Helper functions</li> <li>Misc<ul> <li>Modified <code>compute_fork_version</code></li> </ul> </li> <li>Fork to Bellatrix</li> <li>Fork trigger</li> <li>Upgrading the state</li> </ul>"},{"location":"specs/bellatrix/fork/#introduction","title":"Introduction","text":"<p>This document describes the process of Bellatrix upgrade.</p>"},{"location":"specs/bellatrix/fork/#configuration","title":"Configuration","text":"Name Value <code>BELLATRIX_FORK_VERSION</code> <code>Version('0x02000000')</code> <code>BELLATRIX_FORK_EPOCH</code> <code>Epoch(144896)</code> (Sept 6, 2022, 11:34:47am UTC)"},{"location":"specs/bellatrix/fork/#helper-functions","title":"Helper functions","text":""},{"location":"specs/bellatrix/fork/#misc","title":"Misc","text":""},{"location":"specs/bellatrix/fork/#modified-compute_fork_version","title":"Modified <code>compute_fork_version</code>","text":"<pre><code>def compute_fork_version(epoch: Epoch) -&gt; Version:\n\"\"\"\n    Return the fork version at the given ``epoch``.\n    \"\"\"\nif epoch &gt;= BELLATRIX_FORK_EPOCH:\nreturn BELLATRIX_FORK_VERSION\nif epoch &gt;= ALTAIR_FORK_EPOCH:\nreturn ALTAIR_FORK_VERSION\nreturn GENESIS_FORK_VERSION\n</code></pre>"},{"location":"specs/bellatrix/fork/#fork-to-bellatrix","title":"Fork to Bellatrix","text":""},{"location":"specs/bellatrix/fork/#fork-trigger","title":"Fork trigger","text":"<p>TBD. Social consensus, along with state conditions such as epoch boundary, finality, deposits, active validator count, etc. may be part of the decision process to trigger the fork. For now we assume the condition will be triggered at epoch <code>BELLATRIX_FORK_EPOCH</code>.</p> <p>Note that for the pure Bellatrix networks, we don't apply <code>upgrade_to_bellatrix</code> since it starts with Bellatrix version logic.</p>"},{"location":"specs/bellatrix/fork/#upgrading-the-state","title":"Upgrading the state","text":"<p>As with the Phase0-to-Altair upgrade, the <code>state_transition</code> is modified to upgrade the <code>BeaconState</code>. The <code>BeaconState</code> upgrade runs as part of <code>process_slots</code>, slots with missing block proposals do not affect the upgrade time.</p> <p>If <code>state.slot % SLOTS_PER_EPOCH == 0</code> and <code>compute_epoch_at_slot(state.slot) == BELLATRIX_FORK_EPOCH</code>, an irregular state change is made to upgrade to Bellatrix. The upgrade occurs after the completion of the inner loop of <code>process_slots</code> that sets <code>state.slot</code> equal to <code>BELLATRIX_FORK_EPOCH * SLOTS_PER_EPOCH</code>.</p> <p>When multiple upgrades are scheduled for the same epoch (common for test-networks), all the upgrades run in sequence before resuming the regular state transition.</p> <pre><code>def upgrade_to_bellatrix(pre: altair.BeaconState) -&gt; BeaconState:\nepoch = altair.get_current_epoch(pre)\npost = BeaconState(\n# Versioning\ngenesis_time=pre.genesis_time,\ngenesis_validators_root=pre.genesis_validators_root,\nslot=pre.slot,\nfork=Fork(\nprevious_version=pre.fork.current_version,\ncurrent_version=BELLATRIX_FORK_VERSION,\nepoch=epoch,\n),\n# History\nlatest_block_header=pre.latest_block_header,\nblock_roots=pre.block_roots,\nstate_roots=pre.state_roots,\nhistorical_roots=pre.historical_roots,\n# Eth1\neth1_data=pre.eth1_data,\neth1_data_votes=pre.eth1_data_votes,\neth1_deposit_index=pre.eth1_deposit_index,\n# Registry\nvalidators=pre.validators,\nbalances=pre.balances,\n# Randomness\nrandao_mixes=pre.randao_mixes,\n# Slashings\nslashings=pre.slashings,\n# Participation\nprevious_epoch_participation=pre.previous_epoch_participation,\ncurrent_epoch_participation=pre.current_epoch_participation,\n# Finality\njustification_bits=pre.justification_bits,\nprevious_justified_checkpoint=pre.previous_justified_checkpoint,\ncurrent_justified_checkpoint=pre.current_justified_checkpoint,\nfinalized_checkpoint=pre.finalized_checkpoint,\n# Inactivity\ninactivity_scores=pre.inactivity_scores,\n# Sync\ncurrent_sync_committee=pre.current_sync_committee,\nnext_sync_committee=pre.next_sync_committee,\n# Execution-layer\nlatest_execution_payload_header=ExecutionPayloadHeader(),\n)\nreturn post\n</code></pre>"},{"location":"specs/bellatrix/p2p-interface/","title":"Bellatrix -- Networking","text":"<p>This document contains the networking specification for the Bellatrix.</p> <p>The specification of these changes continues in the same format as the network specifications of previous upgrades, and assumes them as pre-requisite. This document should be viewed as additive to the documents from Phase 0 and from Altair and will be referred to as the \"Phase 0 document\" and \"Altair document\" respectively, hereafter. Readers should understand the Phase 0 and Altair documents and use them as a basis to understand the changes outlined in this document.</p>"},{"location":"specs/bellatrix/p2p-interface/#table-of-contents","title":"Table of contents","text":"<ul> <li>Modifications in Bellatrix<ul> <li>The gossip domain: gossipsub</li> <li>Topics and messages<ul> <li>Global topics</li> <li><code>beacon_block</code></li> </ul> </li> <li>Transitioning the gossip</li> <li>The Req/Resp domain</li> <li>Messages<ul> <li>BeaconBlocksByRange v2</li> <li>BeaconBlocksByRoot v2</li> </ul> </li> </ul> </li> <li>Design decision rationale<ul> <li>Gossipsub</li> <li>Why was the max gossip message size increased at Bellatrix?</li> <li>Req/Resp</li> <li>Why was the max chunk response size increased at Bellatrix?</li> <li>Why allow invalid payloads on the P2P network?</li> </ul> </li> </ul>"},{"location":"specs/bellatrix/p2p-interface/#modifications-in-bellatrix","title":"Modifications in Bellatrix","text":""},{"location":"specs/bellatrix/p2p-interface/#the-gossip-domain-gossipsub","title":"The gossip domain: gossipsub","text":"<p>Some gossip meshes are upgraded in Bellatrix to support upgraded types.</p>"},{"location":"specs/bellatrix/p2p-interface/#topics-and-messages","title":"Topics and messages","text":"<p>Topics follow the same specification as in prior upgrades. All topics remain stable except the beacon block topic which is updated with the modified type.</p> <p>The specification around the creation, validation, and dissemination of messages has not changed from the Phase 0 and Altair documents unless explicitly noted here.</p> <p>The derivation of the <code>message-id</code> remains stable.</p> <p>The new topics along with the type of the <code>data</code> field of a gossipsub message are given in this table:</p> Name Message Type <code>beacon_block</code> <code>SignedBeaconBlock</code> (modified) <p>Note that the <code>ForkDigestValue</code> path segment of the topic separates the old and the new <code>beacon_block</code> topics.</p>"},{"location":"specs/bellatrix/p2p-interface/#global-topics","title":"Global topics","text":"<p>Bellatrix changes the type of the global beacon block topic.</p>"},{"location":"specs/bellatrix/p2p-interface/#beacon_block","title":"<code>beacon_block</code>","text":"<p>The type of the payload of this topic changes to the (modified) <code>SignedBeaconBlock</code> found in Bellatrix. Specifically, this type changes with the addition of <code>execution_payload</code> to the inner <code>BeaconBlockBody</code>. See Bellatrix state transition document for further details.</p> <p>Blocks with execution enabled will be permitted to propagate regardless of the validity of the execution payload. This prevents network segregation between optimistic and non-optimistic nodes.</p> <p>In addition to the gossip validations for this topic from prior specifications, the following validations MUST pass before forwarding the <code>signed_beacon_block</code> on the network. Alias <code>block = signed_beacon_block.message</code>, <code>execution_payload = block.body.execution_payload</code>. - If the execution is enabled for the block -- i.e. <code>is_execution_enabled(state, block.body)</code>   then validate the following:     - [REJECT] The block's execution payload timestamp is correct with respect to the slot        -- i.e. <code>execution_payload.timestamp == compute_timestamp_at_slot(state, block.slot)</code>.     - If <code>execution_payload</code> verification of block's parent by an execution node is not complete:         - [REJECT] The block's parent (defined by <code>block.parent_root</code>) passes all           validation (excluding execution node verification of the <code>block.body.execution_payload</code>).     - otherwise:         - [IGNORE] The block's parent (defined by <code>block.parent_root</code>) passes all           validation (including execution node verification of the <code>block.body.execution_payload</code>).</p> <p>The following gossip validation from prior specifications MUST NOT be applied if the execution is enabled for the block -- i.e. <code>is_execution_enabled(state, block.body)</code>:   - [REJECT] The block's parent (defined by <code>block.parent_root</code>) passes validation.</p>"},{"location":"specs/bellatrix/p2p-interface/#transitioning-the-gossip","title":"Transitioning the gossip","text":"<p>See gossip transition details found in the Altair document for details on how to handle transitioning gossip topics.</p>"},{"location":"specs/bellatrix/p2p-interface/#the-reqresp-domain","title":"The Req/Resp domain","text":"<p>Non-faulty, optimistic nodes may send blocks which result in an INVALID response from an execution engine. To prevent network segregation between optimistic and non-optimistic nodes, transmission of an INVALID execution payload via the Req/Resp domain SHOULD NOT cause a node to be down-scored or disconnected. Transmission of a block which is invalid due to any consensus layer rules (i.e., not execution layer rules) MAY result in down-scoring or disconnection.</p>"},{"location":"specs/bellatrix/p2p-interface/#messages","title":"Messages","text":""},{"location":"specs/bellatrix/p2p-interface/#beaconblocksbyrange-v2","title":"BeaconBlocksByRange v2","text":"<p>Protocol ID: <code>/eth2/beacon_chain/req/beacon_blocks_by_range/2/</code></p> <p>Request and Response remain unchanged unless explicitly noted here.</p> <p>Bellatrix fork-digest is introduced to the <code>context</code> enum to specify Bellatrix block type.</p> <p>Per <code>context = compute_fork_digest(fork_version, genesis_validators_root)</code>:</p> <code>fork_version</code> Chunk SSZ type <code>GENESIS_FORK_VERSION</code> <code>phase0.SignedBeaconBlock</code> <code>ALTAIR_FORK_VERSION</code> <code>altair.SignedBeaconBlock</code> <code>BELLATRIX_FORK_VERSION</code> <code>bellatrix.SignedBeaconBlock</code>"},{"location":"specs/bellatrix/p2p-interface/#beaconblocksbyroot-v2","title":"BeaconBlocksByRoot v2","text":"<p>Protocol ID: <code>/eth2/beacon_chain/req/beacon_blocks_by_root/2/</code></p> <p>Request and Response remain unchanged. Bellatrix fork-digest is introduced to the <code>context</code> enum to specify Bellatrix block type.</p> <p>Per <code>context = compute_fork_digest(fork_version, genesis_validators_root)</code>:</p> <code>fork_version</code> Chunk SSZ type <code>GENESIS_FORK_VERSION</code> <code>phase0.SignedBeaconBlock</code> <code>ALTAIR_FORK_VERSION</code> <code>altair.SignedBeaconBlock</code> <code>BELLATRIX_FORK_VERSION</code> <code>bellatrix.SignedBeaconBlock</code>"},{"location":"specs/bellatrix/p2p-interface/#design-decision-rationale","title":"Design decision rationale","text":""},{"location":"specs/bellatrix/p2p-interface/#gossipsub","title":"Gossipsub","text":""},{"location":"specs/bellatrix/p2p-interface/#why-was-the-max-gossip-message-size-increased-at-bellatrix","title":"Why was the max gossip message size increased at Bellatrix?","text":"<p>With the addition of <code>ExecutionPayload</code> to <code>BeaconBlock</code>s, there is a dynamic field -- <code>transactions</code> -- which can validly exceed the <code>GOSSIP_MAX_SIZE</code> limit (1 MiB) put in place at Phase 0, so GOSSIP_MAX_SIZE has increased to 10 Mib on the network.  At the <code>GAS_LIMIT</code> (~30M) currently seen on mainnet in 2021, a single transaction filled entirely with data at a cost of 16 gas per byte can create a valid <code>ExecutionPayload</code> of ~2 MiB. Thus we need a size limit to at least account for current mainnet conditions.</p> <p>Note, that due to additional size induced by the <code>BeaconBlock</code> contents (e.g. proposer signature, operations lists, etc) this does reduce the theoretical max valid <code>ExecutionPayload</code> (and <code>transactions</code> list) size as slightly lower than 10 MiB. Considering that <code>BeaconBlock</code> max size is on the order of 128 KiB in the worst case and the current gas limit (~30M) bounds max blocksize to less than 2 MiB today, this marginal difference in theoretical bounds will have zero impact on network functionality and security.</p>"},{"location":"specs/bellatrix/p2p-interface/#reqresp","title":"Req/Resp","text":""},{"location":"specs/bellatrix/p2p-interface/#why-was-the-max-chunk-response-size-increased-at-bellatrix","title":"Why was the max chunk response size increased at Bellatrix?","text":"<p>Similar to the discussion about the maximum gossip size increase, the <code>ExecutionPayload</code> type can cause <code>BeaconBlock</code>s to exceed the 1 MiB bounds put in place during Phase 0.</p> <p>As with the gossip limit, 10 MiB is selected because this is firmly above any valid block sizes in the range of gas limits expected in the medium term.</p> <p>As with both gossip and req/rsp maximum values, type-specific limits should always by simultaneously respected.</p>"},{"location":"specs/bellatrix/p2p-interface/#why-allow-invalid-payloads-on-the-p2p-network","title":"Why allow invalid payloads on the P2P network?","text":"<p>The specification allows blocks with invalid execution payloads to propagate across gossip and via RPC calls. The reasoning for this is as follows:</p> <ol> <li>Optimistic nodes must listen to block gossip to obtain a view of the head of    the chain.</li> <li>Therefore, optimistic nodes must propagate gossip blocks. Otherwise, they'd    be censoring.</li> <li>If optimistic nodes will propagate blocks via gossip, then they must respond    to requests for the parent via RPC.</li> <li>Therefore, optimistic nodes must send optimistic blocks via RPC.</li> </ol> <p>So, to prevent network segregation from optimistic nodes inadvertently sending invalid execution payloads, nodes should never downscore/disconnect nodes due to such invalid payloads. This does open the network to some DoS attacks from invalid execution payloads, but the scope of actors is limited to validators who can put those payloads in valid (and slashable) beacon blocks. Therefore, it is argued that the DoS risk introduced in tolerable.</p> <p>More complicated schemes are possible that could restrict invalid payloads from RPC. However, it's not clear that complexity is warranted.</p>"},{"location":"specs/bellatrix/validator/","title":"Bellatrix -- Honest Validator","text":""},{"location":"specs/bellatrix/validator/#table-of-contents","title":"Table of contents","text":"<ul> <li>Introduction</li> <li>Prerequisites</li> <li>Helpers</li> <li><code>GetPayloadResponse</code></li> <li><code>get_pow_block_at_terminal_total_difficulty</code></li> <li><code>get_terminal_pow_block</code></li> <li>Protocols</li> <li><code>ExecutionEngine</code><ul> <li><code>get_payload</code></li> </ul> </li> <li>Beacon chain responsibilities</li> <li>Block proposal<ul> <li>Constructing the <code>BeaconBlockBody</code></li> <li>ExecutionPayload</li> </ul> </li> </ul>"},{"location":"specs/bellatrix/validator/#introduction","title":"Introduction","text":"<p>This document represents the changes to be made in the code of an \"honest validator\" to implement executable beacon chain proposal.</p>"},{"location":"specs/bellatrix/validator/#prerequisites","title":"Prerequisites","text":"<p>This document is an extension of the Altair -- Honest Validator guide. All behaviors and definitions defined in this document, and documents it extends, carry over unless explicitly noted or overridden.</p> <p>All terminology, constants, functions, and protocol mechanics defined in the updated Beacon Chain doc of Bellatrix are requisite for this document and used throughout. Please see related Beacon Chain doc before continuing and use them as a reference throughout.</p>"},{"location":"specs/bellatrix/validator/#helpers","title":"Helpers","text":""},{"location":"specs/bellatrix/validator/#getpayloadresponse","title":"<code>GetPayloadResponse</code>","text":"<pre><code>@dataclass\nclass GetPayloadResponse(object):\nexecution_payload: ExecutionPayload\n</code></pre>"},{"location":"specs/bellatrix/validator/#get_pow_block_at_terminal_total_difficulty","title":"<code>get_pow_block_at_terminal_total_difficulty</code>","text":"<pre><code>def get_pow_block_at_terminal_total_difficulty(pow_chain: Dict[Hash32, PowBlock]) -&gt; Optional[PowBlock]:\n# `pow_chain` abstractly represents all blocks in the PoW chain\nfor block in pow_chain.values():\nblock_reached_ttd = block.total_difficulty &gt;= TERMINAL_TOTAL_DIFFICULTY\nif block_reached_ttd:\n# If genesis block, no parent exists so reaching TTD alone qualifies as valid terminal block\nif block.parent_hash == Hash32():\nreturn block\nparent = pow_chain[block.parent_hash]\nparent_reached_ttd = parent.total_difficulty &gt;= TERMINAL_TOTAL_DIFFICULTY\nif not parent_reached_ttd:\nreturn block\nreturn None\n</code></pre>"},{"location":"specs/bellatrix/validator/#get_terminal_pow_block","title":"<code>get_terminal_pow_block</code>","text":"<pre><code>def get_terminal_pow_block(pow_chain: Dict[Hash32, PowBlock]) -&gt; Optional[PowBlock]:\nif TERMINAL_BLOCK_HASH != Hash32():\n# Terminal block hash override takes precedence over terminal total difficulty\nif TERMINAL_BLOCK_HASH in pow_chain:\nreturn pow_chain[TERMINAL_BLOCK_HASH]\nelse:\nreturn None\nreturn get_pow_block_at_terminal_total_difficulty(pow_chain)\n</code></pre> <p>Note: This function does not use simple serialize <code>hash_tree_root</code> as to avoid requiring simple serialize hashing capabilities in the Execution Layer.</p>"},{"location":"specs/bellatrix/validator/#protocols","title":"Protocols","text":""},{"location":"specs/bellatrix/validator/#executionengine","title":"<code>ExecutionEngine</code>","text":"<p>Note: <code>get_payload</code> function is added to the <code>ExecutionEngine</code> protocol for use as a validator.</p> <p>The body of this function is implementation dependent. The Engine API may be used to implement it with an external execution engine.</p>"},{"location":"specs/bellatrix/validator/#get_payload","title":"<code>get_payload</code>","text":"<p>Given the <code>payload_id</code>, <code>get_payload</code> returns <code>GetPayloadResponse</code> with the most recent version of the execution payload that has been built since the corresponding call to <code>notify_forkchoice_updated</code> method.</p> <pre><code>def get_payload(self: ExecutionEngine, payload_id: PayloadId) -&gt; GetPayloadResponse:\n\"\"\"\n    Return ``GetPayloadResponse`` object.\n    \"\"\"\n...\n</code></pre>"},{"location":"specs/bellatrix/validator/#beacon-chain-responsibilities","title":"Beacon chain responsibilities","text":"<p>All validator responsibilities remain unchanged other than those noted below. Namely, the transition block handling and the addition of <code>ExecutionPayload</code>.</p> <p>Note: A validator must not propose on or attest to a block that isn't deemed valid, i.e. hasn't yet passed the beacon chain state transition and execution validations. In future upgrades, an \"execution Proof-of-Custody\" will be integrated to prevent outsourcing of execution payload validations.</p>"},{"location":"specs/bellatrix/validator/#block-proposal","title":"Block proposal","text":""},{"location":"specs/bellatrix/validator/#constructing-the-beaconblockbody","title":"Constructing the <code>BeaconBlockBody</code>","text":""},{"location":"specs/bellatrix/validator/#executionpayload","title":"ExecutionPayload","text":"<p>To obtain an execution payload, a block proposer building a block on top of a <code>state</code> must take the following actions:</p> <ol> <li>Set <code>payload_id = prepare_execution_payload(state, pow_chain, safe_block_hash, finalized_block_hash, suggested_fee_recipient, execution_engine)</code>, where:<ul> <li><code>state</code> is the state object after applying <code>process_slots(state, slot)</code> transition to the resulting state of the parent block processing</li> <li><code>pow_chain</code> is a <code>Dict[Hash32, PowBlock]</code> dictionary that abstractly represents all blocks in the PoW chain with block hash as the dictionary key</li> <li><code>safe_block_hash</code> is the return value of the <code>get_safe_execution_payload_hash(store: Store)</code> function call</li> <li><code>finalized_block_hash</code> is the hash of the latest finalized execution payload (<code>Hash32()</code> if none yet finalized)</li> <li><code>suggested_fee_recipient</code> is the value suggested to be used for the <code>fee_recipient</code> field of the execution payload</li> </ul> </li> </ol> <pre><code>def prepare_execution_payload(state: BeaconState,\nsafe_block_hash: Hash32,\nfinalized_block_hash: Hash32,\nsuggested_fee_recipient: ExecutionAddress,\nexecution_engine: ExecutionEngine,\npow_chain: Optional[Dict[Hash32, PowBlock]]=None) -&gt; Optional[PayloadId]:\nif not is_merge_transition_complete(state):\nassert pow_chain is not None\nis_terminal_block_hash_set = TERMINAL_BLOCK_HASH != Hash32()\nis_activation_epoch_reached = get_current_epoch(state) &gt;= TERMINAL_BLOCK_HASH_ACTIVATION_EPOCH\nif is_terminal_block_hash_set and not is_activation_epoch_reached:\n# Terminal block hash is set but activation epoch is not yet reached, no prepare payload call is needed\nreturn None\nterminal_pow_block = get_terminal_pow_block(pow_chain)\nif terminal_pow_block is None:\n# Pre-merge, no prepare payload call is needed\nreturn None\n# Signify merge via producing on top of the terminal PoW block\nparent_hash = terminal_pow_block.block_hash\nelse:\n# Post-merge, normal payload\nparent_hash = state.latest_execution_payload_header.block_hash\n# Set the forkchoice head and initiate the payload build process\npayload_attributes = PayloadAttributes(\ntimestamp=compute_timestamp_at_slot(state, state.slot),\nprev_randao=get_randao_mix(state, get_current_epoch(state)),\nsuggested_fee_recipient=suggested_fee_recipient,\n)\nreturn execution_engine.notify_forkchoice_updated(\nhead_block_hash=parent_hash,\nsafe_block_hash=safe_block_hash,\nfinalized_block_hash=finalized_block_hash,\npayload_attributes=payload_attributes,\n)\n</code></pre> <ol> <li>Set <code>block.body.execution_payload = get_execution_payload(payload_id, execution_engine)</code>, where:</li> </ol> <pre><code>def get_execution_payload(payload_id: Optional[PayloadId], execution_engine: ExecutionEngine) -&gt; ExecutionPayload:\nif payload_id is None:\n# Pre-merge, empty payload\nreturn ExecutionPayload()\nelse:\nreturn execution_engine.get_payload(payload_id).execution_payload\n</code></pre> <p>Note: It is recommended for a validator to call <code>prepare_execution_payload</code> as soon as input parameters become known, and make subsequent calls to this function when any of these parameters gets updated.</p>"},{"location":"specs/capella/beacon-chain/","title":"Capella -- The Beacon Chain","text":""},{"location":"specs/capella/beacon-chain/#table-of-contents","title":"Table of contents","text":"<ul> <li>Introduction</li> <li>Custom types</li> <li>Domain types</li> <li>Preset</li> <li>Max operations per block</li> <li>Execution</li> <li>Withdrawals processing</li> <li>Containers</li> <li>New containers<ul> <li><code>Withdrawal</code></li> <li><code>BLSToExecutionChange</code></li> <li><code>SignedBLSToExecutionChange</code></li> <li><code>HistoricalSummary</code></li> </ul> </li> <li>Extended Containers<ul> <li><code>ExecutionPayload</code></li> <li><code>ExecutionPayloadHeader</code></li> <li><code>BeaconBlockBody</code></li> <li><code>BeaconState</code></li> </ul> </li> <li>Helpers</li> <li>Predicates<ul> <li><code>has_eth1_withdrawal_credential</code></li> <li><code>is_fully_withdrawable_validator</code></li> <li><code>is_partially_withdrawable_validator</code></li> </ul> </li> <li>Beacon chain state transition function</li> <li>Epoch processing<ul> <li>Historical summaries updates</li> </ul> </li> <li>Block processing<ul> <li>New <code>get_expected_withdrawals</code></li> <li>New <code>process_withdrawals</code></li> <li>Modified <code>process_execution_payload</code></li> <li>Modified <code>process_operations</code></li> <li>New <code>process_bls_to_execution_change</code></li> </ul> </li> <li>Testing</li> </ul>"},{"location":"specs/capella/beacon-chain/#introduction","title":"Introduction","text":"<p>Capella is a consensus-layer upgrade containing a number of features related to validator withdrawals. Including: * Automatic withdrawals of <code>withdrawable</code> validators. * Partial withdrawals sweep for validators with 0x01 withdrawal   credentials and balances in excess of <code>MAX_EFFECTIVE_BALANCE</code>. * Operation to change from <code>BLS_WITHDRAWAL_PREFIX</code> to   <code>ETH1_ADDRESS_WITHDRAWAL_PREFIX</code> versioned withdrawal credentials to enable withdrawals for a validator.</p> <p>Another new feature is the new independent state and block historical accumulators that replace the original singular historical roots. With these accumulators, it becomes possible to validate the entire block history that led up to that particular state without any additional information beyond the state and the blocks.</p>"},{"location":"specs/capella/beacon-chain/#custom-types","title":"Custom types","text":"<p>We define the following Python custom types for type hinting and readability:</p> Name SSZ equivalent Description <code>WithdrawalIndex</code> <code>uint64</code> an index of a <code>Withdrawal</code>"},{"location":"specs/capella/beacon-chain/#domain-types","title":"Domain types","text":"Name Value <code>DOMAIN_BLS_TO_EXECUTION_CHANGE</code> <code>DomainType('0x0A000000')</code>"},{"location":"specs/capella/beacon-chain/#preset","title":"Preset","text":""},{"location":"specs/capella/beacon-chain/#max-operations-per-block","title":"Max operations per block","text":"Name Value <code>MAX_BLS_TO_EXECUTION_CHANGES</code> <code>2**4</code> (= 16)"},{"location":"specs/capella/beacon-chain/#execution","title":"Execution","text":"Name Value Description <code>MAX_WITHDRAWALS_PER_PAYLOAD</code> <code>uint64(2**4)</code> (= 16) Maximum amount of withdrawals allowed in each payload"},{"location":"specs/capella/beacon-chain/#withdrawals-processing","title":"Withdrawals processing","text":"Name Value <code>MAX_VALIDATORS_PER_WITHDRAWALS_SWEEP</code> <code>16384</code> (= 2**14 )"},{"location":"specs/capella/beacon-chain/#containers","title":"Containers","text":""},{"location":"specs/capella/beacon-chain/#new-containers","title":"New containers","text":""},{"location":"specs/capella/beacon-chain/#withdrawal","title":"<code>Withdrawal</code>","text":"<pre><code>class Withdrawal(Container):\nindex: WithdrawalIndex\nvalidator_index: ValidatorIndex\naddress: ExecutionAddress\namount: Gwei\n</code></pre>"},{"location":"specs/capella/beacon-chain/#blstoexecutionchange","title":"<code>BLSToExecutionChange</code>","text":"<pre><code>class BLSToExecutionChange(Container):\nvalidator_index: ValidatorIndex\nfrom_bls_pubkey: BLSPubkey\nto_execution_address: ExecutionAddress\n</code></pre>"},{"location":"specs/capella/beacon-chain/#signedblstoexecutionchange","title":"<code>SignedBLSToExecutionChange</code>","text":"<pre><code>class SignedBLSToExecutionChange(Container):\nmessage: BLSToExecutionChange\nsignature: BLSSignature\n</code></pre>"},{"location":"specs/capella/beacon-chain/#historicalsummary","title":"<code>HistoricalSummary</code>","text":"<pre><code>class HistoricalSummary(Container):\n\"\"\"\n    `HistoricalSummary` matches the components of the phase0 `HistoricalBatch`\n    making the two hash_tree_root-compatible.\n    \"\"\"\nblock_summary_root: Root\nstate_summary_root: Root\n</code></pre>"},{"location":"specs/capella/beacon-chain/#extended-containers","title":"Extended Containers","text":""},{"location":"specs/capella/beacon-chain/#executionpayload","title":"<code>ExecutionPayload</code>","text":"<pre><code>class ExecutionPayload(Container):\n# Execution block header fields\nparent_hash: Hash32\nfee_recipient: ExecutionAddress  # 'beneficiary' in the yellow paper\nstate_root: Bytes32\nreceipts_root: Bytes32\nlogs_bloom: ByteVector[BYTES_PER_LOGS_BLOOM]\nprev_randao: Bytes32  # 'difficulty' in the yellow paper\nblock_number: uint64  # 'number' in the yellow paper\ngas_limit: uint64\ngas_used: uint64\ntimestamp: uint64\nextra_data: ByteList[MAX_EXTRA_DATA_BYTES]\nbase_fee_per_gas: uint256\n# Extra payload fields\nblock_hash: Hash32  # Hash of execution block\ntransactions: List[Transaction, MAX_TRANSACTIONS_PER_PAYLOAD]\nwithdrawals: List[Withdrawal, MAX_WITHDRAWALS_PER_PAYLOAD]  # [New in Capella]\n</code></pre>"},{"location":"specs/capella/beacon-chain/#executionpayloadheader","title":"<code>ExecutionPayloadHeader</code>","text":"<pre><code>class ExecutionPayloadHeader(Container):\n# Execution block header fields\nparent_hash: Hash32\nfee_recipient: ExecutionAddress\nstate_root: Bytes32\nreceipts_root: Bytes32\nlogs_bloom: ByteVector[BYTES_PER_LOGS_BLOOM]\nprev_randao: Bytes32\nblock_number: uint64\ngas_limit: uint64\ngas_used: uint64\ntimestamp: uint64\nextra_data: ByteList[MAX_EXTRA_DATA_BYTES]\nbase_fee_per_gas: uint256\n# Extra payload fields\nblock_hash: Hash32  # Hash of execution block\ntransactions_root: Root\nwithdrawals_root: Root  # [New in Capella]\n</code></pre>"},{"location":"specs/capella/beacon-chain/#beaconblockbody","title":"<code>BeaconBlockBody</code>","text":"<pre><code>class BeaconBlockBody(Container):\nrandao_reveal: BLSSignature\neth1_data: Eth1Data  # Eth1 data vote\ngraffiti: Bytes32  # Arbitrary data\n# Operations\nproposer_slashings: List[ProposerSlashing, MAX_PROPOSER_SLASHINGS]\nattester_slashings: List[AttesterSlashing, MAX_ATTESTER_SLASHINGS]\nattestations: List[Attestation, MAX_ATTESTATIONS]\ndeposits: List[Deposit, MAX_DEPOSITS]\nvoluntary_exits: List[SignedVoluntaryExit, MAX_VOLUNTARY_EXITS]\nsync_aggregate: SyncAggregate\n# Execution\nexecution_payload: ExecutionPayload\n# Capella operations\nbls_to_execution_changes: List[SignedBLSToExecutionChange, MAX_BLS_TO_EXECUTION_CHANGES]  # [New in Capella]\n</code></pre>"},{"location":"specs/capella/beacon-chain/#beaconstate","title":"<code>BeaconState</code>","text":"<pre><code>class BeaconState(Container):\n# Versioning\ngenesis_time: uint64\ngenesis_validators_root: Root\nslot: Slot\nfork: Fork\n# History\nlatest_block_header: BeaconBlockHeader\nblock_roots: Vector[Root, SLOTS_PER_HISTORICAL_ROOT]\nstate_roots: Vector[Root, SLOTS_PER_HISTORICAL_ROOT]\nhistorical_roots: List[Root, HISTORICAL_ROOTS_LIMIT]  # Frozen in Capella, replaced by historical_summaries\n# Eth1\neth1_data: Eth1Data\neth1_data_votes: List[Eth1Data, EPOCHS_PER_ETH1_VOTING_PERIOD * SLOTS_PER_EPOCH]\neth1_deposit_index: uint64\n# Registry\nvalidators: List[Validator, VALIDATOR_REGISTRY_LIMIT]\nbalances: List[Gwei, VALIDATOR_REGISTRY_LIMIT]\n# Randomness\nrandao_mixes: Vector[Bytes32, EPOCHS_PER_HISTORICAL_VECTOR]\n# Slashings\nslashings: Vector[Gwei, EPOCHS_PER_SLASHINGS_VECTOR]  # Per-epoch sums of slashed effective balances\n# Participation\nprevious_epoch_participation: List[ParticipationFlags, VALIDATOR_REGISTRY_LIMIT]\ncurrent_epoch_participation: List[ParticipationFlags, VALIDATOR_REGISTRY_LIMIT]\n# Finality\njustification_bits: Bitvector[JUSTIFICATION_BITS_LENGTH]  # Bit set for every recent justified epoch\nprevious_justified_checkpoint: Checkpoint\ncurrent_justified_checkpoint: Checkpoint\nfinalized_checkpoint: Checkpoint\n# Inactivity\ninactivity_scores: List[uint64, VALIDATOR_REGISTRY_LIMIT]\n# Sync\ncurrent_sync_committee: SyncCommittee\nnext_sync_committee: SyncCommittee\n# Execution\nlatest_execution_payload_header: ExecutionPayloadHeader  # [Modified in Capella]\n# Withdrawals\nnext_withdrawal_index: WithdrawalIndex  # [New in Capella]\nnext_withdrawal_validator_index: ValidatorIndex  # [New in Capella]\n# Deep history valid from Capella onwards\nhistorical_summaries: List[HistoricalSummary, HISTORICAL_ROOTS_LIMIT]  # [New in Capella]\n</code></pre>"},{"location":"specs/capella/beacon-chain/#helpers","title":"Helpers","text":""},{"location":"specs/capella/beacon-chain/#predicates","title":"Predicates","text":""},{"location":"specs/capella/beacon-chain/#has_eth1_withdrawal_credential","title":"<code>has_eth1_withdrawal_credential</code>","text":"<pre><code>def has_eth1_withdrawal_credential(validator: Validator) -&gt; bool:\n\"\"\"\n    Check if ``validator`` has an 0x01 prefixed \"eth1\" withdrawal credential.\n    \"\"\"\nreturn validator.withdrawal_credentials[:1] == ETH1_ADDRESS_WITHDRAWAL_PREFIX\n</code></pre>"},{"location":"specs/capella/beacon-chain/#is_fully_withdrawable_validator","title":"<code>is_fully_withdrawable_validator</code>","text":"<pre><code>def is_fully_withdrawable_validator(validator: Validator, balance: Gwei, epoch: Epoch) -&gt; bool:\n\"\"\"\n    Check if ``validator`` is fully withdrawable.\n    \"\"\"\nreturn (\nhas_eth1_withdrawal_credential(validator)\nand validator.withdrawable_epoch &lt;= epoch\nand balance &gt; 0\n)\n</code></pre>"},{"location":"specs/capella/beacon-chain/#is_partially_withdrawable_validator","title":"<code>is_partially_withdrawable_validator</code>","text":"<pre><code>def is_partially_withdrawable_validator(validator: Validator, balance: Gwei) -&gt; bool:\n\"\"\"\n    Check if ``validator`` is partially withdrawable.\n    \"\"\"\nhas_max_effective_balance = validator.effective_balance == MAX_EFFECTIVE_BALANCE\nhas_excess_balance = balance &gt; MAX_EFFECTIVE_BALANCE\nreturn has_eth1_withdrawal_credential(validator) and has_max_effective_balance and has_excess_balance\n</code></pre>"},{"location":"specs/capella/beacon-chain/#beacon-chain-state-transition-function","title":"Beacon chain state transition function","text":""},{"location":"specs/capella/beacon-chain/#epoch-processing","title":"Epoch processing","text":"<p>Note: The function <code>process_historical_summaries_update</code> replaces <code>process_historical_roots_update</code> in Capella.</p> <pre><code>def process_epoch(state: BeaconState) -&gt; None:\nprocess_justification_and_finalization(state)\nprocess_inactivity_updates(state)\nprocess_rewards_and_penalties(state)\nprocess_registry_updates(state)\nprocess_slashings(state)\nprocess_eth1_data_reset(state)\nprocess_effective_balance_updates(state)\nprocess_slashings_reset(state)\nprocess_randao_mixes_reset(state)\nprocess_historical_summaries_update(state)  # [Modified in Capella]\nprocess_participation_flag_updates(state)\nprocess_sync_committee_updates(state)\n</code></pre>"},{"location":"specs/capella/beacon-chain/#historical-summaries-updates","title":"Historical summaries updates","text":"<pre><code>def process_historical_summaries_update(state: BeaconState) -&gt; None:\n# Set historical block root accumulator.\nnext_epoch = Epoch(get_current_epoch(state) + 1)\nif next_epoch % (SLOTS_PER_HISTORICAL_ROOT // SLOTS_PER_EPOCH) == 0:\nhistorical_summary = HistoricalSummary(\nblock_summary_root=hash_tree_root(state.block_roots),\nstate_summary_root=hash_tree_root(state.state_roots),\n)\nstate.historical_summaries.append(historical_summary)\n</code></pre>"},{"location":"specs/capella/beacon-chain/#block-processing","title":"Block processing","text":"<pre><code>def process_block(state: BeaconState, block: BeaconBlock) -&gt; None:\nprocess_block_header(state, block)\n# [Modified in Capella] Removed `is_execution_enabled` check in Capella\nprocess_withdrawals(state, block.body.execution_payload)  # [New in Capella]\nprocess_execution_payload(state, block.body, EXECUTION_ENGINE)  # [Modified in Capella]\nprocess_randao(state, block.body)\nprocess_eth1_data(state, block.body)\nprocess_operations(state, block.body)  # [Modified in Capella]\nprocess_sync_aggregate(state, block.body.sync_aggregate)\n</code></pre>"},{"location":"specs/capella/beacon-chain/#new-get_expected_withdrawals","title":"New <code>get_expected_withdrawals</code>","text":"<pre><code>def get_expected_withdrawals(state: BeaconState) -&gt; Sequence[Withdrawal]:\nepoch = get_current_epoch(state)\nwithdrawal_index = state.next_withdrawal_index\nvalidator_index = state.next_withdrawal_validator_index\nwithdrawals: List[Withdrawal] = []\nbound = min(len(state.validators), MAX_VALIDATORS_PER_WITHDRAWALS_SWEEP)\nfor _ in range(bound):\nvalidator = state.validators[validator_index]\nbalance = state.balances[validator_index]\nif is_fully_withdrawable_validator(validator, balance, epoch):\nwithdrawals.append(Withdrawal(\nindex=withdrawal_index,\nvalidator_index=validator_index,\naddress=ExecutionAddress(validator.withdrawal_credentials[12:]),\namount=balance,\n))\nwithdrawal_index += WithdrawalIndex(1)\nelif is_partially_withdrawable_validator(validator, balance):\nwithdrawals.append(Withdrawal(\nindex=withdrawal_index,\nvalidator_index=validator_index,\naddress=ExecutionAddress(validator.withdrawal_credentials[12:]),\namount=balance - MAX_EFFECTIVE_BALANCE,\n))\nwithdrawal_index += WithdrawalIndex(1)\nif len(withdrawals) == MAX_WITHDRAWALS_PER_PAYLOAD:\nbreak\nvalidator_index = ValidatorIndex((validator_index + 1) % len(state.validators))\nreturn withdrawals\n</code></pre>"},{"location":"specs/capella/beacon-chain/#new-process_withdrawals","title":"New <code>process_withdrawals</code>","text":"<pre><code>def process_withdrawals(state: BeaconState, payload: ExecutionPayload) -&gt; None:\nexpected_withdrawals = get_expected_withdrawals(state)\nassert len(payload.withdrawals) == len(expected_withdrawals)\nfor expected_withdrawal, withdrawal in zip(expected_withdrawals, payload.withdrawals):\nassert withdrawal == expected_withdrawal\ndecrease_balance(state, withdrawal.validator_index, withdrawal.amount)\n# Update the next withdrawal index if this block contained withdrawals\nif len(expected_withdrawals) != 0:\nlatest_withdrawal = expected_withdrawals[-1]\nstate.next_withdrawal_index = WithdrawalIndex(latest_withdrawal.index + 1)\n# Update the next validator index to start the next withdrawal sweep\nif len(expected_withdrawals) == MAX_WITHDRAWALS_PER_PAYLOAD:\n# Next sweep starts after the latest withdrawal's validator index\nnext_validator_index = ValidatorIndex((expected_withdrawals[-1].validator_index + 1) % len(state.validators))\nstate.next_withdrawal_validator_index = next_validator_index\nelse:\n# Advance sweep by the max length of the sweep if there was not a full set of withdrawals\nnext_index = state.next_withdrawal_validator_index + MAX_VALIDATORS_PER_WITHDRAWALS_SWEEP\nnext_validator_index = ValidatorIndex(next_index % len(state.validators))\nstate.next_withdrawal_validator_index = next_validator_index\n</code></pre>"},{"location":"specs/capella/beacon-chain/#modified-process_execution_payload","title":"Modified <code>process_execution_payload</code>","text":"<p>Note: The function <code>process_execution_payload</code> is modified to use the new <code>ExecutionPayloadHeader</code> type and removed the <code>is_merge_transition_complete</code> check.</p> <pre><code>def process_execution_payload(state: BeaconState, body: BeaconBlockBody, execution_engine: ExecutionEngine) -&gt; None:\npayload = body.execution_payload\n# [Modified in Capella] Removed `is_merge_transition_complete` check in Capella\n# Verify consistency of the parent hash with respect to the previous execution payload header\nassert payload.parent_hash == state.latest_execution_payload_header.block_hash\n# Verify prev_randao\nassert payload.prev_randao == get_randao_mix(state, get_current_epoch(state))\n# Verify timestamp\nassert payload.timestamp == compute_timestamp_at_slot(state, state.slot)\n# Verify the execution payload is valid\nassert execution_engine.verify_and_notify_new_payload(NewPayloadRequest(execution_payload=payload))\n# Cache execution payload header\nstate.latest_execution_payload_header = ExecutionPayloadHeader(\nparent_hash=payload.parent_hash,\nfee_recipient=payload.fee_recipient,\nstate_root=payload.state_root,\nreceipts_root=payload.receipts_root,\nlogs_bloom=payload.logs_bloom,\nprev_randao=payload.prev_randao,\nblock_number=payload.block_number,\ngas_limit=payload.gas_limit,\ngas_used=payload.gas_used,\ntimestamp=payload.timestamp,\nextra_data=payload.extra_data,\nbase_fee_per_gas=payload.base_fee_per_gas,\nblock_hash=payload.block_hash,\ntransactions_root=hash_tree_root(payload.transactions),\nwithdrawals_root=hash_tree_root(payload.withdrawals),  # [New in Capella]\n)\n</code></pre>"},{"location":"specs/capella/beacon-chain/#modified-process_operations","title":"Modified <code>process_operations</code>","text":"<p>Note: The function <code>process_operations</code> is modified to process <code>BLSToExecutionChange</code> operations included in the block.</p> <pre><code>def process_operations(state: BeaconState, body: BeaconBlockBody) -&gt; None:\n# Verify that outstanding deposits are processed up to the maximum number of deposits\nassert len(body.deposits) == min(MAX_DEPOSITS, state.eth1_data.deposit_count - state.eth1_deposit_index)\ndef for_ops(operations: Sequence[Any], fn: Callable[[BeaconState, Any], None]) -&gt; None:\nfor operation in operations:\nfn(state, operation)\nfor_ops(body.proposer_slashings, process_proposer_slashing)\nfor_ops(body.attester_slashings, process_attester_slashing)\nfor_ops(body.attestations, process_attestation)\nfor_ops(body.deposits, process_deposit)\nfor_ops(body.voluntary_exits, process_voluntary_exit)\nfor_ops(body.bls_to_execution_changes, process_bls_to_execution_change)  # [New in Capella]\n</code></pre>"},{"location":"specs/capella/beacon-chain/#new-process_bls_to_execution_change","title":"New <code>process_bls_to_execution_change</code>","text":"<pre><code>def process_bls_to_execution_change(state: BeaconState,\nsigned_address_change: SignedBLSToExecutionChange) -&gt; None:\naddress_change = signed_address_change.message\nassert address_change.validator_index &lt; len(state.validators)\nvalidator = state.validators[address_change.validator_index]\nassert validator.withdrawal_credentials[:1] == BLS_WITHDRAWAL_PREFIX\nassert validator.withdrawal_credentials[1:] == hash(address_change.from_bls_pubkey)[1:]\n# Fork-agnostic domain since address changes are valid across forks\ndomain = compute_domain(DOMAIN_BLS_TO_EXECUTION_CHANGE, genesis_validators_root=state.genesis_validators_root)\nsigning_root = compute_signing_root(address_change, domain)\nassert bls.Verify(address_change.from_bls_pubkey, signing_root, signed_address_change.signature)\nvalidator.withdrawal_credentials = (\nETH1_ADDRESS_WITHDRAWAL_PREFIX\n+ b'\\x00' * 11\n+ address_change.to_execution_address\n)\n</code></pre>"},{"location":"specs/capella/beacon-chain/#testing","title":"Testing","text":"<p>Note: The function <code>initialize_beacon_state_from_eth1</code> is modified for pure Capella testing only. Modifications include: 1. Use <code>CAPELLA_FORK_VERSION</code> as the previous and current fork version. 2. Utilize the Capella <code>BeaconBlockBody</code> when constructing the initial <code>latest_block_header</code>.</p> <pre><code>def initialize_beacon_state_from_eth1(eth1_block_hash: Hash32,\neth1_timestamp: uint64,\ndeposits: Sequence[Deposit],\nexecution_payload_header: ExecutionPayloadHeader=ExecutionPayloadHeader()\n) -&gt; BeaconState:\nfork = Fork(\nprevious_version=CAPELLA_FORK_VERSION,  # [Modified in Capella] for testing only\ncurrent_version=CAPELLA_FORK_VERSION,  # [Modified in Capella]\nepoch=GENESIS_EPOCH,\n)\nstate = BeaconState(\ngenesis_time=eth1_timestamp + GENESIS_DELAY,\nfork=fork,\neth1_data=Eth1Data(block_hash=eth1_block_hash, deposit_count=uint64(len(deposits))),\nlatest_block_header=BeaconBlockHeader(body_root=hash_tree_root(BeaconBlockBody())),\nrandao_mixes=[eth1_block_hash] * EPOCHS_PER_HISTORICAL_VECTOR,  # Seed RANDAO with Eth1 entropy\n)\n# Process deposits\nleaves = list(map(lambda deposit: deposit.data, deposits))\nfor index, deposit in enumerate(deposits):\ndeposit_data_list = List[DepositData, 2**DEPOSIT_CONTRACT_TREE_DEPTH](*leaves[:index + 1])\nstate.eth1_data.deposit_root = hash_tree_root(deposit_data_list)\nprocess_deposit(state, deposit)\n# Process activations\nfor index, validator in enumerate(state.validators):\nbalance = state.balances[index]\nvalidator.effective_balance = min(balance - balance % EFFECTIVE_BALANCE_INCREMENT, MAX_EFFECTIVE_BALANCE)\nif validator.effective_balance == MAX_EFFECTIVE_BALANCE:\nvalidator.activation_eligibility_epoch = GENESIS_EPOCH\nvalidator.activation_epoch = GENESIS_EPOCH\n# Set genesis validators root for domain separation and chain versioning\nstate.genesis_validators_root = hash_tree_root(state.validators)\n# Fill in sync committees\n# Note: A duplicate committee is assigned for the current and next committee at genesis\nstate.current_sync_committee = get_next_sync_committee(state)\nstate.next_sync_committee = get_next_sync_committee(state)\n# Initialize the execution payload header\nstate.latest_execution_payload_header = execution_payload_header\nreturn state\n</code></pre>"},{"location":"specs/capella/fork-choice/","title":"Capella -- Fork Choice","text":""},{"location":"specs/capella/fork-choice/#table-of-contents","title":"Table of contents","text":"<ul> <li>Introduction</li> <li>Custom types</li> <li>Protocols</li> <li><code>ExecutionEngine</code><ul> <li><code>notify_forkchoice_updated</code></li> </ul> </li> <li>Helpers</li> <li>Extended <code>PayloadAttributes</code></li> <li>Updated fork-choice handlers</li> <li><code>on_block</code></li> </ul>"},{"location":"specs/capella/fork-choice/#introduction","title":"Introduction","text":"<p>This is the modification of the fork choice according to the Capella upgrade.</p> <p>Unless stated explicitly, all prior functionality from Bellatrix is inherited.</p>"},{"location":"specs/capella/fork-choice/#custom-types","title":"Custom types","text":""},{"location":"specs/capella/fork-choice/#protocols","title":"Protocols","text":""},{"location":"specs/capella/fork-choice/#executionengine","title":"<code>ExecutionEngine</code>","text":"<p>Note: The <code>notify_forkchoice_updated</code> function is modified in the <code>ExecutionEngine</code> protocol at the Capella upgrade.</p>"},{"location":"specs/capella/fork-choice/#notify_forkchoice_updated","title":"<code>notify_forkchoice_updated</code>","text":"<p>The only change made is to the <code>PayloadAttributes</code> container through the addition of <code>withdrawals</code>. Otherwise, <code>notify_forkchoice_updated</code> inherits all prior functionality.</p> <pre><code>def notify_forkchoice_updated(self: ExecutionEngine,\nhead_block_hash: Hash32,\nsafe_block_hash: Hash32,\nfinalized_block_hash: Hash32,\npayload_attributes: Optional[PayloadAttributes]) -&gt; Optional[PayloadId]:\n...\n</code></pre>"},{"location":"specs/capella/fork-choice/#helpers","title":"Helpers","text":""},{"location":"specs/capella/fork-choice/#extended-payloadattributes","title":"Extended <code>PayloadAttributes</code>","text":"<p><code>PayloadAttributes</code> is extended with the <code>withdrawals</code> field.</p> <pre><code>@dataclass\nclass PayloadAttributes(object):\ntimestamp: uint64\nprev_randao: Bytes32\nsuggested_fee_recipient: ExecutionAddress\nwithdrawals: Sequence[Withdrawal]  # [New in Capella]\n</code></pre>"},{"location":"specs/capella/fork-choice/#updated-fork-choice-handlers","title":"Updated fork-choice handlers","text":""},{"location":"specs/capella/fork-choice/#on_block","title":"<code>on_block</code>","text":"<p>Note: The only modification is the deletion of the verification of merge transition block conditions.</p> <pre><code>def on_block(store: Store, signed_block: SignedBeaconBlock) -&gt; None:\n\"\"\"\n    Run ``on_block`` upon receiving a new block.\n    \"\"\"\nblock = signed_block.message\n# Parent block must be known\nassert block.parent_root in store.block_states\n# Make a copy of the state to avoid mutability issues\npre_state = copy(store.block_states[block.parent_root])\n# Blocks cannot be in the future. If they are, their consideration must be delayed until they are in the past.\nassert get_current_slot(store) &gt;= block.slot\n# Check that block is later than the finalized epoch slot (optimization to reduce calls to get_ancestor)\nfinalized_slot = compute_start_slot_at_epoch(store.finalized_checkpoint.epoch)\nassert block.slot &gt; finalized_slot\n# Check block is a descendant of the finalized block at the checkpoint finalized slot\nfinalized_checkpoint_block = get_checkpoint_block(\nstore,\nblock.parent_root,\nstore.finalized_checkpoint.epoch,\n)\nassert store.finalized_checkpoint.root == finalized_checkpoint_block\n# Check the block is valid and compute the post-state\nstate = pre_state.copy()\nblock_root = hash_tree_root(block)\nstate_transition(state, signed_block, True)\n# Add new block to the store\nstore.blocks[block_root] = block\n# Add new state for this block to the store\nstore.block_states[block_root] = state\n# Add block timeliness to the store\ntime_into_slot = (store.time - store.genesis_time) % SECONDS_PER_SLOT\nis_before_attesting_interval = time_into_slot &lt; SECONDS_PER_SLOT // INTERVALS_PER_SLOT\nis_timely = get_current_slot(store) == block.slot and is_before_attesting_interval\nstore.block_timeliness[hash_tree_root(block)] = is_timely\n# Add proposer score boost if the block is timely and not conflicting with an existing block\nis_first_block = store.proposer_boost_root == Root()\nif is_timely and is_first_block:\nstore.proposer_boost_root = hash_tree_root(block)\n# Update checkpoints in store if necessary\nupdate_checkpoints(store, state.current_justified_checkpoint, state.finalized_checkpoint)\n# Eagerly compute unrealized justification and finality.\ncompute_pulled_up_tip(store, block_root)\n</code></pre>"},{"location":"specs/capella/fork/","title":"Capella -- Fork Logic","text":""},{"location":"specs/capella/fork/#table-of-contents","title":"Table of contents","text":"<ul> <li>Introduction</li> <li>Configuration</li> <li>Helper functions</li> <li>Misc<ul> <li>Modified <code>compute_fork_version</code></li> </ul> </li> <li>Fork to Capella</li> <li>Fork trigger</li> <li>Upgrading the state</li> </ul>"},{"location":"specs/capella/fork/#introduction","title":"Introduction","text":"<p>This document describes the process of the Capella upgrade.</p>"},{"location":"specs/capella/fork/#configuration","title":"Configuration","text":"Name Value <code>CAPELLA_FORK_VERSION</code> <code>Version('0x03000000')</code> <code>CAPELLA_FORK_EPOCH</code> <code>Epoch(194048)</code> (April 12, 2023, 10:27:35pm UTC)"},{"location":"specs/capella/fork/#helper-functions","title":"Helper functions","text":""},{"location":"specs/capella/fork/#misc","title":"Misc","text":""},{"location":"specs/capella/fork/#modified-compute_fork_version","title":"Modified <code>compute_fork_version</code>","text":"<pre><code>def compute_fork_version(epoch: Epoch) -&gt; Version:\n\"\"\"\n    Return the fork version at the given ``epoch``.\n    \"\"\"\nif epoch &gt;= CAPELLA_FORK_EPOCH:\nreturn CAPELLA_FORK_VERSION\nif epoch &gt;= BELLATRIX_FORK_EPOCH:\nreturn BELLATRIX_FORK_VERSION\nif epoch &gt;= ALTAIR_FORK_EPOCH:\nreturn ALTAIR_FORK_VERSION\nreturn GENESIS_FORK_VERSION\n</code></pre>"},{"location":"specs/capella/fork/#fork-to-capella","title":"Fork to Capella","text":""},{"location":"specs/capella/fork/#fork-trigger","title":"Fork trigger","text":"<p>The fork is triggered at epoch <code>CAPELLA_FORK_EPOCH</code>.</p> <p>Note that for the pure Capella networks, we don't apply <code>upgrade_to_capella</code> since it starts with Capella version logic.</p>"},{"location":"specs/capella/fork/#upgrading-the-state","title":"Upgrading the state","text":"<p>If <code>state.slot % SLOTS_PER_EPOCH == 0</code> and <code>compute_epoch_at_slot(state.slot) == CAPELLA_FORK_EPOCH</code>, an irregular state change is made to upgrade to Capella.</p> <p>The upgrade occurs after the completion of the inner loop of <code>process_slots</code> that sets <code>state.slot</code> equal to <code>CAPELLA_FORK_EPOCH * SLOTS_PER_EPOCH</code>. Care must be taken when transitioning through the fork boundary as implementations will need a modified state transition function that deviates from the Phase 0 document. In particular, the outer <code>state_transition</code> function defined in the Phase 0 document will not expose the precise fork slot to execute the upgrade in the presence of skipped slots at the fork boundary. Instead, the logic must be within <code>process_slots</code>.</p> <pre><code>def upgrade_to_capella(pre: bellatrix.BeaconState) -&gt; BeaconState:\nepoch = bellatrix.get_current_epoch(pre)\nlatest_execution_payload_header = ExecutionPayloadHeader(\nparent_hash=pre.latest_execution_payload_header.parent_hash,\nfee_recipient=pre.latest_execution_payload_header.fee_recipient,\nstate_root=pre.latest_execution_payload_header.state_root,\nreceipts_root=pre.latest_execution_payload_header.receipts_root,\nlogs_bloom=pre.latest_execution_payload_header.logs_bloom,\nprev_randao=pre.latest_execution_payload_header.prev_randao,\nblock_number=pre.latest_execution_payload_header.block_number,\ngas_limit=pre.latest_execution_payload_header.gas_limit,\ngas_used=pre.latest_execution_payload_header.gas_used,\ntimestamp=pre.latest_execution_payload_header.timestamp,\nextra_data=pre.latest_execution_payload_header.extra_data,\nbase_fee_per_gas=pre.latest_execution_payload_header.base_fee_per_gas,\nblock_hash=pre.latest_execution_payload_header.block_hash,\ntransactions_root=pre.latest_execution_payload_header.transactions_root,\nwithdrawals_root=Root(),  # [New in Capella]\n)\npost = BeaconState(\n# Versioning\ngenesis_time=pre.genesis_time,\ngenesis_validators_root=pre.genesis_validators_root,\nslot=pre.slot,\nfork=Fork(\nprevious_version=pre.fork.current_version,\ncurrent_version=CAPELLA_FORK_VERSION,\nepoch=epoch,\n),\n# History\nlatest_block_header=pre.latest_block_header,\nblock_roots=pre.block_roots,\nstate_roots=pre.state_roots,\nhistorical_roots=pre.historical_roots,\n# Eth1\neth1_data=pre.eth1_data,\neth1_data_votes=pre.eth1_data_votes,\neth1_deposit_index=pre.eth1_deposit_index,\n# Registry\nvalidators=pre.validators,\nbalances=pre.balances,\n# Randomness\nrandao_mixes=pre.randao_mixes,\n# Slashings\nslashings=pre.slashings,\n# Participation\nprevious_epoch_participation=pre.previous_epoch_participation,\ncurrent_epoch_participation=pre.current_epoch_participation,\n# Finality\njustification_bits=pre.justification_bits,\nprevious_justified_checkpoint=pre.previous_justified_checkpoint,\ncurrent_justified_checkpoint=pre.current_justified_checkpoint,\nfinalized_checkpoint=pre.finalized_checkpoint,\n# Inactivity\ninactivity_scores=pre.inactivity_scores,\n# Sync\ncurrent_sync_committee=pre.current_sync_committee,\nnext_sync_committee=pre.next_sync_committee,\n# Execution-layer\nlatest_execution_payload_header=latest_execution_payload_header,\n# Withdrawals\nnext_withdrawal_index=WithdrawalIndex(0),  # [New in Capella]\nnext_withdrawal_validator_index=ValidatorIndex(0),  # [New in Capella]\n# Deep history valid from Capella onwards\nhistorical_summaries=List[HistoricalSummary, HISTORICAL_ROOTS_LIMIT]([]),  # [New in Capella]\n)\nreturn post\n</code></pre>"},{"location":"specs/capella/p2p-interface/","title":"Capella -- Networking","text":"<p>This document contains the networking specification for Capella.</p> <p>The specification of these changes continues in the same format as the network specifications of previous upgrades, and assumes them as pre-requisite.</p>"},{"location":"specs/capella/p2p-interface/#table-of-contents","title":"Table of contents","text":"<ul> <li>Modifications in Capella</li> <li>The gossip domain: gossipsub<ul> <li>Topics and messages</li> <li>Global topics<ul> <li><code>beacon_block</code></li> <li><code>bls_to_execution_change</code></li> </ul> </li> <li>Transitioning the gossip</li> </ul> </li> <li>The Req/Resp domain<ul> <li>Messages</li> <li>BeaconBlocksByRange v2</li> <li>BeaconBlocksByRoot v2</li> </ul> </li> </ul>"},{"location":"specs/capella/p2p-interface/#modifications-in-capella","title":"Modifications in Capella","text":""},{"location":"specs/capella/p2p-interface/#the-gossip-domain-gossipsub","title":"The gossip domain: gossipsub","text":"<p>A new topic is added to support the gossip of withdrawal credential change messages. And an existing topic is upgraded for updated types in Capella.</p>"},{"location":"specs/capella/p2p-interface/#topics-and-messages","title":"Topics and messages","text":"<p>Topics follow the same specification as in prior upgrades. All existing topics remain stable except the beacon block topic which is updated with the modified type.</p> <p>The new topics along with the type of the <code>data</code> field of a gossipsub message are given in this table:</p> Name Message Type <code>beacon_block</code> <code>SignedBeaconBlock</code> (modified) <code>bls_to_execution_change</code> <code>SignedBLSToExecutionChange</code> <p>Note that the <code>ForkDigestValue</code> path segment of the topic separates the old and the new <code>beacon_block</code> topics.</p>"},{"location":"specs/capella/p2p-interface/#global-topics","title":"Global topics","text":"<p>Capella changes the type of the global beacon block topic and adds one global topic to propagate withdrawal credential change messages to all potential proposers of beacon blocks.</p>"},{"location":"specs/capella/p2p-interface/#beacon_block","title":"<code>beacon_block</code>","text":"<p>The type of the payload of this topic changes to the (modified) <code>SignedBeaconBlock</code> found in Capella. Specifically, this type changes with the addition of <code>bls_to_execution_changes</code> to the inner <code>BeaconBlockBody</code>. See Capella state transition document for further details.</p>"},{"location":"specs/capella/p2p-interface/#bls_to_execution_change","title":"<code>bls_to_execution_change</code>","text":"<p>This topic is used to propagate signed bls to execution change messages to be included in future blocks.</p> <p>The following validations MUST pass before forwarding the <code>signed_bls_to_execution_change</code> on the network:</p> <ul> <li>[IGNORE] <code>current_epoch &gt;= CAPELLA_FORK_EPOCH</code>,   where <code>current_epoch</code> is defined by the current wall-clock time.</li> <li>[IGNORE] The <code>signed_bls_to_execution_change</code> is the first valid signed bls to execution change received   for the validator with index <code>signed_bls_to_execution_change.message.validator_index</code>.</li> <li>[REJECT] All of the conditions within <code>process_bls_to_execution_change</code> pass validation.</li> </ul>"},{"location":"specs/capella/p2p-interface/#transitioning-the-gossip","title":"Transitioning the gossip","text":"<p>See gossip transition details found in the Altair document for details on how to handle transitioning gossip topics for Capella.</p>"},{"location":"specs/capella/p2p-interface/#the-reqresp-domain","title":"The Req/Resp domain","text":""},{"location":"specs/capella/p2p-interface/#messages","title":"Messages","text":""},{"location":"specs/capella/p2p-interface/#beaconblocksbyrange-v2","title":"BeaconBlocksByRange v2","text":"<p>Protocol ID: <code>/eth2/beacon_chain/req/beacon_blocks_by_range/2/</code></p> <p>The Capella fork-digest is introduced to the <code>context</code> enum to specify Capella block type.</p> <p>Per <code>context = compute_fork_digest(fork_version, genesis_validators_root)</code>:</p> <code>fork_version</code> Chunk SSZ type <code>GENESIS_FORK_VERSION</code> <code>phase0.SignedBeaconBlock</code> <code>ALTAIR_FORK_VERSION</code> <code>altair.SignedBeaconBlock</code> <code>BELLATRIX_FORK_VERSION</code> <code>bellatrix.SignedBeaconBlock</code> <code>CAPELLA_FORK_VERSION</code> <code>capella.SignedBeaconBlock</code>"},{"location":"specs/capella/p2p-interface/#beaconblocksbyroot-v2","title":"BeaconBlocksByRoot v2","text":"<p>Protocol ID: <code>/eth2/beacon_chain/req/beacon_blocks_by_root/2/</code></p> <p>The Capella fork-digest is introduced to the <code>context</code> enum to specify Capella block type.</p> <p>Per <code>context = compute_fork_digest(fork_version, genesis_validators_root)</code>:</p> <code>fork_version</code> Chunk SSZ type <code>GENESIS_FORK_VERSION</code> <code>phase0.SignedBeaconBlock</code> <code>ALTAIR_FORK_VERSION</code> <code>altair.SignedBeaconBlock</code> <code>BELLATRIX_FORK_VERSION</code> <code>bellatrix.SignedBeaconBlock</code> <code>CAPELLA_FORK_VERSION</code> <code>capella.SignedBeaconBlock</code>"},{"location":"specs/capella/validator/","title":"Capella -- Honest Validator","text":""},{"location":"specs/capella/validator/#table-of-contents","title":"Table of contents","text":"<ul> <li>Introduction</li> <li>Prerequisites</li> <li>Helpers</li> <li>Modified <code>GetPayloadResponse</code></li> <li>Protocols</li> <li><code>ExecutionEngine</code><ul> <li>Modified <code>get_payload</code></li> </ul> </li> <li>Beacon chain responsibilities</li> <li>Block proposal<ul> <li>Constructing the <code>BeaconBlockBody</code></li> <li>ExecutionPayload</li> <li>BLS to execution changes</li> </ul> </li> <li>Enabling validator withdrawals</li> <li>Changing from BLS to execution withdrawal credentials</li> </ul>"},{"location":"specs/capella/validator/#introduction","title":"Introduction","text":"<p>This document represents the changes to be made in the code of an \"honest validator\" to implement the Capella upgrade.</p>"},{"location":"specs/capella/validator/#prerequisites","title":"Prerequisites","text":"<p>This document is an extension of the Bellatrix -- Honest Validator guide. All behaviors and definitions defined in this document, and documents it extends, carry over unless explicitly noted or overridden.</p> <p>All terminology, constants, functions, and protocol mechanics defined in the updated Beacon Chain doc of Capella are requisite for this document and used throughout. Please see related Beacon Chain doc before continuing and use them as a reference throughout.</p>"},{"location":"specs/capella/validator/#helpers","title":"Helpers","text":""},{"location":"specs/capella/validator/#modified-getpayloadresponse","title":"Modified <code>GetPayloadResponse</code>","text":"<pre><code>@dataclass\nclass GetPayloadResponse(object):\nexecution_payload: ExecutionPayload\nblock_value: uint256\n</code></pre>"},{"location":"specs/capella/validator/#protocols","title":"Protocols","text":""},{"location":"specs/capella/validator/#executionengine","title":"<code>ExecutionEngine</code>","text":""},{"location":"specs/capella/validator/#modified-get_payload","title":"Modified <code>get_payload</code>","text":"<p><code>get_payload</code> returns the upgraded Capella <code>ExecutionPayload</code> type.</p>"},{"location":"specs/capella/validator/#beacon-chain-responsibilities","title":"Beacon chain responsibilities","text":"<p>All validator responsibilities remain unchanged other than those noted below.</p>"},{"location":"specs/capella/validator/#block-proposal","title":"Block proposal","text":""},{"location":"specs/capella/validator/#constructing-the-beaconblockbody","title":"Constructing the <code>BeaconBlockBody</code>","text":""},{"location":"specs/capella/validator/#executionpayload","title":"ExecutionPayload","text":"<p><code>ExecutionPayload</code>s are constructed as they were in Bellatrix, except that the expected withdrawals for the slot must be gathered from the <code>state</code> (utilizing the helper <code>get_expected_withdrawals</code>) and passed into the <code>ExecutionEngine</code> within <code>prepare_execution_payload</code>.</p> <p>Note: In this section, <code>state</code> is the state of the slot for the block proposal without the block yet applied. That is, <code>state</code> is the <code>previous_state</code> processed through any empty slots up to the assigned slot using <code>process_slots(previous_state, slot)</code>.</p> <p>Note: The only change made to <code>prepare_execution_payload</code> is to call <code>get_expected_withdrawals()</code> to set the new <code>withdrawals</code> field of <code>PayloadAttributes</code>.</p> <pre><code>def prepare_execution_payload(state: BeaconState,\nsafe_block_hash: Hash32,\nfinalized_block_hash: Hash32,\nsuggested_fee_recipient: ExecutionAddress,\nexecution_engine: ExecutionEngine) -&gt; Optional[PayloadId]:\n# [Modified in Capella] Removed `is_merge_transition_complete` check in Capella\nparent_hash = state.latest_execution_payload_header.block_hash\n# Set the forkchoice head and initiate the payload build process\npayload_attributes = PayloadAttributes(\ntimestamp=compute_timestamp_at_slot(state, state.slot),\nprev_randao=get_randao_mix(state, get_current_epoch(state)),\nsuggested_fee_recipient=suggested_fee_recipient,\nwithdrawals=get_expected_withdrawals(state),  # [New in Capella]\n)\nreturn execution_engine.notify_forkchoice_updated(\nhead_block_hash=parent_hash,\nsafe_block_hash=safe_block_hash,\nfinalized_block_hash=finalized_block_hash,\npayload_attributes=payload_attributes,\n)\n</code></pre>"},{"location":"specs/capella/validator/#bls-to-execution-changes","title":"BLS to execution changes","text":"<p>Up to <code>MAX_BLS_TO_EXECUTION_CHANGES</code>, <code>BLSToExecutionChange</code> objects can be included in the <code>block</code>. The BLS to execution changes must satisfy the verification conditions found in BLS to execution change processing.</p>"},{"location":"specs/capella/validator/#enabling-validator-withdrawals","title":"Enabling validator withdrawals","text":"<p>Validator balances are withdrawn periodically via an automatic process. For exited validators, the full balance is withdrawn. For active validators, the balance in excess of <code>MAX_EFFECTIVE_BALANCE</code> is withdrawn.</p> <p>There is one prerequisite for this automated process: the validator's withdrawal credentials pointing to an execution layer address, i.e. having an <code>ETH1_ADDRESS_WITHDRAWAL_PREFIX</code>.</p> <p>If a validator has a <code>BLS_WITHDRAWAL_PREFIX</code> withdrawal credential prefix, to participate in withdrawals the validator must  create a one-time message to change their withdrawal credential from the version authenticated with a BLS key to the version compatible with the execution layer. This message -- a <code>BLSToExecutionChange</code> -- is available starting in Capella</p> <p>Validators who wish to enable withdrawals MUST assemble, sign, and broadcast this message so that it is accepted on the beacon chain. Validators who do not want to enable withdrawals and have the <code>BLS_WITHDRAWAL_PREFIX</code> version of withdrawal credentials can delay creating this message until they are ready to enable withdrawals.</p>"},{"location":"specs/capella/validator/#changing-from-bls-to-execution-withdrawal-credentials","title":"Changing from BLS to execution withdrawal credentials","text":"<p>First, the validator must construct a valid <code>BLSToExecutionChange</code> <code>message</code>. This <code>message</code> contains the <code>validator_index</code> for the validator who wishes to change their credentials, the <code>from_bls_pubkey</code> -- the BLS public key corresponding to the withdrawal BLS secret key used to form the <code>BLS_WITHDRAWAL_PREFIX</code> withdrawal credential, and the <code>to_execution_address</code> specifying the execution layer address to which the validator's balances will be withdrawn.</p> <p>Note: The withdrawal key pair used to construct the <code>BLS_WITHDRAWAL_PREFIX</code> withdrawal credential should be distinct from the signing key pair used to operate the validator under typical circumstances. Consult your validator deposit tooling documentation for further details if you are not aware of the difference.</p> <p>Warning: This message can only be included on-chain once and is irreversible so ensure the correctness and accessibility to <code>to_execution_address</code>.</p> <p>Next, the validator signs the assembled <code>message: BLSToExecutionChange</code> with the withdrawal BLS secret key and this <code>signature</code> is placed into a <code>SignedBLSToExecutionChange</code> message along with the inner <code>BLSToExecutionChange</code> <code>message</code>. Note that the <code>SignedBLSToExecutionChange</code> message should pass all of the validations in <code>process_bls_to_execution_change</code>.</p> <p>The <code>SignedBLSToExecutionChange</code> message should then be submitted to the consensus layer network. Once included on-chain, the withdrawal credential change takes effect. No further action is required for a validator to enter into the automated withdrawal process.</p> <p>Note: A node should prioritize locally received <code>BLSToExecutionChange</code> operations to ensure these changes make it on-chain through self published blocks even if the rest of the network censors.</p>"},{"location":"specs/capella/light-client/fork/","title":"Capella Light Client -- Fork Logic","text":""},{"location":"specs/capella/light-client/fork/#table-of-contents","title":"Table of contents","text":"<ul> <li>Introduction</li> <li>Upgrading light client data</li> <li>Upgrading the store</li> </ul>"},{"location":"specs/capella/light-client/fork/#introduction","title":"Introduction","text":"<p>This document describes how to upgrade existing light client objects based on the Altair specification to Capella. This is necessary when processing pre-Capella data with a post-Capella <code>LightClientStore</code>. Note that the data being exchanged over the network protocols uses the original format.</p>"},{"location":"specs/capella/light-client/fork/#upgrading-light-client-data","title":"Upgrading light client data","text":"<p>A Capella <code>LightClientStore</code> can still process earlier light client data. In order to do so, that pre-Capella data needs to be locally upgraded to Capella before processing.</p> <pre><code>def upgrade_lc_header_to_capella(pre: bellatrix.LightClientHeader) -&gt; LightClientHeader:\nreturn LightClientHeader(\nbeacon=pre.beacon,\n)\n</code></pre> <pre><code>def upgrade_lc_bootstrap_to_capella(pre: bellatrix.LightClientBootstrap) -&gt; LightClientBootstrap:\nreturn LightClientBootstrap(\nheader=upgrade_lc_header_to_capella(pre.header),\ncurrent_sync_committee=pre.current_sync_committee,\ncurrent_sync_committee_branch=pre.current_sync_committee_branch,\n)\n</code></pre> <pre><code>def upgrade_lc_update_to_capella(pre: bellatrix.LightClientUpdate) -&gt; LightClientUpdate:\nreturn LightClientUpdate(\nattested_header=upgrade_lc_header_to_capella(pre.attested_header),\nnext_sync_committee=pre.next_sync_committee,\nnext_sync_committee_branch=pre.next_sync_committee_branch,\nfinalized_header=upgrade_lc_header_to_capella(pre.finalized_header),\nfinality_branch=pre.finality_branch,\nsync_aggregate=pre.sync_aggregate,\nsignature_slot=pre.signature_slot,\n)\n</code></pre> <pre><code>def upgrade_lc_finality_update_to_capella(pre: bellatrix.LightClientFinalityUpdate) -&gt; LightClientFinalityUpdate:\nreturn LightClientFinalityUpdate(\nattested_header=upgrade_lc_header_to_capella(pre.attested_header),\nfinalized_header=upgrade_lc_header_to_capella(pre.finalized_header),\nfinality_branch=pre.finality_branch,\nsync_aggregate=pre.sync_aggregate,\nsignature_slot=pre.signature_slot,\n)\n</code></pre> <pre><code>def upgrade_lc_optimistic_update_to_capella(pre: bellatrix.LightClientOptimisticUpdate) -&gt; LightClientOptimisticUpdate:\nreturn LightClientOptimisticUpdate(\nattested_header=upgrade_lc_header_to_capella(pre.attested_header),\nsync_aggregate=pre.sync_aggregate,\nsignature_slot=pre.signature_slot,\n)\n</code></pre>"},{"location":"specs/capella/light-client/fork/#upgrading-the-store","title":"Upgrading the store","text":"<p>Existing <code>LightClientStore</code> objects based on Altair MUST be upgraded to Capella before Capella based light client data can be processed. The <code>LightClientStore</code> upgrade MAY be performed before <code>CAPELLA_FORK_EPOCH</code>.</p> <pre><code>def upgrade_lc_store_to_capella(pre: bellatrix.LightClientStore) -&gt; LightClientStore:\nif pre.best_valid_update is None:\nbest_valid_update = None\nelse:\nbest_valid_update = upgrade_lc_update_to_capella(pre.best_valid_update)\nreturn LightClientStore(\nfinalized_header=upgrade_lc_header_to_capella(pre.finalized_header),\ncurrent_sync_committee=pre.current_sync_committee,\nnext_sync_committee=pre.next_sync_committee,\nbest_valid_update=best_valid_update,\noptimistic_header=upgrade_lc_header_to_capella(pre.optimistic_header),\nprevious_max_active_participants=pre.previous_max_active_participants,\ncurrent_max_active_participants=pre.current_max_active_participants,\n)\n</code></pre>"},{"location":"specs/capella/light-client/full-node/","title":"Capella Light Client -- Full Node","text":"<p>Notice: This document is a work-in-progress for researchers and implementers.</p>"},{"location":"specs/capella/light-client/full-node/#table-of-contents","title":"Table of contents","text":"<ul> <li>Introduction</li> <li>Helper functions</li> <li>Modified <code>block_to_light_client_header</code></li> </ul>"},{"location":"specs/capella/light-client/full-node/#introduction","title":"Introduction","text":"<p>This upgrade adds information about the execution payload to light client data as part of the Capella upgrade.</p>"},{"location":"specs/capella/light-client/full-node/#helper-functions","title":"Helper functions","text":""},{"location":"specs/capella/light-client/full-node/#modified-block_to_light_client_header","title":"Modified <code>block_to_light_client_header</code>","text":"<pre><code>def block_to_light_client_header(block: SignedBeaconBlock) -&gt; LightClientHeader:\nepoch = compute_epoch_at_slot(block.message.slot)\nif epoch &gt;= CAPELLA_FORK_EPOCH:\npayload = block.message.body.execution_payload\nexecution_header = ExecutionPayloadHeader(\nparent_hash=payload.parent_hash,\nfee_recipient=payload.fee_recipient,\nstate_root=payload.state_root,\nreceipts_root=payload.receipts_root,\nlogs_bloom=payload.logs_bloom,\nprev_randao=payload.prev_randao,\nblock_number=payload.block_number,\ngas_limit=payload.gas_limit,\ngas_used=payload.gas_used,\ntimestamp=payload.timestamp,\nextra_data=payload.extra_data,\nbase_fee_per_gas=payload.base_fee_per_gas,\nblock_hash=payload.block_hash,\ntransactions_root=hash_tree_root(payload.transactions),\nwithdrawals_root=hash_tree_root(payload.withdrawals),\n)\nexecution_branch = ExecutionBranch(\ncompute_merkle_proof(block.message.body, EXECUTION_PAYLOAD_GINDEX))\nelse:\n# Note that during fork transitions, `finalized_header` may still point to earlier forks.\n# While Bellatrix blocks also contain an `ExecutionPayload` (minus `withdrawals_root`),\n# it was not included in the corresponding light client data. To ensure compatibility\n# with legacy data going through `upgrade_lc_header_to_capella`, leave out execution data.\nexecution_header = ExecutionPayloadHeader()\nexecution_branch = ExecutionBranch()\nreturn LightClientHeader(\nbeacon=BeaconBlockHeader(\nslot=block.message.slot,\nproposer_index=block.message.proposer_index,\nparent_root=block.message.parent_root,\nstate_root=block.message.state_root,\nbody_root=hash_tree_root(block.message.body),\n),\nexecution=execution_header,\nexecution_branch=execution_branch,\n)\n</code></pre>"},{"location":"specs/capella/light-client/p2p-interface/","title":"Capella Light Client -- Networking","text":"<p>Notice: This document is a work-in-progress for researchers and implementers.</p>"},{"location":"specs/capella/light-client/p2p-interface/#table-of-contents","title":"Table of contents","text":"<ul> <li>Networking</li> <li>The gossip domain: gossipsub<ul> <li>Topics and messages</li> <li>Global topics<ul> <li><code>light_client_finality_update</code></li> <li><code>light_client_optimistic_update</code></li> </ul> </li> </ul> </li> <li>The Req/Resp domain<ul> <li>Messages</li> <li>GetLightClientBootstrap</li> <li>LightClientUpdatesByRange</li> <li>GetLightClientFinalityUpdate</li> <li>GetLightClientOptimisticUpdate</li> </ul> </li> </ul>"},{"location":"specs/capella/light-client/p2p-interface/#networking","title":"Networking","text":"<p>The Altair light client networking specification is extended to exchange Capella light client data.</p>"},{"location":"specs/capella/light-client/p2p-interface/#the-gossip-domain-gossipsub","title":"The gossip domain: gossipsub","text":""},{"location":"specs/capella/light-client/p2p-interface/#topics-and-messages","title":"Topics and messages","text":""},{"location":"specs/capella/light-client/p2p-interface/#global-topics","title":"Global topics","text":""},{"location":"specs/capella/light-client/p2p-interface/#light_client_finality_update","title":"<code>light_client_finality_update</code>","text":"<code>fork_version</code> Message SSZ type <code>GENESIS_FORK_VERSION</code> n/a <code>ALTAIR_FORK_VERSION</code> through <code>BELLATRIX_FORK_VERSION</code> <code>altair.LightClientFinalityUpdate</code> <code>CAPELLA_FORK_VERSION</code> and later <code>capella.LightClientFinalityUpdate</code>"},{"location":"specs/capella/light-client/p2p-interface/#light_client_optimistic_update","title":"<code>light_client_optimistic_update</code>","text":"<code>fork_version</code> Message SSZ type <code>GENESIS_FORK_VERSION</code> n/a <code>ALTAIR_FORK_VERSION</code> through <code>BELLATRIX_FORK_VERSION</code> <code>altair.LightClientOptimisticUpdate</code> <code>CAPELLA_FORK_VERSION</code> and later <code>capella.LightClientOptimisticUpdate</code>"},{"location":"specs/capella/light-client/p2p-interface/#the-reqresp-domain","title":"The Req/Resp domain","text":""},{"location":"specs/capella/light-client/p2p-interface/#messages","title":"Messages","text":""},{"location":"specs/capella/light-client/p2p-interface/#getlightclientbootstrap","title":"GetLightClientBootstrap","text":"<code>fork_version</code> Response SSZ type <code>GENESIS_FORK_VERSION</code> n/a <code>ALTAIR_FORK_VERSION</code> through <code>BELLATRIX_FORK_VERSION</code> <code>altair.LightClientBootstrap</code> <code>CAPELLA_FORK_VERSION</code> and later <code>capella.LightClientBootstrap</code>"},{"location":"specs/capella/light-client/p2p-interface/#lightclientupdatesbyrange","title":"LightClientUpdatesByRange","text":"<code>fork_version</code> Response chunk SSZ type <code>GENESIS_FORK_VERSION</code> n/a <code>ALTAIR_FORK_VERSION</code> through <code>BELLATRIX_FORK_VERSION</code> <code>altair.LightClientUpdate</code> <code>CAPELLA_FORK_VERSION</code> and later <code>capella.LightClientUpdate</code>"},{"location":"specs/capella/light-client/p2p-interface/#getlightclientfinalityupdate","title":"GetLightClientFinalityUpdate","text":"<code>fork_version</code> Response SSZ type <code>GENESIS_FORK_VERSION</code> n/a <code>ALTAIR_FORK_VERSION</code> through <code>BELLATRIX_FORK_VERSION</code> <code>altair.LightClientFinalityUpdate</code> <code>CAPELLA_FORK_VERSION</code> and later <code>capella.LightClientFinalityUpdate</code>"},{"location":"specs/capella/light-client/p2p-interface/#getlightclientoptimisticupdate","title":"GetLightClientOptimisticUpdate","text":"<code>fork_version</code> Response SSZ type <code>GENESIS_FORK_VERSION</code> n/a <code>ALTAIR_FORK_VERSION</code> through <code>BELLATRIX_FORK_VERSION</code> <code>altair.LightClientOptimisticUpdate</code> <code>CAPELLA_FORK_VERSION</code> and later <code>capella.LightClientOptimisticUpdate</code>"},{"location":"specs/capella/light-client/sync-protocol/","title":"Capella Light Client -- Sync Protocol","text":"<p>Notice: This document is a work-in-progress for researchers and implementers.</p>"},{"location":"specs/capella/light-client/sync-protocol/#table-of-contents","title":"Table of contents","text":"<ul> <li>Introduction</li> <li>Custom types</li> <li>Constants</li> <li>Containers</li> <li>Modified <code>LightClientHeader</code></li> <li>Helper functions</li> <li><code>get_lc_execution_root</code></li> <li>Modified <code>is_valid_light_client_header</code></li> </ul>"},{"location":"specs/capella/light-client/sync-protocol/#introduction","title":"Introduction","text":"<p>This upgrade adds information about the execution payload to light client data as part of the Capella upgrade. It extends the Altair Light Client specifications. The fork document explains how to upgrade existing Altair based deployments to Capella.</p> <p>Additional documents describes the impact of the upgrade on certain roles: - Full node - Networking</p>"},{"location":"specs/capella/light-client/sync-protocol/#custom-types","title":"Custom types","text":"Name SSZ equivalent Description <code>ExecutionBranch</code> <code>Vector[Bytes32, floorlog2(EXECUTION_PAYLOAD_GINDEX)]</code> Merkle branch of <code>execution_payload</code> within <code>BeaconBlockBody</code>"},{"location":"specs/capella/light-client/sync-protocol/#constants","title":"Constants","text":"Name Value <code>EXECUTION_PAYLOAD_GINDEX</code> <code>get_generalized_index(BeaconBlockBody, 'execution_payload')</code> (= 25)"},{"location":"specs/capella/light-client/sync-protocol/#containers","title":"Containers","text":""},{"location":"specs/capella/light-client/sync-protocol/#modified-lightclientheader","title":"Modified <code>LightClientHeader</code>","text":"<pre><code>class LightClientHeader(Container):\n# Beacon block header\nbeacon: BeaconBlockHeader\n# Execution payload header corresponding to `beacon.body_root` (from Capella onward)\nexecution: ExecutionPayloadHeader\nexecution_branch: ExecutionBranch\n</code></pre>"},{"location":"specs/capella/light-client/sync-protocol/#helper-functions","title":"Helper functions","text":""},{"location":"specs/capella/light-client/sync-protocol/#get_lc_execution_root","title":"<code>get_lc_execution_root</code>","text":"<pre><code>def get_lc_execution_root(header: LightClientHeader) -&gt; Root:\nepoch = compute_epoch_at_slot(header.beacon.slot)\nif epoch &gt;= CAPELLA_FORK_EPOCH:\nreturn hash_tree_root(header.execution)\nreturn Root()\n</code></pre>"},{"location":"specs/capella/light-client/sync-protocol/#modified-is_valid_light_client_header","title":"Modified <code>is_valid_light_client_header</code>","text":"<pre><code>def is_valid_light_client_header(header: LightClientHeader) -&gt; bool:\nepoch = compute_epoch_at_slot(header.beacon.slot)\nif epoch &lt; CAPELLA_FORK_EPOCH:\nreturn (\nheader.execution == ExecutionPayloadHeader()\nand header.execution_branch == ExecutionBranch()\n)\nreturn is_valid_merkle_branch(\nleaf=get_lc_execution_root(header),\nbranch=header.execution_branch,\ndepth=floorlog2(EXECUTION_PAYLOAD_GINDEX),\nindex=get_subtree_index(EXECUTION_PAYLOAD_GINDEX),\nroot=header.beacon.body_root,\n)\n</code></pre>"},{"location":"specs/deneb/beacon-chain/","title":"Deneb -- The Beacon Chain","text":""},{"location":"specs/deneb/beacon-chain/#table-of-contents","title":"Table of contents","text":"<ul> <li>Introduction</li> <li>Custom types</li> <li>Constants</li> <li>Blob</li> <li>Preset</li> <li>Execution</li> <li>Configuration</li> <li>Validator cycle</li> <li>Containers</li> <li>Extended containers<ul> <li><code>BeaconBlockBody</code></li> <li><code>ExecutionPayload</code></li> <li><code>ExecutionPayloadHeader</code></li> </ul> </li> <li>Helper functions</li> <li>Misc<ul> <li><code>kzg_commitment_to_versioned_hash</code></li> </ul> </li> <li>Beacon state accessors<ul> <li>Modified <code>get_attestation_participation_flag_indices</code></li> <li>New <code>get_validator_activation_churn_limit</code></li> </ul> </li> <li>Beacon chain state transition function</li> <li>Execution engine<ul> <li>Request data</li> <li>Modified <code>NewPayloadRequest</code></li> <li>Engine APIs</li> <li><code>is_valid_block_hash</code></li> <li><code>is_valid_versioned_hashes</code></li> <li>Modified <code>notify_new_payload</code></li> <li>Modified <code>verify_and_notify_new_payload</code></li> </ul> </li> <li>Block processing<ul> <li>Modified <code>process_attestation</code></li> <li>Execution payload</li> <li>Modified <code>process_execution_payload</code></li> <li>Modified <code>process_voluntary_exit</code></li> </ul> </li> <li>Epoch processing<ul> <li>Registry updates</li> </ul> </li> <li>Testing</li> </ul>"},{"location":"specs/deneb/beacon-chain/#introduction","title":"Introduction","text":"<p>Deneb is a consensus-layer upgrade containing a number of features. Including: * EIP-4788: Beacon block root in the EVM * EIP-4844: Shard Blob Transactions scale data-availability of Ethereum in a simple, forwards-compatible manner * EIP-7044: Perpetually Valid Signed Voluntary Exits * EIP-7045: Increase Max Attestation Inclusion Slot * EIP-7514: Add Max Epoch Churn Limit</p>"},{"location":"specs/deneb/beacon-chain/#custom-types","title":"Custom types","text":"Name SSZ equivalent Description <code>VersionedHash</code> <code>Bytes32</code> [New in Deneb:EIP4844] <code>BlobIndex</code> <code>uint64</code> [New in Deneb:EIP4844]"},{"location":"specs/deneb/beacon-chain/#constants","title":"Constants","text":""},{"location":"specs/deneb/beacon-chain/#blob","title":"Blob","text":"Name Value <code>VERSIONED_HASH_VERSION_KZG</code> <code>Bytes1('0x01')</code>"},{"location":"specs/deneb/beacon-chain/#preset","title":"Preset","text":""},{"location":"specs/deneb/beacon-chain/#execution","title":"Execution","text":"Name Value Description <code>MAX_BLOB_COMMITMENTS_PER_BLOCK</code> <code>uint64(2**12)</code> (= 4096) [New in Deneb:EIP4844] hardfork independent fixed theoretical limit same as <code>LIMIT_BLOBS_PER_TX</code> (see EIP 4844) <code>MAX_BLOBS_PER_BLOCK</code> <code>uint64(6)</code> [New in Deneb:EIP4844] maximum number of blobs in a single block limited by <code>MAX_BLOB_COMMITMENTS_PER_BLOCK</code> <p>Note: The blob transactions are packed into the execution payload by the EL/builder with their corresponding blobs being independently transmitted and are limited by <code>MAX_BLOB_GAS_PER_BLOCK // GAS_PER_BLOB</code>. However the CL limit is independently defined by <code>MAX_BLOBS_PER_BLOCK</code>.</p>"},{"location":"specs/deneb/beacon-chain/#configuration","title":"Configuration","text":""},{"location":"specs/deneb/beacon-chain/#validator-cycle","title":"Validator cycle","text":"Name Value <code>MAX_PER_EPOCH_ACTIVATION_CHURN_LIMIT</code> <code>uint64(2**3)</code> (= 8)"},{"location":"specs/deneb/beacon-chain/#containers","title":"Containers","text":""},{"location":"specs/deneb/beacon-chain/#extended-containers","title":"Extended containers","text":""},{"location":"specs/deneb/beacon-chain/#beaconblockbody","title":"<code>BeaconBlockBody</code>","text":"<p>Note: <code>BeaconBlock</code> and <code>SignedBeaconBlock</code> types are updated indirectly.</p> <pre><code>class BeaconBlockBody(Container):\nrandao_reveal: BLSSignature\neth1_data: Eth1Data  # Eth1 data vote\ngraffiti: Bytes32  # Arbitrary data\n# Operations\nproposer_slashings: List[ProposerSlashing, MAX_PROPOSER_SLASHINGS]\nattester_slashings: List[AttesterSlashing, MAX_ATTESTER_SLASHINGS]\nattestations: List[Attestation, MAX_ATTESTATIONS]\ndeposits: List[Deposit, MAX_DEPOSITS]\nvoluntary_exits: List[SignedVoluntaryExit, MAX_VOLUNTARY_EXITS]\nsync_aggregate: SyncAggregate\n# Execution\nexecution_payload: ExecutionPayload  # [Modified in Deneb:EIP4844]\nbls_to_execution_changes: List[SignedBLSToExecutionChange, MAX_BLS_TO_EXECUTION_CHANGES]\nblob_kzg_commitments: List[KZGCommitment, MAX_BLOB_COMMITMENTS_PER_BLOCK]  # [New in Deneb:EIP4844]\n</code></pre>"},{"location":"specs/deneb/beacon-chain/#executionpayload","title":"<code>ExecutionPayload</code>","text":"<pre><code>class ExecutionPayload(Container):\n# Execution block header fields\nparent_hash: Hash32\nfee_recipient: ExecutionAddress  # 'beneficiary' in the yellow paper\nstate_root: Bytes32\nreceipts_root: Bytes32\nlogs_bloom: ByteVector[BYTES_PER_LOGS_BLOOM]\nprev_randao: Bytes32  # 'difficulty' in the yellow paper\nblock_number: uint64  # 'number' in the yellow paper\ngas_limit: uint64\ngas_used: uint64\ntimestamp: uint64\nextra_data: ByteList[MAX_EXTRA_DATA_BYTES]\nbase_fee_per_gas: uint256\n# Extra payload fields\nblock_hash: Hash32  # Hash of execution block\ntransactions: List[Transaction, MAX_TRANSACTIONS_PER_PAYLOAD]\nwithdrawals: List[Withdrawal, MAX_WITHDRAWALS_PER_PAYLOAD]\nblob_gas_used: uint64  # [New in Deneb:EIP4844]\nexcess_blob_gas: uint64  # [New in Deneb:EIP4844]\n</code></pre>"},{"location":"specs/deneb/beacon-chain/#executionpayloadheader","title":"<code>ExecutionPayloadHeader</code>","text":"<pre><code>class ExecutionPayloadHeader(Container):\n# Execution block header fields\nparent_hash: Hash32\nfee_recipient: ExecutionAddress\nstate_root: Bytes32\nreceipts_root: Bytes32\nlogs_bloom: ByteVector[BYTES_PER_LOGS_BLOOM]\nprev_randao: Bytes32\nblock_number: uint64\ngas_limit: uint64\ngas_used: uint64\ntimestamp: uint64\nextra_data: ByteList[MAX_EXTRA_DATA_BYTES]\nbase_fee_per_gas: uint256\n# Extra payload fields\nblock_hash: Hash32  # Hash of execution block\ntransactions_root: Root\nwithdrawals_root: Root\nblob_gas_used: uint64  # [New in Deneb:EIP4844]\nexcess_blob_gas: uint64  # [New in Deneb:EIP4844]\n</code></pre>"},{"location":"specs/deneb/beacon-chain/#helper-functions","title":"Helper functions","text":""},{"location":"specs/deneb/beacon-chain/#misc","title":"Misc","text":""},{"location":"specs/deneb/beacon-chain/#kzg_commitment_to_versioned_hash","title":"<code>kzg_commitment_to_versioned_hash</code>","text":"<pre><code>def kzg_commitment_to_versioned_hash(kzg_commitment: KZGCommitment) -&gt; VersionedHash:\nreturn VERSIONED_HASH_VERSION_KZG + hash(kzg_commitment)[1:]\n</code></pre>"},{"location":"specs/deneb/beacon-chain/#beacon-state-accessors","title":"Beacon state accessors","text":""},{"location":"specs/deneb/beacon-chain/#modified-get_attestation_participation_flag_indices","title":"Modified <code>get_attestation_participation_flag_indices</code>","text":"<p>Note: The function <code>get_attestation_participation_flag_indices</code> is modified to set the <code>TIMELY_TARGET_FLAG</code> for any correct target attestation, regardless of <code>inclusion_delay</code> as a baseline reward for any speed of inclusion of an attestation that contributes to justification of the contained chain for EIP-7045.</p> <pre><code>def get_attestation_participation_flag_indices(state: BeaconState,\ndata: AttestationData,\ninclusion_delay: uint64) -&gt; Sequence[int]:\n\"\"\"\n    Return the flag indices that are satisfied by an attestation.\n    \"\"\"\nif data.target.epoch == get_current_epoch(state):\njustified_checkpoint = state.current_justified_checkpoint\nelse:\njustified_checkpoint = state.previous_justified_checkpoint\n# Matching roots\nis_matching_source = data.source == justified_checkpoint\nis_matching_target = is_matching_source and data.target.root == get_block_root(state, data.target.epoch)\nis_matching_head = is_matching_target and data.beacon_block_root == get_block_root_at_slot(state, data.slot)\nassert is_matching_source\nparticipation_flag_indices = []\nif is_matching_source and inclusion_delay &lt;= integer_squareroot(SLOTS_PER_EPOCH):\nparticipation_flag_indices.append(TIMELY_SOURCE_FLAG_INDEX)\nif is_matching_target:  # [Modified in Deneb:EIP7045]\nparticipation_flag_indices.append(TIMELY_TARGET_FLAG_INDEX)\nif is_matching_head and inclusion_delay == MIN_ATTESTATION_INCLUSION_DELAY:\nparticipation_flag_indices.append(TIMELY_HEAD_FLAG_INDEX)\nreturn participation_flag_indices\n</code></pre>"},{"location":"specs/deneb/beacon-chain/#new-get_validator_activation_churn_limit","title":"New <code>get_validator_activation_churn_limit</code>","text":"<pre><code>def get_validator_activation_churn_limit(state: BeaconState) -&gt; uint64:\n\"\"\"\n    Return the validator activation churn limit for the current epoch.\n    \"\"\"\nreturn min(MAX_PER_EPOCH_ACTIVATION_CHURN_LIMIT, get_validator_churn_limit(state))\n</code></pre>"},{"location":"specs/deneb/beacon-chain/#beacon-chain-state-transition-function","title":"Beacon chain state transition function","text":""},{"location":"specs/deneb/beacon-chain/#execution-engine","title":"Execution engine","text":""},{"location":"specs/deneb/beacon-chain/#request-data","title":"Request data","text":""},{"location":"specs/deneb/beacon-chain/#modified-newpayloadrequest","title":"Modified <code>NewPayloadRequest</code>","text":"<pre><code>@dataclass\nclass NewPayloadRequest(object):\nexecution_payload: ExecutionPayload\nversioned_hashes: Sequence[VersionedHash]\nparent_beacon_block_root: Root\n</code></pre>"},{"location":"specs/deneb/beacon-chain/#engine-apis","title":"Engine APIs","text":""},{"location":"specs/deneb/beacon-chain/#is_valid_block_hash","title":"<code>is_valid_block_hash</code>","text":"<p>Note: The function <code>is_valid_block_hash</code> is modified to include the additional <code>parent_beacon_block_root</code> parameter for EIP-4788.</p> <pre><code>def is_valid_block_hash(self: ExecutionEngine,\nexecution_payload: ExecutionPayload,\nparent_beacon_block_root: Root) -&gt; bool:\n\"\"\"\n    Return ``True`` if and only if ``execution_payload.block_hash`` is computed correctly.\n    \"\"\"\n...\n</code></pre>"},{"location":"specs/deneb/beacon-chain/#is_valid_versioned_hashes","title":"<code>is_valid_versioned_hashes</code>","text":"<pre><code>def is_valid_versioned_hashes(self: ExecutionEngine, new_payload_request: NewPayloadRequest) -&gt; bool:\n\"\"\"\n    Return ``True`` if and only if the version hashes computed by the blob transactions of\n    ``new_payload_request.execution_payload`` matches ``new_payload_request.version_hashes``.\n    \"\"\"\n...\n</code></pre>"},{"location":"specs/deneb/beacon-chain/#modified-notify_new_payload","title":"Modified <code>notify_new_payload</code>","text":"<p>Note: The function <code>notify_new_payload</code> is modified to include the additional <code>parent_beacon_block_root</code> parameter for EIP-4788.</p> <pre><code>def notify_new_payload(self: ExecutionEngine,\nexecution_payload: ExecutionPayload,\nparent_beacon_block_root: Root) -&gt; bool:\n\"\"\"\n    Return ``True`` if and only if ``execution_payload`` is valid with respect to ``self.execution_state``.\n    \"\"\"\n...\n</code></pre>"},{"location":"specs/deneb/beacon-chain/#modified-verify_and_notify_new_payload","title":"Modified <code>verify_and_notify_new_payload</code>","text":"<pre><code>def verify_and_notify_new_payload(self: ExecutionEngine,\nnew_payload_request: NewPayloadRequest) -&gt; bool:\n\"\"\"\n    Return ``True`` if and only if ``new_payload_request`` is valid with respect to ``self.execution_state``.\n    \"\"\"\nexecution_payload = new_payload_request.execution_payload\nparent_beacon_block_root = new_payload_request.parent_beacon_block_root\n# [Modified in Deneb:EIP4788]\nif not self.is_valid_block_hash(execution_payload, parent_beacon_block_root):\nreturn False\n# [New in Deneb:EIP4844]\nif not self.is_valid_versioned_hashes(new_payload_request):\nreturn False\n# [Modified in Deneb:EIP4788]\nif not self.notify_new_payload(execution_payload, parent_beacon_block_root):\nreturn False\nreturn True\n</code></pre>"},{"location":"specs/deneb/beacon-chain/#block-processing","title":"Block processing","text":""},{"location":"specs/deneb/beacon-chain/#modified-process_attestation","title":"Modified <code>process_attestation</code>","text":"<p>Note: The function <code>process_attestation</code> is modified to expand valid slots for inclusion to those in both <code>target.epoch</code> epoch and <code>target.epoch + 1</code> epoch for EIP-7045. Additionally, it utilizes an updated version of <code>get_attestation_participation_flag_indices</code> to ensure rewards are available for the extended attestation inclusion range for EIP-7045.</p> <pre><code>def process_attestation(state: BeaconState, attestation: Attestation) -&gt; None:\ndata = attestation.data\nassert data.target.epoch in (get_previous_epoch(state), get_current_epoch(state))\nassert data.target.epoch == compute_epoch_at_slot(data.slot)\nassert data.slot + MIN_ATTESTATION_INCLUSION_DELAY &lt;= state.slot  # [Modified in Deneb:EIP7045]\nassert data.index &lt; get_committee_count_per_slot(state, data.target.epoch)\ncommittee = get_beacon_committee(state, data.slot, data.index)\nassert len(attestation.aggregation_bits) == len(committee)\n# Participation flag indices\nparticipation_flag_indices = get_attestation_participation_flag_indices(state, data, state.slot - data.slot)\n# Verify signature\nassert is_valid_indexed_attestation(state, get_indexed_attestation(state, attestation))\n# Update epoch participation flags\nif data.target.epoch == get_current_epoch(state):\nepoch_participation = state.current_epoch_participation\nelse:\nepoch_participation = state.previous_epoch_participation\nproposer_reward_numerator = 0\nfor index in get_attesting_indices(state, attestation):\nfor flag_index, weight in enumerate(PARTICIPATION_FLAG_WEIGHTS):\nif flag_index in participation_flag_indices and not has_flag(epoch_participation[index], flag_index):\nepoch_participation[index] = add_flag(epoch_participation[index], flag_index)\nproposer_reward_numerator += get_base_reward(state, index) * weight\n# Reward proposer\nproposer_reward_denominator = (WEIGHT_DENOMINATOR - PROPOSER_WEIGHT) * WEIGHT_DENOMINATOR // PROPOSER_WEIGHT\nproposer_reward = Gwei(proposer_reward_numerator // proposer_reward_denominator)\nincrease_balance(state, get_beacon_proposer_index(state), proposer_reward)\n</code></pre>"},{"location":"specs/deneb/beacon-chain/#execution-payload","title":"Execution payload","text":""},{"location":"specs/deneb/beacon-chain/#modified-process_execution_payload","title":"Modified <code>process_execution_payload</code>","text":"<p>Note: The function <code>process_execution_payload</code> is modified to pass <code>versioned_hashes</code> into <code>execution_engine.verify_and_notify_new_payload</code> and to assign the new fields in <code>ExecutionPayloadHeader</code> for EIP-4844. It is also modified to pass in the parent beacon block root to support EIP-4788.</p> <pre><code>def process_execution_payload(state: BeaconState, body: BeaconBlockBody, execution_engine: ExecutionEngine) -&gt; None:\npayload = body.execution_payload\n# Verify consistency of the parent hash with respect to the previous execution payload header\nassert payload.parent_hash == state.latest_execution_payload_header.block_hash\n# Verify prev_randao\nassert payload.prev_randao == get_randao_mix(state, get_current_epoch(state))\n# Verify timestamp\nassert payload.timestamp == compute_timestamp_at_slot(state, state.slot)\n# [New in Deneb:EIP4844] Verify commitments are under limit\nassert len(body.blob_kzg_commitments) &lt;= MAX_BLOBS_PER_BLOCK\n# Verify the execution payload is valid\n# [Modified in Deneb:EIP4844] Pass `versioned_hashes` to Execution Engine\n# [Modified in Deneb:EIP4788] Pass `parent_beacon_block_root` to Execution Engine\nversioned_hashes = [kzg_commitment_to_versioned_hash(commitment) for commitment in body.blob_kzg_commitments]\nassert execution_engine.verify_and_notify_new_payload(\nNewPayloadRequest(\nexecution_payload=payload,\nversioned_hashes=versioned_hashes,\nparent_beacon_block_root=state.latest_block_header.parent_root,\n)\n)\n# Cache execution payload header\nstate.latest_execution_payload_header = ExecutionPayloadHeader(\nparent_hash=payload.parent_hash,\nfee_recipient=payload.fee_recipient,\nstate_root=payload.state_root,\nreceipts_root=payload.receipts_root,\nlogs_bloom=payload.logs_bloom,\nprev_randao=payload.prev_randao,\nblock_number=payload.block_number,\ngas_limit=payload.gas_limit,\ngas_used=payload.gas_used,\ntimestamp=payload.timestamp,\nextra_data=payload.extra_data,\nbase_fee_per_gas=payload.base_fee_per_gas,\nblock_hash=payload.block_hash,\ntransactions_root=hash_tree_root(payload.transactions),\nwithdrawals_root=hash_tree_root(payload.withdrawals),\nblob_gas_used=payload.blob_gas_used,  # [New in Deneb:EIP4844]\nexcess_blob_gas=payload.excess_blob_gas,  # [New in Deneb:EIP4844]\n)\n</code></pre>"},{"location":"specs/deneb/beacon-chain/#modified-process_voluntary_exit","title":"Modified <code>process_voluntary_exit</code>","text":"<p>Note: The function <code>process_voluntary_exit</code> is modified to use the a fixed fork version -- <code>CAPELLA_FORK_VERSION</code> -- for EIP-7044.</p> <pre><code>def process_voluntary_exit(state: BeaconState, signed_voluntary_exit: SignedVoluntaryExit) -&gt; None:\nvoluntary_exit = signed_voluntary_exit.message\nvalidator = state.validators[voluntary_exit.validator_index]\n# Verify the validator is active\nassert is_active_validator(validator, get_current_epoch(state))\n# Verify exit has not been initiated\nassert validator.exit_epoch == FAR_FUTURE_EPOCH\n# Exits must specify an epoch when they become valid; they are not valid before then\nassert get_current_epoch(state) &gt;= voluntary_exit.epoch\n# Verify the validator has been active long enough\nassert get_current_epoch(state) &gt;= validator.activation_epoch + SHARD_COMMITTEE_PERIOD\n# Verify signature\n# [Modified in Deneb:EIP7044]\ndomain = compute_domain(DOMAIN_VOLUNTARY_EXIT, CAPELLA_FORK_VERSION, state.genesis_validators_root)\nsigning_root = compute_signing_root(voluntary_exit, domain)\nassert bls.Verify(validator.pubkey, signing_root, signed_voluntary_exit.signature)\n# Initiate exit\ninitiate_validator_exit(state, voluntary_exit.validator_index)\n</code></pre>"},{"location":"specs/deneb/beacon-chain/#epoch-processing","title":"Epoch processing","text":""},{"location":"specs/deneb/beacon-chain/#registry-updates","title":"Registry updates","text":"<p>Note: The function <code>process_registry_updates</code> is modified to utilize <code>get_validator_activation_churn_limit()</code> to rate limit the activation queue for EIP-7514.</p> <pre><code>def process_registry_updates(state: BeaconState) -&gt; None:\n# Process activation eligibility and ejections\nfor index, validator in enumerate(state.validators):\nif is_eligible_for_activation_queue(validator):\nvalidator.activation_eligibility_epoch = get_current_epoch(state) + 1\nif (\nis_active_validator(validator, get_current_epoch(state))\nand validator.effective_balance &lt;= EJECTION_BALANCE\n):\ninitiate_validator_exit(state, ValidatorIndex(index))\n# Queue validators eligible for activation and not yet dequeued for activation\nactivation_queue = sorted([\nindex for index, validator in enumerate(state.validators)\nif is_eligible_for_activation(state, validator)\n# Order by the sequence of activation_eligibility_epoch setting and then index\n], key=lambda index: (state.validators[index].activation_eligibility_epoch, index))\n# Dequeued validators for activation up to activation churn limit\n# [Modified in Deneb:EIP7514]\nfor index in activation_queue[:get_validator_activation_churn_limit(state)]:\nvalidator = state.validators[index]\nvalidator.activation_epoch = compute_activation_exit_epoch(get_current_epoch(state))\n</code></pre>"},{"location":"specs/deneb/beacon-chain/#testing","title":"Testing","text":"<p>Note: The function <code>initialize_beacon_state_from_eth1</code> is modified for pure Deneb testing only.</p> <p>The <code>BeaconState</code> initialization is unchanged, except for the use of the updated <code>deneb.BeaconBlockBody</code> type when initializing the first body-root.</p> <pre><code>def initialize_beacon_state_from_eth1(eth1_block_hash: Hash32,\neth1_timestamp: uint64,\ndeposits: Sequence[Deposit],\nexecution_payload_header: ExecutionPayloadHeader=ExecutionPayloadHeader()\n) -&gt; BeaconState:\nfork = Fork(\nprevious_version=DENEB_FORK_VERSION,  # [Modified in Deneb] for testing only\ncurrent_version=DENEB_FORK_VERSION,  # [Modified in Deneb]\nepoch=GENESIS_EPOCH,\n)\nstate = BeaconState(\ngenesis_time=eth1_timestamp + GENESIS_DELAY,\nfork=fork,\neth1_data=Eth1Data(block_hash=eth1_block_hash, deposit_count=uint64(len(deposits))),\nlatest_block_header=BeaconBlockHeader(body_root=hash_tree_root(BeaconBlockBody())),\nrandao_mixes=[eth1_block_hash] * EPOCHS_PER_HISTORICAL_VECTOR,  # Seed RANDAO with Eth1 entropy\n)\n# Process deposits\nleaves = list(map(lambda deposit: deposit.data, deposits))\nfor index, deposit in enumerate(deposits):\ndeposit_data_list = List[DepositData, 2**DEPOSIT_CONTRACT_TREE_DEPTH](*leaves[:index + 1])\nstate.eth1_data.deposit_root = hash_tree_root(deposit_data_list)\nprocess_deposit(state, deposit)\n# Process activations\nfor index, validator in enumerate(state.validators):\nbalance = state.balances[index]\nvalidator.effective_balance = min(balance - balance % EFFECTIVE_BALANCE_INCREMENT, MAX_EFFECTIVE_BALANCE)\nif validator.effective_balance == MAX_EFFECTIVE_BALANCE:\nvalidator.activation_eligibility_epoch = GENESIS_EPOCH\nvalidator.activation_epoch = GENESIS_EPOCH\n# Set genesis validators root for domain separation and chain versioning\nstate.genesis_validators_root = hash_tree_root(state.validators)\n# Fill in sync committees\n# Note: A duplicate committee is assigned for the current and next committee at genesis\nstate.current_sync_committee = get_next_sync_committee(state)\nstate.next_sync_committee = get_next_sync_committee(state)\n# Initialize the execution payload header\n# If empty, will initialize a chain that has not yet gone through the Merge transition\nstate.latest_execution_payload_header = execution_payload_header\nreturn state\n</code></pre>"},{"location":"specs/deneb/fork-choice/","title":"Deneb -- Fork Choice","text":""},{"location":"specs/deneb/fork-choice/#table-of-contents","title":"Table of contents","text":"<ul> <li>Introduction</li> <li>Containers</li> <li>Helpers</li> <li>Extended <code>PayloadAttributes</code></li> <li><code>is_data_available</code></li> <li>Updated fork-choice handlers</li> <li><code>on_block</code></li> </ul>"},{"location":"specs/deneb/fork-choice/#introduction","title":"Introduction","text":"<p>This is the modification of the fork choice accompanying the Deneb upgrade.</p>"},{"location":"specs/deneb/fork-choice/#containers","title":"Containers","text":""},{"location":"specs/deneb/fork-choice/#helpers","title":"Helpers","text":""},{"location":"specs/deneb/fork-choice/#extended-payloadattributes","title":"Extended <code>PayloadAttributes</code>","text":"<p><code>PayloadAttributes</code> is extended with the parent beacon block root for EIP-4788.</p> <pre><code>@dataclass\nclass PayloadAttributes(object):\ntimestamp: uint64\nprev_randao: Bytes32\nsuggested_fee_recipient: ExecutionAddress\nwithdrawals: Sequence[Withdrawal]\nparent_beacon_block_root: Root  # [New in Deneb:EIP4788]\n</code></pre>"},{"location":"specs/deneb/fork-choice/#is_data_available","title":"<code>is_data_available</code>","text":"<p>[New in Deneb:EIP4844]</p> <p>The implementation of <code>is_data_available</code> will become more sophisticated during later scaling upgrades. Initially, verification requires every verifying actor to retrieve all matching <code>Blob</code>s and <code>KZGProof</code>s, and validate them with <code>verify_blob_kzg_proof_batch</code>.</p> <p>The block MUST NOT be considered valid until all valid <code>Blob</code>s have been downloaded. Blocks that have been previously validated as available SHOULD be considered available even if the associated <code>Blob</code>s have subsequently been pruned.</p> <p>Note: Extraneous or invalid Blobs (in addition to KZG expected/referenced valid blobs) received on the p2p network MUST NOT invalidate a block that is otherwise valid and available.</p> <pre><code>def is_data_available(beacon_block_root: Root, blob_kzg_commitments: Sequence[KZGCommitment]) -&gt; bool:\n# `retrieve_blobs_and_proofs` is implementation and context dependent\n# It returns all the blobs for the given block root, and raises an exception if not available\n# Note: the p2p network does not guarantee sidecar retrieval outside of\n# `MIN_EPOCHS_FOR_BLOB_SIDECARS_REQUESTS`\nblobs, proofs = retrieve_blobs_and_proofs(beacon_block_root)\nreturn verify_blob_kzg_proof_batch(blobs, blob_kzg_commitments, proofs)\n</code></pre>"},{"location":"specs/deneb/fork-choice/#updated-fork-choice-handlers","title":"Updated fork-choice handlers","text":""},{"location":"specs/deneb/fork-choice/#on_block","title":"<code>on_block</code>","text":"<p>Note: The only modification is the addition of the blob data availability check.</p> <pre><code>def on_block(store: Store, signed_block: SignedBeaconBlock) -&gt; None:\n\"\"\"\n    Run ``on_block`` upon receiving a new block.\n    \"\"\"\nblock = signed_block.message\n# Parent block must be known\nassert block.parent_root in store.block_states\n# Make a copy of the state to avoid mutability issues\npre_state = copy(store.block_states[block.parent_root])\n# Blocks cannot be in the future. If they are, their consideration must be delayed until they are in the past.\nassert get_current_slot(store) &gt;= block.slot\n# Check that block is later than the finalized epoch slot (optimization to reduce calls to get_ancestor)\nfinalized_slot = compute_start_slot_at_epoch(store.finalized_checkpoint.epoch)\nassert block.slot &gt; finalized_slot\n# Check block is a descendant of the finalized block at the checkpoint finalized slot\nfinalized_checkpoint_block = get_checkpoint_block(\nstore,\nblock.parent_root,\nstore.finalized_checkpoint.epoch,\n)\nassert store.finalized_checkpoint.root == finalized_checkpoint_block\n# [New in Deneb:EIP4844]\n# Check if blob data is available\n# If not, this block MAY be queued and subsequently considered when blob data becomes available\n# *Note*: Extraneous or invalid Blobs (in addition to the expected/referenced valid blobs)\n# received on the p2p network MUST NOT invalidate a block that is otherwise valid and available\nassert is_data_available(hash_tree_root(block), block.body.blob_kzg_commitments)\n# Check the block is valid and compute the post-state\nstate = pre_state.copy()\nblock_root = hash_tree_root(block)\nstate_transition(state, signed_block, True)\n# Add new block to the store\nstore.blocks[block_root] = block\n# Add new state for this block to the store\nstore.block_states[block_root] = state\n# Add block timeliness to the store\ntime_into_slot = (store.time - store.genesis_time) % SECONDS_PER_SLOT\nis_before_attesting_interval = time_into_slot &lt; SECONDS_PER_SLOT // INTERVALS_PER_SLOT\nis_timely = get_current_slot(store) == block.slot and is_before_attesting_interval\nstore.block_timeliness[hash_tree_root(block)] = is_timely\n# Add proposer score boost if the block is timely and not conflicting with an existing block\nis_first_block = store.proposer_boost_root == Root()\nif is_timely and is_first_block:\nstore.proposer_boost_root = hash_tree_root(block)\n# Update checkpoints in store if necessary\nupdate_checkpoints(store, state.current_justified_checkpoint, state.finalized_checkpoint)\n# Eagerly compute unrealized justification and finality.\ncompute_pulled_up_tip(store, block_root)\n</code></pre>"},{"location":"specs/deneb/fork/","title":"Deneb -- Fork Logic","text":""},{"location":"specs/deneb/fork/#table-of-contents","title":"Table of contents","text":"<ul> <li>Introduction</li> <li>Configuration</li> <li>Helper functions</li> <li>Misc<ul> <li>Modified <code>compute_fork_version</code></li> </ul> </li> <li>Fork to Deneb</li> <li>Fork trigger</li> <li>Upgrading the state</li> </ul>"},{"location":"specs/deneb/fork/#introduction","title":"Introduction","text":"<p>This document describes the process of Deneb upgrade.</p>"},{"location":"specs/deneb/fork/#configuration","title":"Configuration","text":"<p>Warning: this configuration is not definitive.</p> Name Value <code>DENEB_FORK_VERSION</code> <code>Version('0x04000000')</code> <code>DENEB_FORK_EPOCH</code> <code>Epoch(269568)</code> (March 13, 2024, 01:55:35pm UTC)"},{"location":"specs/deneb/fork/#helper-functions","title":"Helper functions","text":""},{"location":"specs/deneb/fork/#misc","title":"Misc","text":""},{"location":"specs/deneb/fork/#modified-compute_fork_version","title":"Modified <code>compute_fork_version</code>","text":"<pre><code>def compute_fork_version(epoch: Epoch) -&gt; Version:\n\"\"\"\n    Return the fork version at the given ``epoch``.\n    \"\"\"\nif epoch &gt;= DENEB_FORK_EPOCH:\nreturn DENEB_FORK_VERSION\nif epoch &gt;= CAPELLA_FORK_EPOCH:\nreturn CAPELLA_FORK_VERSION\nif epoch &gt;= BELLATRIX_FORK_EPOCH:\nreturn BELLATRIX_FORK_VERSION\nif epoch &gt;= ALTAIR_FORK_EPOCH:\nreturn ALTAIR_FORK_VERSION\nreturn GENESIS_FORK_VERSION\n</code></pre>"},{"location":"specs/deneb/fork/#fork-to-deneb","title":"Fork to Deneb","text":""},{"location":"specs/deneb/fork/#fork-trigger","title":"Fork trigger","text":"<p>TBD. This fork is defined for testing purposes. For now, we assume the condition will be triggered at epoch <code>DENEB_FORK_EPOCH</code>.</p> <p>Note that for the pure Deneb networks, we don't apply <code>upgrade_to_deneb</code> since it starts with Deneb version logic.</p>"},{"location":"specs/deneb/fork/#upgrading-the-state","title":"Upgrading the state","text":"<pre><code>def upgrade_to_deneb(pre: capella.BeaconState) -&gt; BeaconState:\nepoch = capella.get_current_epoch(pre)\nlatest_execution_payload_header = ExecutionPayloadHeader(\nparent_hash=pre.latest_execution_payload_header.parent_hash,\nfee_recipient=pre.latest_execution_payload_header.fee_recipient,\nstate_root=pre.latest_execution_payload_header.state_root,\nreceipts_root=pre.latest_execution_payload_header.receipts_root,\nlogs_bloom=pre.latest_execution_payload_header.logs_bloom,\nprev_randao=pre.latest_execution_payload_header.prev_randao,\nblock_number=pre.latest_execution_payload_header.block_number,\ngas_limit=pre.latest_execution_payload_header.gas_limit,\ngas_used=pre.latest_execution_payload_header.gas_used,\ntimestamp=pre.latest_execution_payload_header.timestamp,\nextra_data=pre.latest_execution_payload_header.extra_data,\nbase_fee_per_gas=pre.latest_execution_payload_header.base_fee_per_gas,\nblock_hash=pre.latest_execution_payload_header.block_hash,\ntransactions_root=pre.latest_execution_payload_header.transactions_root,\nwithdrawals_root=pre.latest_execution_payload_header.withdrawals_root,\nblob_gas_used=uint64(0),  # [New in Deneb:EIP4844]\nexcess_blob_gas=uint64(0),  # [New in Deneb:EIP4844]\n)\npost = BeaconState(\n# Versioning\ngenesis_time=pre.genesis_time,\ngenesis_validators_root=pre.genesis_validators_root,\nslot=pre.slot,\nfork=Fork(\nprevious_version=pre.fork.current_version,\ncurrent_version=DENEB_FORK_VERSION,  # [Modified in Deneb]\nepoch=epoch,\n),\n# History\nlatest_block_header=pre.latest_block_header,\nblock_roots=pre.block_roots,\nstate_roots=pre.state_roots,\nhistorical_roots=pre.historical_roots,\n# Eth1\neth1_data=pre.eth1_data,\neth1_data_votes=pre.eth1_data_votes,\neth1_deposit_index=pre.eth1_deposit_index,\n# Registry\nvalidators=pre.validators,\nbalances=pre.balances,\n# Randomness\nrandao_mixes=pre.randao_mixes,\n# Slashings\nslashings=pre.slashings,\n# Participation\nprevious_epoch_participation=pre.previous_epoch_participation,\ncurrent_epoch_participation=pre.current_epoch_participation,\n# Finality\njustification_bits=pre.justification_bits,\nprevious_justified_checkpoint=pre.previous_justified_checkpoint,\ncurrent_justified_checkpoint=pre.current_justified_checkpoint,\nfinalized_checkpoint=pre.finalized_checkpoint,\n# Inactivity\ninactivity_scores=pre.inactivity_scores,\n# Sync\ncurrent_sync_committee=pre.current_sync_committee,\nnext_sync_committee=pre.next_sync_committee,\n# Execution-layer\nlatest_execution_payload_header=latest_execution_payload_header,  # [Modified in Deneb:EIP4844]\n# Withdrawals\nnext_withdrawal_index=pre.next_withdrawal_index,\nnext_withdrawal_validator_index=pre.next_withdrawal_validator_index,\n# Deep history valid from Capella onwards\nhistorical_summaries=pre.historical_summaries,\n)\nreturn post\n</code></pre>"},{"location":"specs/deneb/p2p-interface/","title":"Deneb -- Networking","text":"<p>This document contains the consensus-layer networking specification for Deneb.</p> <p>The specification of these changes continues in the same format as the network specifications of previous upgrades, and assumes them as pre-requisite.</p>"},{"location":"specs/deneb/p2p-interface/#table-of-contents","title":"Table of contents","text":"<ul> <li>Modifications in Deneb</li> <li>Constant</li> <li>Preset</li> <li>Configuration</li> <li>Containers<ul> <li><code>BlobSidecar</code></li> <li><code>BlobIdentifier</code></li> <li>Helpers</li> <li><code>verify_blob_sidecar_inclusion_proof</code></li> </ul> </li> <li>The gossip domain: gossipsub<ul> <li>Topics and messages</li> <li>Global topics<ul> <li><code>beacon_block</code></li> <li><code>beacon_aggregate_and_proof</code></li> </ul> </li> <li>Blob subnets<ul> <li><code>blob_sidecar_{subnet_id}</code></li> </ul> </li> <li>Attestation subnets<ul> <li><code>beacon_attestation_{subnet_id}</code></li> </ul> </li> <li>Transitioning the gossip</li> </ul> </li> <li>The Req/Resp domain<ul> <li>Messages</li> <li>BeaconBlocksByRange v2</li> <li>BeaconBlocksByRoot v2</li> <li>BlobSidecarsByRoot v1</li> <li>BlobSidecarsByRange v1</li> </ul> </li> <li>Design decision rationale</li> <li>Why are blobs relayed as a sidecar, separate from beacon blocks?</li> </ul>"},{"location":"specs/deneb/p2p-interface/#modifications-in-deneb","title":"Modifications in Deneb","text":""},{"location":"specs/deneb/p2p-interface/#constant","title":"Constant","text":"<p>[New in Deneb:EIP4844]</p>"},{"location":"specs/deneb/p2p-interface/#preset","title":"Preset","text":"<p>[New in Deneb:EIP4844]</p> Name Value Description <code>KZG_COMMITMENT_INCLUSION_PROOF_DEPTH</code> <code>uint64(floorlog2(get_generalized_index(BeaconBlockBody, 'blob_kzg_commitments')) + 1 + ceillog2(MAX_BLOB_COMMITMENTS_PER_BLOCK))</code> (= 17)  Merkle proof depth for <code>blob_kzg_commitments</code> list item"},{"location":"specs/deneb/p2p-interface/#configuration","title":"Configuration","text":"<p>[New in Deneb:EIP4844]</p> Name Value Description <code>MAX_REQUEST_BLOCKS_DENEB</code> <code>2**7</code> (= 128) Maximum number of blocks in a single request <code>MAX_REQUEST_BLOB_SIDECARS</code> <code>MAX_REQUEST_BLOCKS_DENEB * MAX_BLOBS_PER_BLOCK</code> Maximum number of blob sidecars in a single request <code>MIN_EPOCHS_FOR_BLOB_SIDECARS_REQUESTS</code> <code>2**12</code> (= 4096 epochs, ~18 days) The minimum epoch range over which a node must serve blob sidecars <code>BLOB_SIDECAR_SUBNET_COUNT</code> <code>6</code> The number of blob sidecar subnets used in the gossipsub protocol."},{"location":"specs/deneb/p2p-interface/#containers","title":"Containers","text":""},{"location":"specs/deneb/p2p-interface/#blobsidecar","title":"<code>BlobSidecar</code>","text":"<p>[New in Deneb:EIP4844]</p> <pre><code>class BlobSidecar(Container):\nindex: BlobIndex  # Index of blob in block\nblob: Blob\nkzg_commitment: KZGCommitment\nkzg_proof: KZGProof  # Allows for quick verification of kzg_commitment\nsigned_block_header: SignedBeaconBlockHeader\nkzg_commitment_inclusion_proof: Vector[Bytes32, KZG_COMMITMENT_INCLUSION_PROOF_DEPTH]\n</code></pre>"},{"location":"specs/deneb/p2p-interface/#blobidentifier","title":"<code>BlobIdentifier</code>","text":"<p>[New in Deneb:EIP4844]</p> <pre><code>class BlobIdentifier(Container):\nblock_root: Root\nindex: BlobIndex\n</code></pre>"},{"location":"specs/deneb/p2p-interface/#helpers","title":"Helpers","text":""},{"location":"specs/deneb/p2p-interface/#verify_blob_sidecar_inclusion_proof","title":"<code>verify_blob_sidecar_inclusion_proof</code>","text":"<pre><code>def verify_blob_sidecar_inclusion_proof(blob_sidecar: BlobSidecar) -&gt; bool:\ngindex = get_subtree_index(get_generalized_index(BeaconBlockBody, 'blob_kzg_commitments', blob_sidecar.index))\nreturn is_valid_merkle_branch(\nleaf=blob_sidecar.kzg_commitment.hash_tree_root(),\nbranch=blob_sidecar.kzg_commitment_inclusion_proof,\ndepth=KZG_COMMITMENT_INCLUSION_PROOF_DEPTH,\nindex=gindex,\nroot=blob_sidecar.signed_block_header.message.body_root,\n)\n</code></pre>"},{"location":"specs/deneb/p2p-interface/#the-gossip-domain-gossipsub","title":"The gossip domain: gossipsub","text":"<p>Some gossip meshes are upgraded in the fork of Deneb to support upgraded types.</p>"},{"location":"specs/deneb/p2p-interface/#topics-and-messages","title":"Topics and messages","text":"<p>Topics follow the same specification as in prior upgrades.</p> <p>The <code>beacon_block</code> topic is modified to also support Deneb blocks and new topics are added per table below.</p> <p>The <code>voluntary_exit</code> topic is implicitly modified despite the lock-in use of <code>CAPELLA_FORK_VERSION</code> for this message signature validation for EIP-7044.</p> <p>The <code>beacon_aggregate_and_proof</code> and <code>beacon_attestation_{subnet_id}</code> topics are modified to support the gossip of attestations created in epoch <code>N</code> to be gossiped through the entire range of slots in epoch <code>N+1</code> rather than only through one epoch of slots for EIP-7045.</p> <p>The specification around the creation, validation, and dissemination of messages has not changed from the Capella document unless explicitly noted here.</p> <p>The derivation of the <code>message-id</code> remains stable.</p> <p>The new topics along with the type of the <code>data</code> field of a gossipsub message are given in this table:</p> Name Message Type <code>blob_sidecar_{subnet_id}</code> <code>BlobSidecar</code> [New in Deneb:EIP4844]"},{"location":"specs/deneb/p2p-interface/#global-topics","title":"Global topics","text":""},{"location":"specs/deneb/p2p-interface/#beacon_block","title":"<code>beacon_block</code>","text":"<p>The type of the payload of this topic changes to the (modified) <code>SignedBeaconBlock</code> found in Deneb.</p> <p>[Modified in Deneb:EIP4844]</p> <p>New validation:</p> <ul> <li>[REJECT] The length of KZG commitments is less than or equal to the limitation defined in Consensus Layer --   i.e. validate that <code>len(body.signed_beacon_block.message.blob_kzg_commitments) &lt;= MAX_BLOBS_PER_BLOCK</code></li> </ul>"},{"location":"specs/deneb/p2p-interface/#beacon_aggregate_and_proof","title":"<code>beacon_aggregate_and_proof</code>","text":"<p>[Modified in Deneb:EIP7045]</p> <p>The following validation is removed: * [IGNORE] <code>aggregate.data.slot</code> is within the last <code>ATTESTATION_PROPAGATION_SLOT_RANGE</code> slots (with a <code>MAXIMUM_GOSSIP_CLOCK_DISPARITY</code> allowance) --   i.e. <code>aggregate.data.slot + ATTESTATION_PROPAGATION_SLOT_RANGE &gt;= current_slot &gt;= aggregate.data.slot</code>   (a client MAY queue future aggregates for processing at the appropriate slot).</p> <p>The following validations are added in its place: * [IGNORE] <code>aggregate.data.slot</code> is equal to or earlier than the <code>current_slot</code> (with a <code>MAXIMUM_GOSSIP_CLOCK_DISPARITY</code> allowance) --   i.e. <code>aggregate.data.slot &lt;= current_slot</code>   (a client MAY queue future aggregates for processing at the appropriate slot). * [IGNORE] the epoch of <code>aggregate.data.slot</code> is either the current or previous epoch   (with a <code>MAXIMUM_GOSSIP_CLOCK_DISPARITY</code> allowance) --   i.e. <code>compute_epoch_at_slot(aggregate.data.slot) in (get_previous_epoch(state), get_current_epoch(state))</code></p>"},{"location":"specs/deneb/p2p-interface/#blob-subnets","title":"Blob subnets","text":""},{"location":"specs/deneb/p2p-interface/#blob_sidecar_subnet_id","title":"<code>blob_sidecar_{subnet_id}</code>","text":"<p>[New in Deneb:EIP4844]</p> <p>This topic is used to propagate blob sidecars, where each blob index maps to some <code>subnet_id</code>.</p> <p>The following validations MUST pass before forwarding the <code>blob_sidecar</code> on the network, assuming the alias <code>block_header = blob_sidecar.signed_block_header.message</code>:</p> <ul> <li>[REJECT] The sidecar's index is consistent with <code>MAX_BLOBS_PER_BLOCK</code> -- i.e. <code>blob_sidecar.index &lt; MAX_BLOBS_PER_BLOCK</code>.</li> <li>[REJECT] The sidecar is for the correct subnet -- i.e. <code>compute_subnet_for_blob_sidecar(blob_sidecar.index) == subnet_id</code>.</li> <li>[IGNORE] The sidecar is not from a future slot (with a <code>MAXIMUM_GOSSIP_CLOCK_DISPARITY</code> allowance) -- i.e. validate that <code>block_header.slot &lt;= current_slot</code> (a client MAY queue future sidecars for processing at the appropriate slot).</li> <li>[IGNORE] The sidecar is from a slot greater than the latest finalized slot -- i.e. validate that <code>block_header.slot &gt; compute_start_slot_at_epoch(store.finalized_checkpoint.epoch)</code></li> <li>[REJECT] The proposer signature of <code>blob_sidecar.signed_block_header</code>, is valid with respect to the <code>block_header.proposer_index</code> pubkey.</li> <li>[IGNORE] The sidecar's block's parent (defined by <code>block_header.parent_root</code>) has been seen (via both gossip and non-gossip sources) (a client MAY queue sidecars for processing once the parent block is retrieved).</li> <li>[REJECT] The sidecar's block's parent (defined by <code>block_header.parent_root</code>) passes validation.</li> <li>[REJECT] The sidecar is from a higher slot than the sidecar's block's parent (defined by <code>block_header.parent_root</code>).</li> <li>[REJECT] The current finalized_checkpoint is an ancestor of the sidecar's block -- i.e. <code>get_checkpoint_block(store, block_header.parent_root, store.finalized_checkpoint.epoch) == store.finalized_checkpoint.root</code>.</li> <li>[REJECT] The sidecar's inclusion proof is valid as verified by <code>verify_blob_sidecar_inclusion_proof(blob_sidecar)</code>.</li> <li>[REJECT] The sidecar's blob is valid as verified by <code>verify_blob_kzg_proof(blob_sidecar.blob, blob_sidecar.kzg_commitment, blob_sidecar.kzg_proof)</code>.</li> <li>[IGNORE] The sidecar is the first sidecar for the tuple <code>(block_header.slot, block_header.proposer_index, blob_sidecar.index)</code> with valid header signature, sidecar inclusion proof, and kzg proof.</li> <li>[REJECT] The sidecar is proposed by the expected <code>proposer_index</code> for the block's slot in the context of the current shuffling (defined by <code>block_header.parent_root</code>/<code>block_header.slot</code>).   If the <code>proposer_index</code> cannot immediately be verified against the expected shuffling, the sidecar MAY be queued for later processing while proposers for the block's branch are calculated -- in such a case do not <code>REJECT</code>, instead <code>IGNORE</code> this message.</li> </ul>"},{"location":"specs/deneb/p2p-interface/#attestation-subnets","title":"Attestation subnets","text":""},{"location":"specs/deneb/p2p-interface/#beacon_attestation_subnet_id","title":"<code>beacon_attestation_{subnet_id}</code>","text":"<p>[Modified in Deneb:EIP7045]</p> <p>The following validation is removed: * [IGNORE] <code>attestation.data.slot</code> is within the last <code>ATTESTATION_PROPAGATION_SLOT_RANGE</code> slots (with a <code>MAXIMUM_GOSSIP_CLOCK_DISPARITY</code> allowance) --   i.e. <code>attestation.data.slot + ATTESTATION_PROPAGATION_SLOT_RANGE &gt;= current_slot &gt;= attestation.data.slot</code>   (a client MAY queue future attestations for processing at the appropriate slot).</p> <p>The following validations are added in its place: * [IGNORE] <code>attestation.data.slot</code> is equal to or earlier than the <code>current_slot</code> (with a <code>MAXIMUM_GOSSIP_CLOCK_DISPARITY</code> allowance) --   i.e. <code>attestation.data.slot &lt;= current_slot</code>   (a client MAY queue future attestation for processing at the appropriate slot). * [IGNORE] the epoch of <code>attestation.data.slot</code> is either the current or previous epoch   (with a <code>MAXIMUM_GOSSIP_CLOCK_DISPARITY</code> allowance) --   i.e. <code>compute_epoch_at_slot(attestation.data.slot) in (get_previous_epoch(state), get_current_epoch(state))</code></p>"},{"location":"specs/deneb/p2p-interface/#transitioning-the-gossip","title":"Transitioning the gossip","text":"<p>See gossip transition details found in the Altair document for details on how to handle transitioning gossip topics for this upgrade.</p>"},{"location":"specs/deneb/p2p-interface/#the-reqresp-domain","title":"The Req/Resp domain","text":""},{"location":"specs/deneb/p2p-interface/#messages","title":"Messages","text":""},{"location":"specs/deneb/p2p-interface/#beaconblocksbyrange-v2","title":"BeaconBlocksByRange v2","text":"<p>Protocol ID: <code>/eth2/beacon_chain/req/beacon_blocks_by_range/2/</code></p> <p>The Deneb fork-digest is introduced to the <code>context</code> enum to specify Deneb beacon block type.</p> <p>Per <code>context = compute_fork_digest(fork_version, genesis_validators_root)</code>:</p> <code>fork_version</code> Chunk SSZ type <code>GENESIS_FORK_VERSION</code> <code>phase0.SignedBeaconBlock</code> <code>ALTAIR_FORK_VERSION</code> <code>altair.SignedBeaconBlock</code> <code>BELLATRIX_FORK_VERSION</code> <code>bellatrix.SignedBeaconBlock</code> <code>CAPELLA_FORK_VERSION</code> <code>capella.SignedBeaconBlock</code> <code>DENEB_FORK_VERSION</code> <code>deneb.SignedBeaconBlock</code> <p>No more than <code>MAX_REQUEST_BLOCKS_DENEB</code> may be requested at a time.</p>"},{"location":"specs/deneb/p2p-interface/#beaconblocksbyroot-v2","title":"BeaconBlocksByRoot v2","text":"<p>Protocol ID: <code>/eth2/beacon_chain/req/beacon_blocks_by_root/2/</code></p> <p>Per <code>context = compute_fork_digest(fork_version, genesis_validators_root)</code>:</p> <code>fork_version</code> Chunk SSZ type <code>GENESIS_FORK_VERSION</code> <code>phase0.SignedBeaconBlock</code> <code>ALTAIR_FORK_VERSION</code> <code>altair.SignedBeaconBlock</code> <code>BELLATRIX_FORK_VERSION</code> <code>bellatrix.SignedBeaconBlock</code> <code>CAPELLA_FORK_VERSION</code> <code>capella.SignedBeaconBlock</code> <code>DENEB_FORK_VERSION</code> <code>deneb.SignedBeaconBlock</code> <p>No more than <code>MAX_REQUEST_BLOCKS_DENEB</code> may be requested at a time.</p> <p>[Modified in Deneb:EIP4844] Clients SHOULD include a block in the response as soon as it passes the gossip validation rules. Clients SHOULD NOT respond with blocks that fail the beacon chain state transition.</p>"},{"location":"specs/deneb/p2p-interface/#blobsidecarsbyroot-v1","title":"BlobSidecarsByRoot v1","text":"<p>Protocol ID: <code>/eth2/beacon_chain/req/blob_sidecars_by_root/1/</code></p> <p>[New in Deneb:EIP4844]</p> <p>The <code>&lt;context-bytes&gt;</code> field is calculated as <code>context = compute_fork_digest(fork_version, genesis_validators_root)</code>:</p> <code>fork_version</code> Chunk SSZ type <code>DENEB_FORK_VERSION</code> <code>deneb.BlobSidecar</code> <p>Request Content:</p> <pre><code>(\n  List[BlobIdentifier, MAX_REQUEST_BLOB_SIDECARS]\n)\n</code></pre> <p>Response Content:</p> <pre><code>(\n  List[BlobSidecar, MAX_REQUEST_BLOB_SIDECARS]\n)\n</code></pre> <p>Requests sidecars by block root and index. The response is a list of <code>BlobSidecar</code> whose length is less than or equal to the number of requests. It may be less in the case that the responding peer is missing blocks or sidecars.</p> <p>Before consuming the next response chunk, the response reader SHOULD verify the blob sidecar is well-formatted, has valid inclusion proof, and is correct w.r.t. the expected KZG commitments through <code>verify_blob_kzg_proof</code>.</p> <p>No more than <code>MAX_REQUEST_BLOB_SIDECARS</code> may be requested at a time.</p> <p><code>BlobSidecarsByRoot</code> is primarily used to recover recent blobs (e.g. when receiving a block with a transaction whose corresponding blob is missing).</p> <p>The response MUST consist of zero or more <code>response_chunk</code>. Each successful <code>response_chunk</code> MUST contain a single <code>BlobSidecar</code> payload.</p> <p>Clients MUST support requesting sidecars since <code>minimum_request_epoch</code>, where <code>minimum_request_epoch = max(finalized_epoch, current_epoch - MIN_EPOCHS_FOR_BLOB_SIDECARS_REQUESTS, DENEB_FORK_EPOCH)</code>. If any root in the request content references a block earlier than <code>minimum_request_epoch</code>, peers MAY respond with error code <code>3: ResourceUnavailable</code> or not include the blob sidecar in the response.</p> <p>Clients MUST respond with at least one sidecar, if they have it. Clients MAY limit the number of blocks and sidecars in the response.</p> <p>Clients SHOULD include a sidecar in the response as soon as it passes the gossip validation rules. Clients SHOULD NOT respond with sidecars related to blocks that fail gossip validation rules. Clients SHOULD NOT respond with sidecars related to blocks that fail the beacon chain state transition</p>"},{"location":"specs/deneb/p2p-interface/#blobsidecarsbyrange-v1","title":"BlobSidecarsByRange v1","text":"<p>Protocol ID: <code>/eth2/beacon_chain/req/blob_sidecars_by_range/1/</code></p> <p>[New in Deneb:EIP4844]</p> <p>The <code>&lt;context-bytes&gt;</code> field is calculated as <code>context = compute_fork_digest(fork_version, genesis_validators_root)</code>:</p> <code>fork_version</code> Chunk SSZ type <code>DENEB_FORK_VERSION</code> <code>deneb.BlobSidecar</code> <p>Request Content: <pre><code>(\n  start_slot: Slot\n  count: uint64\n)\n</code></pre></p> <p>Response Content: <pre><code>(\n  List[BlobSidecar, MAX_REQUEST_BLOB_SIDECARS]\n)\n</code></pre></p> <p>Requests blob sidecars in the slot range <code>[start_slot, start_slot + count)</code>, leading up to the current head block as selected by fork choice.</p> <p>Before consuming the next response chunk, the response reader SHOULD verify the blob sidecar is well-formatted, has valid inclusion proof, and is correct w.r.t. the expected KZG commitments through <code>verify_blob_kzg_proof</code>.</p> <p><code>BlobSidecarsByRange</code> is primarily used to sync blobs that may have been missed on gossip and to sync within the <code>MIN_EPOCHS_FOR_BLOB_SIDECARS_REQUESTS</code> window.</p> <p>The request MUST be encoded as an SSZ-container.</p> <p>The response MUST consist of zero or more <code>response_chunk</code>. Each successful <code>response_chunk</code> MUST contain a single <code>BlobSidecar</code> payload.</p> <p>Let <code>blob_serve_range</code> be <code>[max(current_epoch - MIN_EPOCHS_FOR_BLOB_SIDECARS_REQUESTS, DENEB_FORK_EPOCH), current_epoch]</code>. Clients MUST keep a record of blob sidecars seen on the epoch range <code>blob_serve_range</code> where <code>current_epoch</code> is defined by the current wall-clock time, and clients MUST support serving requests of blobs on this range.</p> <p>Peers that are unable to reply to blob sidecar requests within the range <code>blob_serve_range</code> SHOULD respond with error code <code>3: ResourceUnavailable</code>. Such peers that are unable to successfully reply to this range of requests MAY get descored or disconnected at any time.</p> <p>Note: The above requirement implies that nodes that start from a recent weak subjectivity checkpoint MUST backfill the local blobs database to at least the range <code>blob_serve_range</code> to be fully compliant with <code>BlobSidecarsByRange</code> requests.</p> <p>Note: Although clients that bootstrap from a weak subjectivity checkpoint can begin participating in the networking immediately, other peers MAY disconnect and/or temporarily ban such an un-synced or semi-synced client.</p> <p>Clients MUST respond with at least the blob sidecars of the first blob-carrying block that exists in the range, if they have it, and no more than <code>MAX_REQUEST_BLOB_SIDECARS</code> sidecars.</p> <p>Clients MUST include all blob sidecars of each block from which they include blob sidecars.</p> <p>The following blob sidecars, where they exist, MUST be sent in consecutive <code>(slot, index)</code> order.</p> <p>Slots that do not contain known blobs MUST be skipped, mimicking the behaviour of the <code>BlocksByRange</code> request. Only response chunks with known blobs should therefore be sent.</p> <p>Clients MAY limit the number of blob sidecars in the response.</p> <p>The response MUST contain no more than <code>count * MAX_BLOBS_PER_BLOCK</code> blob sidecars.</p> <p>Clients MUST respond with blob sidecars from their view of the current fork choice -- that is, blob sidecars as included by blocks from the single chain defined by the current head. Of note, blocks from slots before the finalization MUST lead to the finalized block reported in the <code>Status</code> handshake.</p> <p>Clients MUST respond with blob sidecars that are consistent from a single chain within the context of the request.</p> <p>After the initial blob sidecar, clients MAY stop in the process of responding if their fork choice changes the view of the chain in the context of the request.</p>"},{"location":"specs/deneb/p2p-interface/#design-decision-rationale","title":"Design decision rationale","text":""},{"location":"specs/deneb/p2p-interface/#why-are-blobs-relayed-as-a-sidecar-separate-from-beacon-blocks","title":"Why are blobs relayed as a sidecar, separate from beacon blocks?","text":"<p>This \"sidecar\" design provides forward compatibility for further data increases by black-boxing <code>is_data_available()</code>: with full sharding <code>is_data_available()</code> can be replaced by data-availability-sampling (DAS) thus avoiding all blobs being downloaded by all beacon nodes on the network.</p> <p>Such sharding design may introduce an updated <code>BlobSidecar</code> to identify the shard, but does not affect the <code>BeaconBlock</code> structure.</p>"},{"location":"specs/deneb/polynomial-commitments/","title":"Deneb -- Polynomial Commitments","text":""},{"location":"specs/deneb/polynomial-commitments/#table-of-contents","title":"Table of contents","text":"<ul> <li>Introduction</li> <li>Custom types</li> <li>Constants</li> <li>Preset</li> <li>Blob</li> <li>Trusted setup</li> <li>Helper functions</li> <li>Bit-reversal permutation<ul> <li><code>is_power_of_two</code></li> <li><code>reverse_bits</code></li> <li><code>bit_reversal_permutation</code></li> </ul> </li> <li>BLS12-381 helpers<ul> <li><code>multi_exp</code></li> <li><code>hash_to_bls_field</code></li> <li><code>bytes_to_bls_field</code></li> <li><code>bls_field_to_bytes</code></li> <li><code>validate_kzg_g1</code></li> <li><code>bytes_to_kzg_commitment</code></li> <li><code>bytes_to_kzg_proof</code></li> <li><code>blob_to_polynomial</code></li> <li><code>compute_challenge</code></li> <li><code>bls_modular_inverse</code></li> <li><code>div</code></li> <li><code>g1_lincomb</code></li> <li><code>compute_powers</code></li> <li><code>compute_roots_of_unity</code></li> </ul> </li> <li>Polynomials<ul> <li><code>evaluate_polynomial_in_evaluation_form</code></li> </ul> </li> <li>KZG<ul> <li><code>blob_to_kzg_commitment</code></li> <li><code>verify_kzg_proof</code></li> <li><code>verify_kzg_proof_impl</code></li> <li><code>verify_kzg_proof_batch</code></li> <li><code>compute_kzg_proof</code></li> <li><code>compute_quotient_eval_within_domain</code></li> <li><code>compute_kzg_proof_impl</code></li> <li><code>compute_blob_kzg_proof</code></li> <li><code>verify_blob_kzg_proof</code></li> <li><code>verify_blob_kzg_proof_batch</code></li> </ul> </li> </ul>"},{"location":"specs/deneb/polynomial-commitments/#introduction","title":"Introduction","text":"<p>This document specifies basic polynomial operations and KZG polynomial commitment operations that are essential for the implementation of the EIP-4844 feature in the Deneb specification. The implementations are not optimized for performance, but readability. All practical implementations should optimize the polynomial operations.</p> <p>Functions flagged as \"Public method\" MUST be provided by the underlying KZG library as public functions. All other functions are private functions used internally by the KZG library.</p> <p>Public functions MUST accept raw bytes as input and perform the required cryptographic normalization before invoking any internal functions.</p>"},{"location":"specs/deneb/polynomial-commitments/#custom-types","title":"Custom types","text":"Name SSZ equivalent Description <code>G1Point</code> <code>Bytes48</code> <code>G2Point</code> <code>Bytes96</code> <code>BLSFieldElement</code> <code>uint256</code> Validation: <code>x &lt; BLS_MODULUS</code> <code>KZGCommitment</code> <code>Bytes48</code> Validation: Perform BLS standard's \"KeyValidate\" check but do allow the identity point <code>KZGProof</code> <code>Bytes48</code> Same as for <code>KZGCommitment</code> <code>Polynomial</code> <code>Vector[BLSFieldElement, FIELD_ELEMENTS_PER_BLOB]</code> A polynomial in evaluation form <code>Blob</code> <code>ByteVector[BYTES_PER_FIELD_ELEMENT * FIELD_ELEMENTS_PER_BLOB]</code> A basic data blob"},{"location":"specs/deneb/polynomial-commitments/#constants","title":"Constants","text":"Name Value Notes <code>BLS_MODULUS</code> <code>52435875175126190479447740508185965837690552500527637822603658699938581184513</code> Scalar field modulus of BLS12-381 <code>BYTES_PER_COMMITMENT</code> <code>uint64(48)</code> The number of bytes in a KZG commitment <code>BYTES_PER_PROOF</code> <code>uint64(48)</code> The number of bytes in a KZG proof <code>BYTES_PER_FIELD_ELEMENT</code> <code>uint64(32)</code> Bytes used to encode a BLS scalar field element <code>BYTES_PER_BLOB</code> <code>uint64(BYTES_PER_FIELD_ELEMENT * FIELD_ELEMENTS_PER_BLOB)</code> The number of bytes in a blob <code>G1_POINT_AT_INFINITY</code> <code>Bytes48(b'\\xc0' + b'\\x00' * 47)</code> Serialized form of the point at infinity on the G1 group <code>KZG_ENDIANNESS</code> <code>'big'</code> The endianness of the field elements including blobs <code>PRIMITIVE_ROOT_OF_UNITY</code> <code>7</code> The primitive root of unity from which all roots of unity should be derived"},{"location":"specs/deneb/polynomial-commitments/#preset","title":"Preset","text":""},{"location":"specs/deneb/polynomial-commitments/#blob","title":"Blob","text":"Name Value <code>FIELD_ELEMENTS_PER_BLOB</code> <code>uint64(4096)</code> <code>FIAT_SHAMIR_PROTOCOL_DOMAIN</code> <code>b'FSBLOBVERIFY_V1_'</code> <code>RANDOM_CHALLENGE_KZG_BATCH_DOMAIN</code> <code>b'RCKZGBATCH___V1_'</code>"},{"location":"specs/deneb/polynomial-commitments/#trusted-setup","title":"Trusted setup","text":"Name Value <code>KZG_SETUP_G2_LENGTH</code> <code>65</code> <code>KZG_SETUP_G1_MONOMIAL</code> <code>Vector[G1Point, FIELD_ELEMENTS_PER_BLOB]</code> <code>KZG_SETUP_G1_LAGRANGE</code> <code>Vector[G1Point, FIELD_ELEMENTS_PER_BLOB]</code> <code>KZG_SETUP_G2_MONOMIAL</code> <code>Vector[G2Point, KZG_SETUP_G2_LENGTH]</code>"},{"location":"specs/deneb/polynomial-commitments/#helper-functions","title":"Helper functions","text":""},{"location":"specs/deneb/polynomial-commitments/#bit-reversal-permutation","title":"Bit-reversal permutation","text":"<p>All polynomials (which are always given in Lagrange form) should be interpreted as being in bit-reversal permutation. In practice, clients can implement this by storing the lists <code>KZG_SETUP_G1_LAGRANGE</code> and roots of unity in bit-reversal permutation, so these functions only have to be called once at startup.</p>"},{"location":"specs/deneb/polynomial-commitments/#is_power_of_two","title":"<code>is_power_of_two</code>","text":"<pre><code>def is_power_of_two(value: int) -&gt; bool:\n\"\"\"\n    Check if ``value`` is a power of two integer.\n    \"\"\"\nreturn (value &gt; 0) and (value &amp; (value - 1) == 0)\n</code></pre>"},{"location":"specs/deneb/polynomial-commitments/#reverse_bits","title":"<code>reverse_bits</code>","text":"<pre><code>def reverse_bits(n: int, order: int) -&gt; int:\n\"\"\"\n    Reverse the bit order of an integer ``n``.\n    \"\"\"\nassert is_power_of_two(order)\n# Convert n to binary with the same number of bits as \"order\" - 1, then reverse its bit order\nreturn int(('{:0' + str(order.bit_length() - 1) + 'b}').format(n)[::-1], 2)\n</code></pre>"},{"location":"specs/deneb/polynomial-commitments/#bit_reversal_permutation","title":"<code>bit_reversal_permutation</code>","text":"<pre><code>def bit_reversal_permutation(sequence: Sequence[T]) -&gt; Sequence[T]:\n\"\"\"\n    Return a copy with bit-reversed permutation. The permutation is an involution (inverts itself).\n    The input and output are a sequence of generic type ``T`` objects.\n    \"\"\"\nreturn [sequence[reverse_bits(i, len(sequence))] for i in range(len(sequence))]\n</code></pre>"},{"location":"specs/deneb/polynomial-commitments/#bls12-381-helpers","title":"BLS12-381 helpers","text":""},{"location":"specs/deneb/polynomial-commitments/#multi_exp","title":"<code>multi_exp</code>","text":"<p>This function performs a multi-scalar multiplication between <code>points</code> and <code>integers</code>. <code>points</code> can either be in G1 or G2.</p> <pre><code>def multi_exp(points: Sequence[TPoint],\nintegers: Sequence[uint64]) -&gt; Sequence[TPoint]:\n# pylint: disable=unused-argument\n...\n</code></pre>"},{"location":"specs/deneb/polynomial-commitments/#hash_to_bls_field","title":"<code>hash_to_bls_field</code>","text":"<pre><code>def hash_to_bls_field(data: bytes) -&gt; BLSFieldElement:\n\"\"\"\n    Hash ``data`` and convert the output to a BLS scalar field element.\n    The output is not uniform over the BLS field.\n    \"\"\"\nhashed_data = hash(data)\nreturn BLSFieldElement(int.from_bytes(hashed_data, KZG_ENDIANNESS) % BLS_MODULUS)\n</code></pre>"},{"location":"specs/deneb/polynomial-commitments/#bytes_to_bls_field","title":"<code>bytes_to_bls_field</code>","text":"<pre><code>def bytes_to_bls_field(b: Bytes32) -&gt; BLSFieldElement:\n\"\"\"\n    Convert untrusted bytes to a trusted and validated BLS scalar field element.\n    This function does not accept inputs greater than the BLS modulus.\n    \"\"\"\nfield_element = int.from_bytes(b, KZG_ENDIANNESS)\nassert field_element &lt; BLS_MODULUS\nreturn BLSFieldElement(field_element)\n</code></pre>"},{"location":"specs/deneb/polynomial-commitments/#bls_field_to_bytes","title":"<code>bls_field_to_bytes</code>","text":"<pre><code>def bls_field_to_bytes(x: BLSFieldElement) -&gt; Bytes32:\nreturn int.to_bytes(x % BLS_MODULUS, 32, KZG_ENDIANNESS)\n</code></pre>"},{"location":"specs/deneb/polynomial-commitments/#validate_kzg_g1","title":"<code>validate_kzg_g1</code>","text":"<pre><code>def validate_kzg_g1(b: Bytes48) -&gt; None:\n\"\"\"\n    Perform BLS validation required by the types `KZGProof` and `KZGCommitment`.\n    \"\"\"\nif b == G1_POINT_AT_INFINITY:\nreturn\nassert bls.KeyValidate(b)\n</code></pre>"},{"location":"specs/deneb/polynomial-commitments/#bytes_to_kzg_commitment","title":"<code>bytes_to_kzg_commitment</code>","text":"<pre><code>def bytes_to_kzg_commitment(b: Bytes48) -&gt; KZGCommitment:\n\"\"\"\n    Convert untrusted bytes into a trusted and validated KZGCommitment.\n    \"\"\"\nvalidate_kzg_g1(b)\nreturn KZGCommitment(b)\n</code></pre>"},{"location":"specs/deneb/polynomial-commitments/#bytes_to_kzg_proof","title":"<code>bytes_to_kzg_proof</code>","text":"<pre><code>def bytes_to_kzg_proof(b: Bytes48) -&gt; KZGProof:\n\"\"\"\n    Convert untrusted bytes into a trusted and validated KZGProof.\n    \"\"\"\nvalidate_kzg_g1(b)\nreturn KZGProof(b)\n</code></pre>"},{"location":"specs/deneb/polynomial-commitments/#blob_to_polynomial","title":"<code>blob_to_polynomial</code>","text":"<pre><code>def blob_to_polynomial(blob: Blob) -&gt; Polynomial:\n\"\"\"\n    Convert a blob to list of BLS field scalars.\n    \"\"\"\npolynomial = Polynomial()\nfor i in range(FIELD_ELEMENTS_PER_BLOB):\nvalue = bytes_to_bls_field(blob[i * BYTES_PER_FIELD_ELEMENT: (i + 1) * BYTES_PER_FIELD_ELEMENT])\npolynomial[i] = value\nreturn polynomial\n</code></pre>"},{"location":"specs/deneb/polynomial-commitments/#compute_challenge","title":"<code>compute_challenge</code>","text":"<pre><code>def compute_challenge(blob: Blob,\ncommitment: KZGCommitment) -&gt; BLSFieldElement:\n\"\"\"\n    Return the Fiat-Shamir challenge required by the rest of the protocol.\n    \"\"\"\n# Append the degree of the polynomial as a domain separator\ndegree_poly = int.to_bytes(FIELD_ELEMENTS_PER_BLOB, 16, KZG_ENDIANNESS)\ndata = FIAT_SHAMIR_PROTOCOL_DOMAIN + degree_poly\ndata += blob\ndata += commitment\n# Transcript has been prepared: time to create the challenge\nreturn hash_to_bls_field(data)\n</code></pre>"},{"location":"specs/deneb/polynomial-commitments/#bls_modular_inverse","title":"<code>bls_modular_inverse</code>","text":"<pre><code>def bls_modular_inverse(x: BLSFieldElement) -&gt; BLSFieldElement:\n\"\"\"\n    Compute the modular inverse of x (for x != 0)\n    i.e. return y such that x * y % BLS_MODULUS == 1\n    \"\"\"\nassert (int(x) % BLS_MODULUS) != 0\nreturn BLSFieldElement(pow(x, -1, BLS_MODULUS))\n</code></pre>"},{"location":"specs/deneb/polynomial-commitments/#div","title":"<code>div</code>","text":"<pre><code>def div(x: BLSFieldElement, y: BLSFieldElement) -&gt; BLSFieldElement:\n\"\"\"\n    Divide two field elements: ``x`` by `y``.\n    \"\"\"\nreturn BLSFieldElement((int(x) * int(bls_modular_inverse(y))) % BLS_MODULUS)\n</code></pre>"},{"location":"specs/deneb/polynomial-commitments/#g1_lincomb","title":"<code>g1_lincomb</code>","text":"<pre><code>def g1_lincomb(points: Sequence[KZGCommitment], scalars: Sequence[BLSFieldElement]) -&gt; KZGCommitment:\n\"\"\"\n    BLS multiscalar multiplication in G1. This can be naively implemented using double-and-add.\n    \"\"\"\nassert len(points) == len(scalars)\nif len(points) == 0:\nreturn bls.G1_to_bytes48(bls.Z1())\npoints_g1 = []\nfor point in points:\npoints_g1.append(bls.bytes48_to_G1(point))\nresult = bls.multi_exp(points_g1, scalars)\nreturn KZGCommitment(bls.G1_to_bytes48(result))\n</code></pre>"},{"location":"specs/deneb/polynomial-commitments/#compute_powers","title":"<code>compute_powers</code>","text":"<pre><code>def compute_powers(x: BLSFieldElement, n: uint64) -&gt; Sequence[BLSFieldElement]:\n\"\"\"\n    Return ``x`` to power of [0, n-1], if n &gt; 0. When n==0, an empty array is returned.\n    \"\"\"\ncurrent_power = 1\npowers = []\nfor _ in range(n):\npowers.append(BLSFieldElement(current_power))\ncurrent_power = current_power * int(x) % BLS_MODULUS\nreturn powers\n</code></pre>"},{"location":"specs/deneb/polynomial-commitments/#compute_roots_of_unity","title":"<code>compute_roots_of_unity</code>","text":"<pre><code>def compute_roots_of_unity(order: uint64) -&gt; Sequence[BLSFieldElement]:\n\"\"\"\n    Return roots of unity of ``order``.\n    \"\"\"\nassert (BLS_MODULUS - 1) % int(order) == 0\nroot_of_unity = BLSFieldElement(pow(PRIMITIVE_ROOT_OF_UNITY, (BLS_MODULUS - 1) // int(order), BLS_MODULUS))\nreturn compute_powers(root_of_unity, order)\n</code></pre>"},{"location":"specs/deneb/polynomial-commitments/#polynomials","title":"Polynomials","text":""},{"location":"specs/deneb/polynomial-commitments/#evaluate_polynomial_in_evaluation_form","title":"<code>evaluate_polynomial_in_evaluation_form</code>","text":"<pre><code>def evaluate_polynomial_in_evaluation_form(polynomial: Polynomial,\nz: BLSFieldElement) -&gt; BLSFieldElement:\n\"\"\"\n    Evaluate a polynomial (in evaluation form) at an arbitrary point ``z``.\n    - When ``z`` is in the domain, the evaluation can be found by indexing the polynomial at the\n    position that ``z`` is in the domain.\n    - When ``z`` is not in the domain, the barycentric formula is used:\n       f(z) = (z**WIDTH - 1) / WIDTH  *  sum_(i=0)^WIDTH  (f(DOMAIN[i]) * DOMAIN[i]) / (z - DOMAIN[i])\n    \"\"\"\nwidth = len(polynomial)\nassert width == FIELD_ELEMENTS_PER_BLOB\ninverse_width = bls_modular_inverse(BLSFieldElement(width))\nroots_of_unity_brp = bit_reversal_permutation(compute_roots_of_unity(FIELD_ELEMENTS_PER_BLOB))\n# If we are asked to evaluate within the domain, we already know the answer\nif z in roots_of_unity_brp:\neval_index = roots_of_unity_brp.index(z)\nreturn BLSFieldElement(polynomial[eval_index])\nresult = 0\nfor i in range(width):\na = BLSFieldElement(int(polynomial[i]) * int(roots_of_unity_brp[i]) % BLS_MODULUS)\nb = BLSFieldElement((int(BLS_MODULUS) + int(z) - int(roots_of_unity_brp[i])) % BLS_MODULUS)\nresult += int(div(a, b) % BLS_MODULUS)\nresult = result * int(BLS_MODULUS + pow(z, width, BLS_MODULUS) - 1) * int(inverse_width)\nreturn BLSFieldElement(result % BLS_MODULUS)\n</code></pre>"},{"location":"specs/deneb/polynomial-commitments/#kzg","title":"KZG","text":"<p>KZG core functions. These are also defined in Deneb execution specs.</p>"},{"location":"specs/deneb/polynomial-commitments/#blob_to_kzg_commitment","title":"<code>blob_to_kzg_commitment</code>","text":"<pre><code>def blob_to_kzg_commitment(blob: Blob) -&gt; KZGCommitment:\n\"\"\"\n    Public method.\n    \"\"\"\nassert len(blob) == BYTES_PER_BLOB\nreturn g1_lincomb(bit_reversal_permutation(KZG_SETUP_G1_LAGRANGE), blob_to_polynomial(blob))\n</code></pre>"},{"location":"specs/deneb/polynomial-commitments/#verify_kzg_proof","title":"<code>verify_kzg_proof</code>","text":"<pre><code>def verify_kzg_proof(commitment_bytes: Bytes48,\nz_bytes: Bytes32,\ny_bytes: Bytes32,\nproof_bytes: Bytes48) -&gt; bool:\n\"\"\"\n    Verify KZG proof that ``p(z) == y`` where ``p(z)`` is the polynomial represented by ``polynomial_kzg``.\n    Receives inputs as bytes.\n    Public method.\n    \"\"\"\nassert len(commitment_bytes) == BYTES_PER_COMMITMENT\nassert len(z_bytes) == BYTES_PER_FIELD_ELEMENT\nassert len(y_bytes) == BYTES_PER_FIELD_ELEMENT\nassert len(proof_bytes) == BYTES_PER_PROOF\nreturn verify_kzg_proof_impl(bytes_to_kzg_commitment(commitment_bytes),\nbytes_to_bls_field(z_bytes),\nbytes_to_bls_field(y_bytes),\nbytes_to_kzg_proof(proof_bytes))\n</code></pre>"},{"location":"specs/deneb/polynomial-commitments/#verify_kzg_proof_impl","title":"<code>verify_kzg_proof_impl</code>","text":"<pre><code>def verify_kzg_proof_impl(commitment: KZGCommitment,\nz: BLSFieldElement,\ny: BLSFieldElement,\nproof: KZGProof) -&gt; bool:\n\"\"\"\n    Verify KZG proof that ``p(z) == y`` where ``p(z)`` is the polynomial represented by ``polynomial_kzg``.\n    \"\"\"\n# Verify: P - y = Q * (X - z)\nX_minus_z = bls.add(\nbls.bytes96_to_G2(KZG_SETUP_G2_MONOMIAL[1]),\nbls.multiply(bls.G2(), (BLS_MODULUS - z) % BLS_MODULUS),\n)\nP_minus_y = bls.add(bls.bytes48_to_G1(commitment), bls.multiply(bls.G1(), (BLS_MODULUS - y) % BLS_MODULUS))\nreturn bls.pairing_check([\n[P_minus_y, bls.neg(bls.G2())],\n[bls.bytes48_to_G1(proof), X_minus_z]\n])\n</code></pre>"},{"location":"specs/deneb/polynomial-commitments/#verify_kzg_proof_batch","title":"<code>verify_kzg_proof_batch</code>","text":"<pre><code>def verify_kzg_proof_batch(commitments: Sequence[KZGCommitment],\nzs: Sequence[BLSFieldElement],\nys: Sequence[BLSFieldElement],\nproofs: Sequence[KZGProof]) -&gt; bool:\n\"\"\"\n    Verify multiple KZG proofs efficiently.\n    \"\"\"\nassert len(commitments) == len(zs) == len(ys) == len(proofs)\n# Compute a random challenge. Note that it does not have to be computed from a hash,\n# r just has to be random.\ndegree_poly = int.to_bytes(FIELD_ELEMENTS_PER_BLOB, 8, KZG_ENDIANNESS)\nnum_commitments = int.to_bytes(len(commitments), 8, KZG_ENDIANNESS)\ndata = RANDOM_CHALLENGE_KZG_BATCH_DOMAIN + degree_poly + num_commitments\n# Append all inputs to the transcript before we hash\nfor commitment, z, y, proof in zip(commitments, zs, ys, proofs):\ndata += commitment \\\n            + int.to_bytes(z, BYTES_PER_FIELD_ELEMENT, KZG_ENDIANNESS) \\\n            + int.to_bytes(y, BYTES_PER_FIELD_ELEMENT, KZG_ENDIANNESS) \\\n            + proof\nr = hash_to_bls_field(data)\nr_powers = compute_powers(r, len(commitments))\n# Verify: e(sum r^i proof_i, [s]) ==\n# e(sum r^i (commitment_i - [y_i]) + sum r^i z_i proof_i, [1])\nproof_lincomb = g1_lincomb(proofs, r_powers)\nproof_z_lincomb = g1_lincomb(\nproofs,\n[BLSFieldElement((int(z) * int(r_power)) % BLS_MODULUS) for z, r_power in zip(zs, r_powers)],\n)\nC_minus_ys = [bls.add(bls.bytes48_to_G1(commitment), bls.multiply(bls.G1(), (BLS_MODULUS - y) % BLS_MODULUS))\nfor commitment, y in zip(commitments, ys)]\nC_minus_y_as_KZGCommitments = [KZGCommitment(bls.G1_to_bytes48(x)) for x in C_minus_ys]\nC_minus_y_lincomb = g1_lincomb(C_minus_y_as_KZGCommitments, r_powers)\nreturn bls.pairing_check([\n[bls.bytes48_to_G1(proof_lincomb), bls.neg(bls.bytes96_to_G2(KZG_SETUP_G2_MONOMIAL[1]))],\n[bls.add(bls.bytes48_to_G1(C_minus_y_lincomb), bls.bytes48_to_G1(proof_z_lincomb)), bls.G2()]\n])\n</code></pre>"},{"location":"specs/deneb/polynomial-commitments/#compute_kzg_proof","title":"<code>compute_kzg_proof</code>","text":"<pre><code>def compute_kzg_proof(blob: Blob, z_bytes: Bytes32) -&gt; Tuple[KZGProof, Bytes32]:\n\"\"\"\n    Compute KZG proof at point `z` for the polynomial represented by `blob`.\n    Do this by computing the quotient polynomial in evaluation form: q(x) = (p(x) - p(z)) / (x - z).\n    Public method.\n    \"\"\"\nassert len(blob) == BYTES_PER_BLOB\nassert len(z_bytes) == BYTES_PER_FIELD_ELEMENT\npolynomial = blob_to_polynomial(blob)\nproof, y = compute_kzg_proof_impl(polynomial, bytes_to_bls_field(z_bytes))\nreturn proof, y.to_bytes(BYTES_PER_FIELD_ELEMENT, KZG_ENDIANNESS)\n</code></pre>"},{"location":"specs/deneb/polynomial-commitments/#compute_quotient_eval_within_domain","title":"<code>compute_quotient_eval_within_domain</code>","text":"<pre><code>def compute_quotient_eval_within_domain(z: BLSFieldElement,\npolynomial: Polynomial,\ny: BLSFieldElement\n) -&gt; BLSFieldElement:\n\"\"\"\n    Given `y == p(z)` for a polynomial `p(x)`, compute `q(z)`: the KZG quotient polynomial evaluated at `z` for the\n    special case where `z` is in roots of unity.\n    For more details, read https://dankradfeist.de/ethereum/2021/06/18/pcs-multiproofs.html section \"Dividing\n    when one of the points is zero\". The code below computes q(x_m) for the roots of unity special case.\n    \"\"\"\nroots_of_unity_brp = bit_reversal_permutation(compute_roots_of_unity(FIELD_ELEMENTS_PER_BLOB))\nresult = 0\nfor i, omega_i in enumerate(roots_of_unity_brp):\nif omega_i == z:  # skip the evaluation point in the sum\ncontinue\nf_i = int(BLS_MODULUS) + int(polynomial[i]) - int(y) % BLS_MODULUS\nnumerator = f_i * int(omega_i) % BLS_MODULUS\ndenominator = int(z) * (int(BLS_MODULUS) + int(z) - int(omega_i)) % BLS_MODULUS\nresult += int(div(BLSFieldElement(numerator), BLSFieldElement(denominator)))\nreturn BLSFieldElement(result % BLS_MODULUS)\n</code></pre>"},{"location":"specs/deneb/polynomial-commitments/#compute_kzg_proof_impl","title":"<code>compute_kzg_proof_impl</code>","text":"<pre><code>def compute_kzg_proof_impl(polynomial: Polynomial, z: BLSFieldElement) -&gt; Tuple[KZGProof, BLSFieldElement]:\n\"\"\"\n    Helper function for `compute_kzg_proof()` and `compute_blob_kzg_proof()`.\n    \"\"\"\nroots_of_unity_brp = bit_reversal_permutation(compute_roots_of_unity(FIELD_ELEMENTS_PER_BLOB))\n# For all x_i, compute p(x_i) - p(z)\ny = evaluate_polynomial_in_evaluation_form(polynomial, z)\npolynomial_shifted = [BLSFieldElement((int(p) - int(y)) % BLS_MODULUS) for p in polynomial]\n# For all x_i, compute (x_i - z)\ndenominator_poly = [BLSFieldElement((int(x) - int(z)) % BLS_MODULUS)\nfor x in roots_of_unity_brp]\n# Compute the quotient polynomial directly in evaluation form\nquotient_polynomial = [BLSFieldElement(0)] * FIELD_ELEMENTS_PER_BLOB\nfor i, (a, b) in enumerate(zip(polynomial_shifted, denominator_poly)):\nif b == 0:\n# The denominator is zero hence `z` is a root of unity: we must handle it as a special case\nquotient_polynomial[i] = compute_quotient_eval_within_domain(roots_of_unity_brp[i], polynomial, y)\nelse:\n# Compute: q(x_i) = (p(x_i) - p(z)) / (x_i - z).\nquotient_polynomial[i] = div(a, b)\nreturn KZGProof(g1_lincomb(bit_reversal_permutation(KZG_SETUP_G1_LAGRANGE), quotient_polynomial)), y\n</code></pre>"},{"location":"specs/deneb/polynomial-commitments/#compute_blob_kzg_proof","title":"<code>compute_blob_kzg_proof</code>","text":"<pre><code>def compute_blob_kzg_proof(blob: Blob, commitment_bytes: Bytes48) -&gt; KZGProof:\n\"\"\"\n    Given a blob, return the KZG proof that is used to verify it against the commitment.\n    This method does not verify that the commitment is correct with respect to `blob`.\n    Public method.\n    \"\"\"\nassert len(blob) == BYTES_PER_BLOB\nassert len(commitment_bytes) == BYTES_PER_COMMITMENT\ncommitment = bytes_to_kzg_commitment(commitment_bytes)\npolynomial = blob_to_polynomial(blob)\nevaluation_challenge = compute_challenge(blob, commitment)\nproof, _ = compute_kzg_proof_impl(polynomial, evaluation_challenge)\nreturn proof\n</code></pre>"},{"location":"specs/deneb/polynomial-commitments/#verify_blob_kzg_proof","title":"<code>verify_blob_kzg_proof</code>","text":"<pre><code>def verify_blob_kzg_proof(blob: Blob,\ncommitment_bytes: Bytes48,\nproof_bytes: Bytes48) -&gt; bool:\n\"\"\"\n    Given a blob and a KZG proof, verify that the blob data corresponds to the provided commitment.\n    Public method.\n    \"\"\"\nassert len(blob) == BYTES_PER_BLOB\nassert len(commitment_bytes) == BYTES_PER_COMMITMENT\nassert len(proof_bytes) == BYTES_PER_PROOF\ncommitment = bytes_to_kzg_commitment(commitment_bytes)\npolynomial = blob_to_polynomial(blob)\nevaluation_challenge = compute_challenge(blob, commitment)\n# Evaluate polynomial at `evaluation_challenge`\ny = evaluate_polynomial_in_evaluation_form(polynomial, evaluation_challenge)\n# Verify proof\nproof = bytes_to_kzg_proof(proof_bytes)\nreturn verify_kzg_proof_impl(commitment, evaluation_challenge, y, proof)\n</code></pre>"},{"location":"specs/deneb/polynomial-commitments/#verify_blob_kzg_proof_batch","title":"<code>verify_blob_kzg_proof_batch</code>","text":"<pre><code>def verify_blob_kzg_proof_batch(blobs: Sequence[Blob],\ncommitments_bytes: Sequence[Bytes48],\nproofs_bytes: Sequence[Bytes48]) -&gt; bool:\n\"\"\"\n    Given a list of blobs and blob KZG proofs, verify that they correspond to the provided commitments.\n    Will return True if there are zero blobs/commitments/proofs.\n    Public method.\n    \"\"\"\nassert len(blobs) == len(commitments_bytes) == len(proofs_bytes)\ncommitments, evaluation_challenges, ys, proofs = [], [], [], []\nfor blob, commitment_bytes, proof_bytes in zip(blobs, commitments_bytes, proofs_bytes):\nassert len(blob) == BYTES_PER_BLOB\nassert len(commitment_bytes) == BYTES_PER_COMMITMENT\nassert len(proof_bytes) == BYTES_PER_PROOF\ncommitment = bytes_to_kzg_commitment(commitment_bytes)\ncommitments.append(commitment)\npolynomial = blob_to_polynomial(blob)\nevaluation_challenge = compute_challenge(blob, commitment)\nevaluation_challenges.append(evaluation_challenge)\nys.append(evaluate_polynomial_in_evaluation_form(polynomial, evaluation_challenge))\nproofs.append(bytes_to_kzg_proof(proof_bytes))\nreturn verify_kzg_proof_batch(commitments, evaluation_challenges, ys, proofs)\n</code></pre>"},{"location":"specs/deneb/validator/","title":"Deneb -- Honest Validator","text":""},{"location":"specs/deneb/validator/#table-of-contents","title":"Table of contents","text":"<ul> <li>Introduction</li> <li>Prerequisites</li> <li>Helpers</li> <li><code>BlobsBundle</code></li> <li>Modified <code>GetPayloadResponse</code></li> <li>Protocol</li> <li><code>ExecutionEngine</code><ul> <li>Modified <code>get_payload</code></li> </ul> </li> <li>Beacon chain responsibilities</li> <li>Block and sidecar proposal<ul> <li>Constructing the <code>BeaconBlockBody</code></li> <li>ExecutionPayload</li> <li>Blob KZG commitments</li> <li>Constructing the <code>BlobSidecar</code>s</li> <li>Sidecar</li> </ul> </li> </ul>"},{"location":"specs/deneb/validator/#introduction","title":"Introduction","text":"<p>This document represents the changes to be made in the code of an \"honest validator\" to implement Deneb.</p>"},{"location":"specs/deneb/validator/#prerequisites","title":"Prerequisites","text":"<p>This document is an extension of the Capella -- Honest Validator guide. All behaviors and definitions defined in this document, and documents it extends, carry over unless explicitly noted or overridden.</p> <p>All terminology, constants, functions, and protocol mechanics defined in the updated Beacon Chain doc of Deneb are requisite for this document and used throughout. Please see related Beacon Chain doc before continuing and use them as a reference throughout.</p>"},{"location":"specs/deneb/validator/#helpers","title":"Helpers","text":""},{"location":"specs/deneb/validator/#blobsbundle","title":"<code>BlobsBundle</code>","text":"<p>[New in Deneb:EIP4844]</p> <pre><code>@dataclass\nclass BlobsBundle(object):\ncommitments: Sequence[KZGCommitment]\nproofs: Sequence[KZGProof]\nblobs: Sequence[Blob]\n</code></pre>"},{"location":"specs/deneb/validator/#modified-getpayloadresponse","title":"Modified <code>GetPayloadResponse</code>","text":"<pre><code>@dataclass\nclass GetPayloadResponse(object):\nexecution_payload: ExecutionPayload\nblock_value: uint256\nblobs_bundle: BlobsBundle  # [New in Deneb:EIP4844]\n</code></pre> <pre><code>def compute_signed_block_header(signed_block: SignedBeaconBlock) -&gt; SignedBeaconBlockHeader:\nblock = signed_block.message\nblock_header = BeaconBlockHeader(\nslot=block.slot,\nproposer_index=block.proposer_index,\nparent_root=block.parent_root,\nstate_root=block.state_root,\nbody_root=hash_tree_root(block.body),\n)\nreturn SignedBeaconBlockHeader(message=block_header, signature=signed_block.signature)\n</code></pre>"},{"location":"specs/deneb/validator/#protocol","title":"Protocol","text":""},{"location":"specs/deneb/validator/#executionengine","title":"<code>ExecutionEngine</code>","text":""},{"location":"specs/deneb/validator/#modified-get_payload","title":"Modified <code>get_payload</code>","text":"<p>Given the <code>payload_id</code>, <code>get_payload</code> returns the most recent version of the execution payload that has been built since the corresponding call to <code>notify_forkchoice_updated</code> method.</p> <pre><code>def get_payload(self: ExecutionEngine, payload_id: PayloadId) -&gt; GetPayloadResponse:\n\"\"\"\n    Return ExecutionPayload, uint256, BlobsBundle objects.\n    \"\"\"\n# pylint: disable=unused-argument\n...\n</code></pre>"},{"location":"specs/deneb/validator/#beacon-chain-responsibilities","title":"Beacon chain responsibilities","text":"<p>All validator responsibilities remain unchanged other than those noted below.</p>"},{"location":"specs/deneb/validator/#block-and-sidecar-proposal","title":"Block and sidecar proposal","text":""},{"location":"specs/deneb/validator/#constructing-the-beaconblockbody","title":"Constructing the <code>BeaconBlockBody</code>","text":""},{"location":"specs/deneb/validator/#executionpayload","title":"ExecutionPayload","text":"<p><code>prepare_execution_payload</code> is updated from the Capella specs to provide the parent beacon block root.</p> <p>Note: In this section, <code>state</code> is the state of the slot for the block proposal without the block yet applied. That is, <code>state</code> is the <code>previous_state</code> processed through any empty slots up to the assigned slot using <code>process_slots(previous_state, slot)</code>.</p> <p>Note: The only change made to <code>prepare_execution_payload</code> is to add the parent beacon block root as an additional parameter to the <code>PayloadAttributes</code>.</p> <pre><code>def prepare_execution_payload(state: BeaconState,\nsafe_block_hash: Hash32,\nfinalized_block_hash: Hash32,\nsuggested_fee_recipient: ExecutionAddress,\nexecution_engine: ExecutionEngine) -&gt; Optional[PayloadId]:\n# Verify consistency of the parent hash with respect to the previous execution payload header\nparent_hash = state.latest_execution_payload_header.block_hash\n# Set the forkchoice head and initiate the payload build process\npayload_attributes = PayloadAttributes(\ntimestamp=compute_timestamp_at_slot(state, state.slot),\nprev_randao=get_randao_mix(state, get_current_epoch(state)),\nsuggested_fee_recipient=suggested_fee_recipient,\nwithdrawals=get_expected_withdrawals(state),\nparent_beacon_block_root=hash_tree_root(state.latest_block_header),  # [New in Deneb:EIP4788]\n)\nreturn execution_engine.notify_forkchoice_updated(\nhead_block_hash=parent_hash,\nsafe_block_hash=safe_block_hash,\nfinalized_block_hash=finalized_block_hash,\npayload_attributes=payload_attributes,\n)\n</code></pre>"},{"location":"specs/deneb/validator/#blob-kzg-commitments","title":"Blob KZG commitments","text":"<p>[New in Deneb:EIP4844]</p> <ol> <li>The execution payload is obtained from the execution engine as defined above using <code>payload_id</code>. The response also includes a <code>blobs_bundle</code> entry containing the corresponding <code>blobs</code>, <code>commitments</code>, and <code>proofs</code>.</li> <li>Set <code>block.body.blob_kzg_commitments = commitments</code>.</li> </ol>"},{"location":"specs/deneb/validator/#constructing-the-blobsidecars","title":"Constructing the <code>BlobSidecar</code>s","text":"<p>[New in Deneb:EIP4844]</p> <p>To construct a <code>BlobSidecar</code>, a <code>blob_sidecar</code> is defined with the necessary context for block and sidecar proposal.</p>"},{"location":"specs/deneb/validator/#sidecar","title":"Sidecar","text":"<p>Blobs associated with a block are packaged into sidecar objects for distribution to the associated sidecar topic, the <code>blob_sidecar_{subnet_id}</code> pubsub topic.</p> <p>Each <code>sidecar</code> is obtained from: <pre><code>def get_blob_sidecars(signed_block: SignedBeaconBlock,\nblobs: Sequence[Blob],\nblob_kzg_proofs: Sequence[KZGProof]) -&gt; Sequence[BlobSidecar]:\nblock = signed_block.message\nsigned_block_header = compute_signed_block_header(signed_block)\nreturn [\nBlobSidecar(\nindex=index,\nblob=blob,\nkzg_commitment=block.body.blob_kzg_commitments[index],\nkzg_proof=blob_kzg_proofs[index],\nsigned_block_header=signed_block_header,\nkzg_commitment_inclusion_proof=compute_merkle_proof(\nblock.body,\nget_generalized_index(BeaconBlockBody, 'blob_kzg_commitments', index),\n),\n)\nfor index, blob in enumerate(blobs)\n]\n</code></pre></p> <p>The <code>subnet_id</code> for the <code>blob_sidecar</code> is calculated with: - Let <code>blob_index = blob_sidecar.index</code>. - Let <code>subnet_id = compute_subnet_for_blob_sidecar(blob_index)</code>.</p> <pre><code>def compute_subnet_for_blob_sidecar(blob_index: BlobIndex) -&gt; SubnetID:\nreturn SubnetID(blob_index % BLOB_SIDECAR_SUBNET_COUNT)\n</code></pre> <p>After publishing the peers on the network may request the sidecar through sync-requests, or a local user may be interested.</p> <p>The validator MUST hold on to sidecars for <code>MIN_EPOCHS_FOR_BLOB_SIDECARS_REQUESTS</code> epochs and serve when capable, to ensure the data-availability of these blobs throughout the network.</p> <p>After <code>MIN_EPOCHS_FOR_BLOB_SIDECARS_REQUESTS</code> nodes MAY prune the sidecars and/or stop serving them.</p>"},{"location":"specs/deneb/light-client/fork/","title":"Deneb Light Client -- Fork Logic","text":""},{"location":"specs/deneb/light-client/fork/#table-of-contents","title":"Table of contents","text":"<ul> <li>Introduction</li> <li>Upgrading light client data</li> <li>Upgrading the store</li> </ul>"},{"location":"specs/deneb/light-client/fork/#introduction","title":"Introduction","text":"<p>This document describes how to upgrade existing light client objects based on the Capella specification to Deneb. This is necessary when processing pre-Deneb data with a post-Deneb <code>LightClientStore</code>. Note that the data being exchanged over the network protocols uses the original format.</p>"},{"location":"specs/deneb/light-client/fork/#upgrading-light-client-data","title":"Upgrading light client data","text":"<p>A Deneb <code>LightClientStore</code> can still process earlier light client data. In order to do so, that pre-Deneb data needs to be locally upgraded to Deneb before processing.</p> <pre><code>def upgrade_lc_header_to_deneb(pre: capella.LightClientHeader) -&gt; LightClientHeader:\nreturn LightClientHeader(\nbeacon=pre.beacon,\nexecution=ExecutionPayloadHeader(\nparent_hash=pre.execution.parent_hash,\nfee_recipient=pre.execution.fee_recipient,\nstate_root=pre.execution.state_root,\nreceipts_root=pre.execution.receipts_root,\nlogs_bloom=pre.execution.logs_bloom,\nprev_randao=pre.execution.prev_randao,\nblock_number=pre.execution.block_number,\ngas_limit=pre.execution.gas_limit,\ngas_used=pre.execution.gas_used,\ntimestamp=pre.execution.timestamp,\nextra_data=pre.execution.extra_data,\nbase_fee_per_gas=pre.execution.base_fee_per_gas,\nblock_hash=pre.execution.block_hash,\ntransactions_root=pre.execution.transactions_root,\nwithdrawals_root=pre.execution.withdrawals_root,\nblob_gas_used=uint64(0),  # [New in Deneb:EIP4844]\nexcess_blob_gas=uint64(0),  # [New in Deneb:EIP4844]\n),\nexecution_branch=pre.execution_branch,\n)\n</code></pre> <pre><code>def upgrade_lc_bootstrap_to_deneb(pre: capella.LightClientBootstrap) -&gt; LightClientBootstrap:\nreturn LightClientBootstrap(\nheader=upgrade_lc_header_to_deneb(pre.header),\ncurrent_sync_committee=pre.current_sync_committee,\ncurrent_sync_committee_branch=pre.current_sync_committee_branch,\n)\n</code></pre> <pre><code>def upgrade_lc_update_to_deneb(pre: capella.LightClientUpdate) -&gt; LightClientUpdate:\nreturn LightClientUpdate(\nattested_header=upgrade_lc_header_to_deneb(pre.attested_header),\nnext_sync_committee=pre.next_sync_committee,\nnext_sync_committee_branch=pre.next_sync_committee_branch,\nfinalized_header=upgrade_lc_header_to_deneb(pre.finalized_header),\nfinality_branch=pre.finality_branch,\nsync_aggregate=pre.sync_aggregate,\nsignature_slot=pre.signature_slot,\n)\n</code></pre> <pre><code>def upgrade_lc_finality_update_to_deneb(pre: capella.LightClientFinalityUpdate) -&gt; LightClientFinalityUpdate:\nreturn LightClientFinalityUpdate(\nattested_header=upgrade_lc_header_to_deneb(pre.attested_header),\nfinalized_header=upgrade_lc_header_to_deneb(pre.finalized_header),\nfinality_branch=pre.finality_branch,\nsync_aggregate=pre.sync_aggregate,\nsignature_slot=pre.signature_slot,\n)\n</code></pre> <pre><code>def upgrade_lc_optimistic_update_to_deneb(pre: capella.LightClientOptimisticUpdate) -&gt; LightClientOptimisticUpdate:\nreturn LightClientOptimisticUpdate(\nattested_header=upgrade_lc_header_to_deneb(pre.attested_header),\nsync_aggregate=pre.sync_aggregate,\nsignature_slot=pre.signature_slot,\n)\n</code></pre>"},{"location":"specs/deneb/light-client/fork/#upgrading-the-store","title":"Upgrading the store","text":"<p>Existing <code>LightClientStore</code> objects based on Capella MUST be upgraded to Deneb before Deneb based light client data can be processed. The <code>LightClientStore</code> upgrade MAY be performed before <code>DENEB_FORK_EPOCH</code>.</p> <pre><code>def upgrade_lc_store_to_deneb(pre: capella.LightClientStore) -&gt; LightClientStore:\nif pre.best_valid_update is None:\nbest_valid_update = None\nelse:\nbest_valid_update = upgrade_lc_update_to_deneb(pre.best_valid_update)\nreturn LightClientStore(\nfinalized_header=upgrade_lc_header_to_deneb(pre.finalized_header),\ncurrent_sync_committee=pre.current_sync_committee,\nnext_sync_committee=pre.next_sync_committee,\nbest_valid_update=best_valid_update,\noptimistic_header=upgrade_lc_header_to_deneb(pre.optimistic_header),\nprevious_max_active_participants=pre.previous_max_active_participants,\ncurrent_max_active_participants=pre.current_max_active_participants,\n)\n</code></pre>"},{"location":"specs/deneb/light-client/full-node/","title":"Deneb Light Client -- Full Node","text":"<p>Notice: This document is a work-in-progress for researchers and implementers.</p>"},{"location":"specs/deneb/light-client/full-node/#table-of-contents","title":"Table of contents","text":"<ul> <li>Introduction</li> <li>Helper functions</li> <li>Modified <code>block_to_light_client_header</code></li> </ul>"},{"location":"specs/deneb/light-client/full-node/#introduction","title":"Introduction","text":"<p>This upgrade adds information about the execution payload to light client data as part of the Deneb upgrade.</p>"},{"location":"specs/deneb/light-client/full-node/#helper-functions","title":"Helper functions","text":""},{"location":"specs/deneb/light-client/full-node/#modified-block_to_light_client_header","title":"Modified <code>block_to_light_client_header</code>","text":"<pre><code>def block_to_light_client_header(block: SignedBeaconBlock) -&gt; LightClientHeader:\nepoch = compute_epoch_at_slot(block.message.slot)\nif epoch &gt;= CAPELLA_FORK_EPOCH:\npayload = block.message.body.execution_payload\nexecution_header = ExecutionPayloadHeader(\nparent_hash=payload.parent_hash,\nfee_recipient=payload.fee_recipient,\nstate_root=payload.state_root,\nreceipts_root=payload.receipts_root,\nlogs_bloom=payload.logs_bloom,\nprev_randao=payload.prev_randao,\nblock_number=payload.block_number,\ngas_limit=payload.gas_limit,\ngas_used=payload.gas_used,\ntimestamp=payload.timestamp,\nextra_data=payload.extra_data,\nbase_fee_per_gas=payload.base_fee_per_gas,\nblock_hash=payload.block_hash,\ntransactions_root=hash_tree_root(payload.transactions),\nwithdrawals_root=hash_tree_root(payload.withdrawals),\n)\n# [New in Deneb:EIP4844]\nif epoch &gt;= DENEB_FORK_EPOCH:\nexecution_header.blob_gas_used = payload.blob_gas_used\nexecution_header.excess_blob_gas = payload.excess_blob_gas\nexecution_branch = ExecutionBranch(\ncompute_merkle_proof(block.message.body, EXECUTION_PAYLOAD_GINDEX))\nelse:\n# Note that during fork transitions, `finalized_header` may still point to earlier forks.\n# While Bellatrix blocks also contain an `ExecutionPayload` (minus `withdrawals_root`),\n# it was not included in the corresponding light client data. To ensure compatibility\n# with legacy data going through `upgrade_lc_header_to_capella`, leave out execution data.\nexecution_header = ExecutionPayloadHeader()\nexecution_branch = ExecutionBranch()\nreturn LightClientHeader(\nbeacon=BeaconBlockHeader(\nslot=block.message.slot,\nproposer_index=block.message.proposer_index,\nparent_root=block.message.parent_root,\nstate_root=block.message.state_root,\nbody_root=hash_tree_root(block.message.body),\n),\nexecution=execution_header,\nexecution_branch=execution_branch,\n)\n</code></pre>"},{"location":"specs/deneb/light-client/p2p-interface/","title":"Deneb Light Client -- Networking","text":"<p>Notice: This document is a work-in-progress for researchers and implementers.</p>"},{"location":"specs/deneb/light-client/p2p-interface/#table-of-contents","title":"Table of contents","text":"<ul> <li>Networking</li> <li>The gossip domain: gossipsub<ul> <li>Topics and messages</li> <li>Global topics<ul> <li><code>light_client_finality_update</code></li> <li><code>light_client_optimistic_update</code></li> </ul> </li> </ul> </li> <li>The Req/Resp domain<ul> <li>Messages</li> <li>GetLightClientBootstrap</li> <li>LightClientUpdatesByRange</li> <li>GetLightClientFinalityUpdate</li> <li>GetLightClientOptimisticUpdate</li> </ul> </li> </ul>"},{"location":"specs/deneb/light-client/p2p-interface/#networking","title":"Networking","text":"<p>The Capella light client networking specification is extended to exchange Deneb light client data.</p>"},{"location":"specs/deneb/light-client/p2p-interface/#the-gossip-domain-gossipsub","title":"The gossip domain: gossipsub","text":""},{"location":"specs/deneb/light-client/p2p-interface/#topics-and-messages","title":"Topics and messages","text":""},{"location":"specs/deneb/light-client/p2p-interface/#global-topics","title":"Global topics","text":""},{"location":"specs/deneb/light-client/p2p-interface/#light_client_finality_update","title":"<code>light_client_finality_update</code>","text":"<code>fork_version</code> Message SSZ type <code>GENESIS_FORK_VERSION</code> n/a <code>ALTAIR_FORK_VERSION</code> through <code>BELLATRIX_FORK_VERSION</code> <code>altair.LightClientFinalityUpdate</code> <code>CAPELLA_FORK_VERSION</code> <code>capella.LightClientFinalityUpdate</code> <code>DENEB_FORK_VERSION</code> and later <code>deneb.LightClientFinalityUpdate</code>"},{"location":"specs/deneb/light-client/p2p-interface/#light_client_optimistic_update","title":"<code>light_client_optimistic_update</code>","text":"<code>fork_version</code> Message SSZ type <code>GENESIS_FORK_VERSION</code> n/a <code>ALTAIR_FORK_VERSION</code> through <code>BELLATRIX_FORK_VERSION</code> <code>altair.LightClientOptimisticUpdate</code> <code>CAPELLA_FORK_VERSION</code> <code>capella.LightClientOptimisticUpdate</code> <code>DENEB_FORK_VERSION</code> and later <code>deneb.LightClientOptimisticUpdate</code>"},{"location":"specs/deneb/light-client/p2p-interface/#the-reqresp-domain","title":"The Req/Resp domain","text":""},{"location":"specs/deneb/light-client/p2p-interface/#messages","title":"Messages","text":""},{"location":"specs/deneb/light-client/p2p-interface/#getlightclientbootstrap","title":"GetLightClientBootstrap","text":"<code>fork_version</code> Response SSZ type <code>GENESIS_FORK_VERSION</code> n/a <code>ALTAIR_FORK_VERSION</code> through <code>BELLATRIX_FORK_VERSION</code> <code>altair.LightClientBootstrap</code> <code>CAPELLA_FORK_VERSION</code> <code>capella.LightClientBootstrap</code> <code>DENEB_FORK_VERSION</code> and later <code>deneb.LightClientBootstrap</code>"},{"location":"specs/deneb/light-client/p2p-interface/#lightclientupdatesbyrange","title":"LightClientUpdatesByRange","text":"<code>fork_version</code> Response chunk SSZ type <code>GENESIS_FORK_VERSION</code> n/a <code>ALTAIR_FORK_VERSION</code> through <code>BELLATRIX_FORK_VERSION</code> <code>altair.LightClientUpdate</code> <code>CAPELLA_FORK_VERSION</code> <code>capella.LightClientUpdate</code> <code>DENEB_FORK_VERSION</code> and later <code>deneb.LightClientUpdate</code>"},{"location":"specs/deneb/light-client/p2p-interface/#getlightclientfinalityupdate","title":"GetLightClientFinalityUpdate","text":"<code>fork_version</code> Response SSZ type <code>GENESIS_FORK_VERSION</code> n/a <code>ALTAIR_FORK_VERSION</code> through <code>BELLATRIX_FORK_VERSION</code> <code>altair.LightClientFinalityUpdate</code> <code>CAPELLA_FORK_VERSION</code> <code>capella.LightClientFinalityUpdate</code> <code>DENEB_FORK_VERSION</code> and later <code>deneb.LightClientFinalityUpdate</code>"},{"location":"specs/deneb/light-client/p2p-interface/#getlightclientoptimisticupdate","title":"GetLightClientOptimisticUpdate","text":"<code>fork_version</code> Response SSZ type <code>GENESIS_FORK_VERSION</code> n/a <code>ALTAIR_FORK_VERSION</code> through <code>BELLATRIX_FORK_VERSION</code> <code>altair.LightClientOptimisticUpdate</code> <code>CAPELLA_FORK_VERSION</code> <code>capella.LightClientOptimisticUpdate</code> <code>DENEB_FORK_VERSION</code> and later <code>deneb.LightClientOptimisticUpdate</code>"},{"location":"specs/deneb/light-client/sync-protocol/","title":"Deneb Light Client -- Sync Protocol","text":"<p>Notice: This document is a work-in-progress for researchers and implementers.</p>"},{"location":"specs/deneb/light-client/sync-protocol/#table-of-contents","title":"Table of contents","text":"<ul> <li>Introduction</li> <li>Helper functions</li> <li>Modified <code>get_lc_execution_root</code></li> <li>Modified <code>is_valid_light_client_header</code></li> </ul>"},{"location":"specs/deneb/light-client/sync-protocol/#introduction","title":"Introduction","text":"<p>This upgrade updates light client data to include the Deneb changes to the <code>ExecutionPayload</code> structure. It extends the Capella Light Client specifications. The fork document explains how to upgrade existing Capella based deployments to Deneb.</p> <p>Additional documents describes the impact of the upgrade on certain roles: - Full node - Networking</p>"},{"location":"specs/deneb/light-client/sync-protocol/#helper-functions","title":"Helper functions","text":""},{"location":"specs/deneb/light-client/sync-protocol/#modified-get_lc_execution_root","title":"Modified <code>get_lc_execution_root</code>","text":"<pre><code>def get_lc_execution_root(header: LightClientHeader) -&gt; Root:\nepoch = compute_epoch_at_slot(header.beacon.slot)\n# [New in Deneb]\nif epoch &gt;= DENEB_FORK_EPOCH:\nreturn hash_tree_root(header.execution)\n# [Modified in Deneb]\nif epoch &gt;= CAPELLA_FORK_EPOCH:\nexecution_header = capella.ExecutionPayloadHeader(\nparent_hash=header.execution.parent_hash,\nfee_recipient=header.execution.fee_recipient,\nstate_root=header.execution.state_root,\nreceipts_root=header.execution.receipts_root,\nlogs_bloom=header.execution.logs_bloom,\nprev_randao=header.execution.prev_randao,\nblock_number=header.execution.block_number,\ngas_limit=header.execution.gas_limit,\ngas_used=header.execution.gas_used,\ntimestamp=header.execution.timestamp,\nextra_data=header.execution.extra_data,\nbase_fee_per_gas=header.execution.base_fee_per_gas,\nblock_hash=header.execution.block_hash,\ntransactions_root=header.execution.transactions_root,\nwithdrawals_root=header.execution.withdrawals_root,\n)\nreturn hash_tree_root(execution_header)\nreturn Root()\n</code></pre>"},{"location":"specs/deneb/light-client/sync-protocol/#modified-is_valid_light_client_header","title":"Modified <code>is_valid_light_client_header</code>","text":"<pre><code>def is_valid_light_client_header(header: LightClientHeader) -&gt; bool:\nepoch = compute_epoch_at_slot(header.beacon.slot)\n# [New in Deneb:EIP4844]\nif epoch &lt; DENEB_FORK_EPOCH:\nif header.execution.blob_gas_used != uint64(0) or header.execution.excess_blob_gas != uint64(0):\nreturn False\nif epoch &lt; CAPELLA_FORK_EPOCH:\nreturn (\nheader.execution == ExecutionPayloadHeader()\nand header.execution_branch == ExecutionBranch()\n)\nreturn is_valid_merkle_branch(\nleaf=get_lc_execution_root(header),\nbranch=header.execution_branch,\ndepth=floorlog2(EXECUTION_PAYLOAD_GINDEX),\nindex=get_subtree_index(EXECUTION_PAYLOAD_GINDEX),\nroot=header.beacon.body_root,\n)\n</code></pre>"},{"location":"specs/electra/beacon-chain/","title":"Electra -- The Beacon Chain","text":"<p>Notice: This document is a work-in-progress for researchers and implementers.</p>"},{"location":"specs/electra/beacon-chain/#table-of-contents","title":"Table of contents","text":"<ul> <li>Introduction</li> <li>Constants</li> <li>Misc</li> <li>Withdrawal prefixes</li> <li>Domains</li> <li>Preset</li> <li>Gwei values</li> <li>Rewards and penalties</li> <li>State list lengths</li> <li>Max operations per block</li> <li>Execution</li> <li>Withdrawals processing</li> <li>Configuration</li> <li>Validator cycle</li> <li>Containers</li> <li>New containers<ul> <li><code>DepositReceipt</code></li> <li><code>PendingBalanceDeposit</code></li> <li><code>PendingPartialWithdrawal</code></li> <li><code>ExecutionLayerWithdrawalRequest</code></li> <li><code>Consolidation</code></li> <li><code>SignedConsolidation</code></li> <li><code>PendingConsolidation</code></li> </ul> </li> <li>Modified Containers<ul> <li><code>AttesterSlashing</code></li> </ul> </li> <li>Extended Containers<ul> <li><code>Attestation</code></li> <li><code>IndexedAttestation</code></li> <li><code>BeaconBlockBody</code></li> <li><code>ExecutionPayload</code></li> <li><code>ExecutionPayloadHeader</code></li> <li><code>BeaconState</code></li> </ul> </li> <li>Helper functions</li> <li>Predicates<ul> <li>Updated <code>is_eligible_for_activation_queue</code></li> <li>New <code>is_compounding_withdrawal_credential</code></li> <li>New <code>has_compounding_withdrawal_credential</code></li> <li>New <code>has_execution_withdrawal_credential</code></li> <li>Updated <code>is_fully_withdrawable_validator</code></li> <li>Updated <code>is_partially_withdrawable_validator</code></li> </ul> </li> <li>Misc<ul> <li><code>get_committee_indices</code></li> <li><code>get_validator_max_effective_balance</code></li> </ul> </li> <li>Beacon state accessors<ul> <li>New <code>get_balance_churn_limit</code></li> <li>New <code>get_activation_exit_churn_limit</code></li> <li>New <code>get_consolidation_churn_limit</code></li> <li>New <code>get_active_balance</code></li> <li>New <code>get_pending_balance_to_withdraw</code></li> <li>Modified <code>get_attesting_indices</code></li> </ul> </li> <li>Beacon state mutators<ul> <li>Updated  <code>initiate_validator_exit</code></li> <li>New <code>switch_to_compounding_validator</code></li> <li>New <code>queue_excess_active_balance</code></li> <li>New <code>queue_entire_balance_and_reset_validator</code></li> <li>New <code>compute_exit_epoch_and_update_churn</code></li> <li>New <code>compute_consolidation_epoch_and_update_churn</code></li> <li>Updated <code>slash_validator</code></li> </ul> </li> <li>Beacon chain state transition function</li> <li>Epoch processing<ul> <li>Updated <code>process_epoch</code></li> <li>Updated  <code>process_registry_updates</code></li> <li>New <code>process_pending_balance_deposits</code></li> <li>New <code>process_pending_consolidations</code></li> <li>Updated <code>process_effective_balance_updates</code></li> </ul> </li> <li>Block processing<ul> <li>Withdrawals</li> <li>Updated <code>get_expected_withdrawals</code></li> <li>Updated <code>process_withdrawals</code></li> <li>Execution payload</li> <li>Modified <code>process_execution_payload</code></li> <li>Operations</li> <li>Modified <code>process_operations</code></li> <li>Attestations<ul> <li>Modified <code>process_attestation</code></li> </ul> </li> <li>Deposits<ul> <li>Updated  <code>apply_deposit</code></li> <li>New <code>is_valid_deposit_signature</code></li> <li>Modified <code>add_validator_to_registry</code></li> <li>Updated <code>get_validator_from_deposit</code></li> </ul> </li> <li>Voluntary exits<ul> <li>Updated <code>process_voluntary_exit</code></li> </ul> </li> <li>Execution layer withdrawal requests<ul> <li>New <code>process_execution_layer_withdrawal_request</code></li> </ul> </li> <li>Deposit receipts<ul> <li>New <code>process_deposit_receipt</code></li> </ul> </li> <li>Consolidations<ul> <li>New <code>process_consolidation</code></li> </ul> </li> </ul> </li> <li>Testing</li> </ul>"},{"location":"specs/electra/beacon-chain/#introduction","title":"Introduction","text":"<p>Electra is a consensus-layer upgrade containing a number of features. Including: * EIP-6110: Supply validator deposits on chain * EIP-7002: Execution layer triggerable exits * EIP-7251: Increase the MAX_EFFECTIVE_BALANCE * EIP-7549: Move committee index outside Attestation</p> <p>Note: This specification is built upon Deneb and is under active development.</p>"},{"location":"specs/electra/beacon-chain/#constants","title":"Constants","text":"<p>The following values are (non-configurable) constants used throughout the specification.</p>"},{"location":"specs/electra/beacon-chain/#misc","title":"Misc","text":"Name Value Description <code>UNSET_DEPOSIT_RECEIPTS_START_INDEX</code> <code>uint64(2**64 - 1)</code> [New in Electra:EIP6110] <code>FULL_EXIT_REQUEST_AMOUNT</code> <code>uint64(0)</code> [New in Electra:EIP7002]"},{"location":"specs/electra/beacon-chain/#withdrawal-prefixes","title":"Withdrawal prefixes","text":"Name Value <code>BLS_WITHDRAWAL_PREFIX</code> <code>Bytes1('0x00')</code> <code>ETH1_ADDRESS_WITHDRAWAL_PREFIX</code> <code>Bytes1('0x01')</code> <code>COMPOUNDING_WITHDRAWAL_PREFIX</code> <code>Bytes1('0x02')</code>"},{"location":"specs/electra/beacon-chain/#domains","title":"Domains","text":"Name Value <code>DOMAIN_CONSOLIDATION</code> <code>DomainType('0x0B000000')</code>"},{"location":"specs/electra/beacon-chain/#preset","title":"Preset","text":""},{"location":"specs/electra/beacon-chain/#gwei-values","title":"Gwei values","text":"Name Value <code>MIN_ACTIVATION_BALANCE</code> <code>Gwei(2**5 * 10**9)</code>  (= 32,000,000,000) <code>MAX_EFFECTIVE_BALANCE_ELECTRA</code> <code>Gwei(2**11 * 10**9)</code> (= 2048,000,000,000)"},{"location":"specs/electra/beacon-chain/#rewards-and-penalties","title":"Rewards and penalties","text":"Name Value <code>MIN_SLASHING_PENALTY_QUOTIENT_ELECTRA</code> <code>uint64(2**12)</code>  (= 4,096) <code>WHISTLEBLOWER_REWARD_QUOTIENT_ELECTRA</code> <code>uint64(2**12)</code>  (= 4,096)"},{"location":"specs/electra/beacon-chain/#state-list-lengths","title":"State list lengths","text":"Name Value Unit <code>PENDING_BALANCE_DEPOSITS_LIMIT</code> <code>uint64(2**27)</code> (= 134,217,728) pending balance deposits <code>PENDING_PARTIAL_WITHDRAWALS_LIMIT</code> <code>uint64(2**27)</code> (= 134,217,728) pending partial withdrawals <code>PENDING_CONSOLIDATIONS_LIMIT</code> <code>uint64(2**18)</code> (= 262,144) pending consolidations"},{"location":"specs/electra/beacon-chain/#max-operations-per-block","title":"Max operations per block","text":"Name Value <code>MAX_CONSOLIDATIONS</code> <code>uint64(1)</code>"},{"location":"specs/electra/beacon-chain/#execution","title":"Execution","text":"Name Value Description <code>MAX_DEPOSIT_RECEIPTS_PER_PAYLOAD</code> <code>uint64(2**13)</code> (= 8,192) [New in Electra:EIP6110] Maximum number of deposit receipts allowed in each payload <code>MAX_ATTESTER_SLASHINGS_ELECTRA</code> <code>2**0</code> (= 1) [New in Electra:EIP7549] <code>MAX_ATTESTATIONS_ELECTRA</code> <code>2**3</code> (= 8) [New in Electra:EIP7549] <code>MAX_WITHDRAWAL_REQUESTS_PER_PAYLOAD</code> <code>uint64(2**4)</code> (= 16) [New in Electra:EIP7002] Maximum number of execution layer withdrawal requests in each payload"},{"location":"specs/electra/beacon-chain/#withdrawals-processing","title":"Withdrawals processing","text":"Name Value Description <code>MAX_PENDING_PARTIALS_PER_WITHDRAWALS_SWEEP</code> <code>uint64(2**3)</code> (= 8) [New in Electra:EIP7002] Maximum number of pending partial withdrawals to process per payload"},{"location":"specs/electra/beacon-chain/#configuration","title":"Configuration","text":""},{"location":"specs/electra/beacon-chain/#validator-cycle","title":"Validator cycle","text":"Name Value <code>MIN_PER_EPOCH_CHURN_LIMIT_ELECTRA</code> <code>Gwei(2**7 * 10**9)</code> (= 128,000,000,000) <code>MAX_PER_EPOCH_ACTIVATION_EXIT_CHURN_LIMIT</code> <code>Gwei(2**8 * 10**9)</code> (= 256,000,000,000)"},{"location":"specs/electra/beacon-chain/#containers","title":"Containers","text":""},{"location":"specs/electra/beacon-chain/#new-containers","title":"New containers","text":""},{"location":"specs/electra/beacon-chain/#depositreceipt","title":"<code>DepositReceipt</code>","text":"<p>Note: The container is new in EIP6110.</p> <pre><code>class DepositReceipt(Container):\npubkey: BLSPubkey\nwithdrawal_credentials: Bytes32\namount: Gwei\nsignature: BLSSignature\nindex: uint64\n</code></pre>"},{"location":"specs/electra/beacon-chain/#pendingbalancedeposit","title":"<code>PendingBalanceDeposit</code>","text":"<p>Note: The container is new in EIP7251.</p> <pre><code>class PendingBalanceDeposit(Container):\nindex: ValidatorIndex\namount: Gwei\n</code></pre>"},{"location":"specs/electra/beacon-chain/#pendingpartialwithdrawal","title":"<code>PendingPartialWithdrawal</code>","text":"<p>Note: The container is new in EIP7251.</p> <pre><code>class PendingPartialWithdrawal(Container):\nindex: ValidatorIndex\namount: Gwei\nwithdrawable_epoch: Epoch\n</code></pre>"},{"location":"specs/electra/beacon-chain/#executionlayerwithdrawalrequest","title":"<code>ExecutionLayerWithdrawalRequest</code>","text":"<p>Note: The container is new in EIP7251:EIP7002.</p> <pre><code>class ExecutionLayerWithdrawalRequest(Container):\nsource_address: ExecutionAddress\nvalidator_pubkey: BLSPubkey\namount: Gwei\n</code></pre>"},{"location":"specs/electra/beacon-chain/#consolidation","title":"<code>Consolidation</code>","text":"<p>Note: The container is new in EIP7251.</p> <pre><code>class Consolidation(Container):\nsource_index: ValidatorIndex\ntarget_index: ValidatorIndex\nepoch: Epoch\n</code></pre>"},{"location":"specs/electra/beacon-chain/#signedconsolidation","title":"<code>SignedConsolidation</code>","text":"<p>Note: The container is new in EIP7251.</p> <pre><code>class SignedConsolidation(Container):\nmessage: Consolidation\nsignature: BLSSignature\n</code></pre>"},{"location":"specs/electra/beacon-chain/#pendingconsolidation","title":"<code>PendingConsolidation</code>","text":"<p>Note: The container is new in EIP7251.</p> <pre><code>class PendingConsolidation(Container):\nsource_index: ValidatorIndex\ntarget_index: ValidatorIndex\n</code></pre>"},{"location":"specs/electra/beacon-chain/#modified-containers","title":"Modified Containers","text":""},{"location":"specs/electra/beacon-chain/#attesterslashing","title":"<code>AttesterSlashing</code>","text":"<pre><code>class AttesterSlashing(Container):\nattestation_1: IndexedAttestation  # [Modified in Electra:EIP7549]\nattestation_2: IndexedAttestation  # [Modified in Electra:EIP7549]\n</code></pre>"},{"location":"specs/electra/beacon-chain/#extended-containers","title":"Extended Containers","text":""},{"location":"specs/electra/beacon-chain/#attestation","title":"<code>Attestation</code>","text":"<pre><code>class Attestation(Container):\naggregation_bits: Bitlist[MAX_VALIDATORS_PER_COMMITTEE * MAX_COMMITTEES_PER_SLOT]  # [Modified in Electra:EIP7549]\ndata: AttestationData\ncommittee_bits: Bitvector[MAX_COMMITTEES_PER_SLOT]  # [New in Electra:EIP7549]\nsignature: BLSSignature\n</code></pre>"},{"location":"specs/electra/beacon-chain/#indexedattestation","title":"<code>IndexedAttestation</code>","text":"<pre><code>class IndexedAttestation(Container):\n# [Modified in Electra:EIP7549]\nattesting_indices: List[ValidatorIndex, MAX_VALIDATORS_PER_COMMITTEE * MAX_COMMITTEES_PER_SLOT]\ndata: AttestationData\nsignature: BLSSignature\n</code></pre>"},{"location":"specs/electra/beacon-chain/#beaconblockbody","title":"<code>BeaconBlockBody</code>","text":"<pre><code>class BeaconBlockBody(Container):\nrandao_reveal: BLSSignature\neth1_data: Eth1Data  # Eth1 data vote\ngraffiti: Bytes32  # Arbitrary data\n# Operations\nproposer_slashings: List[ProposerSlashing, MAX_PROPOSER_SLASHINGS]\nattester_slashings: List[AttesterSlashing, MAX_ATTESTER_SLASHINGS_ELECTRA]  # [Modified in Electra:EIP7549]\nattestations: List[Attestation, MAX_ATTESTATIONS_ELECTRA]  # [Modified in Electra:EIP7549]\ndeposits: List[Deposit, MAX_DEPOSITS]\nvoluntary_exits: List[SignedVoluntaryExit, MAX_VOLUNTARY_EXITS]\nsync_aggregate: SyncAggregate\n# Execution\nexecution_payload: ExecutionPayload  # [Modified in Electra:EIP6110:EIP7002]\nbls_to_execution_changes: List[SignedBLSToExecutionChange, MAX_BLS_TO_EXECUTION_CHANGES]\nblob_kzg_commitments: List[KZGCommitment, MAX_BLOB_COMMITMENTS_PER_BLOCK]\nconsolidations: List[SignedConsolidation, MAX_CONSOLIDATIONS]  # [New in Electra:EIP7251]\n</code></pre>"},{"location":"specs/electra/beacon-chain/#executionpayload","title":"<code>ExecutionPayload</code>","text":"<pre><code>class ExecutionPayload(Container):\n# Execution block header fields\nparent_hash: Hash32\nfee_recipient: ExecutionAddress\nstate_root: Bytes32\nreceipts_root: Bytes32\nlogs_bloom: ByteVector[BYTES_PER_LOGS_BLOOM]\nprev_randao: Bytes32\nblock_number: uint64\ngas_limit: uint64\ngas_used: uint64\ntimestamp: uint64\nextra_data: ByteList[MAX_EXTRA_DATA_BYTES]\nbase_fee_per_gas: uint256\n# Extra payload fields\nblock_hash: Hash32\ntransactions: List[Transaction, MAX_TRANSACTIONS_PER_PAYLOAD]\nwithdrawals: List[Withdrawal, MAX_WITHDRAWALS_PER_PAYLOAD]\nblob_gas_used: uint64\nexcess_blob_gas: uint64\ndeposit_receipts: List[DepositReceipt, MAX_DEPOSIT_RECEIPTS_PER_PAYLOAD]  # [New in Electra:EIP6110]\n# [New in Electra:EIP7002:EIP7251]\nwithdrawal_requests: List[ExecutionLayerWithdrawalRequest, MAX_WITHDRAWAL_REQUESTS_PER_PAYLOAD]\n</code></pre>"},{"location":"specs/electra/beacon-chain/#executionpayloadheader","title":"<code>ExecutionPayloadHeader</code>","text":"<pre><code>class ExecutionPayloadHeader(Container):\n# Execution block header fields\nparent_hash: Hash32\nfee_recipient: ExecutionAddress\nstate_root: Bytes32\nreceipts_root: Bytes32\nlogs_bloom: ByteVector[BYTES_PER_LOGS_BLOOM]\nprev_randao: Bytes32\nblock_number: uint64\ngas_limit: uint64\ngas_used: uint64\ntimestamp: uint64\nextra_data: ByteList[MAX_EXTRA_DATA_BYTES]\nbase_fee_per_gas: uint256\n# Extra payload fields\nblock_hash: Hash32\ntransactions_root: Root\nwithdrawals_root: Root\nblob_gas_used: uint64\nexcess_blob_gas: uint64\ndeposit_receipts_root: Root  # [New in Electra:EIP6110]\nwithdrawal_requests_root: Root  # [New in Electra:EIP7002:EIP7251]\n</code></pre>"},{"location":"specs/electra/beacon-chain/#beaconstate","title":"<code>BeaconState</code>","text":"<pre><code>class BeaconState(Container):\n# Versioning\ngenesis_time: uint64\ngenesis_validators_root: Root\nslot: Slot\nfork: Fork\n# History\nlatest_block_header: BeaconBlockHeader\nblock_roots: Vector[Root, SLOTS_PER_HISTORICAL_ROOT]\nstate_roots: Vector[Root, SLOTS_PER_HISTORICAL_ROOT]\nhistorical_roots: List[Root, HISTORICAL_ROOTS_LIMIT]\n# Eth1\neth1_data: Eth1Data\neth1_data_votes: List[Eth1Data, EPOCHS_PER_ETH1_VOTING_PERIOD * SLOTS_PER_EPOCH]\neth1_deposit_index: uint64\n# Registry\nvalidators: List[Validator, VALIDATOR_REGISTRY_LIMIT]\nbalances: List[Gwei, VALIDATOR_REGISTRY_LIMIT]\n# Randomness\nrandao_mixes: Vector[Bytes32, EPOCHS_PER_HISTORICAL_VECTOR]\n# Slashings\nslashings: Vector[Gwei, EPOCHS_PER_SLASHINGS_VECTOR]  # Per-epoch sums of slashed effective balances\n# Participation\nprevious_epoch_participation: List[ParticipationFlags, VALIDATOR_REGISTRY_LIMIT]\ncurrent_epoch_participation: List[ParticipationFlags, VALIDATOR_REGISTRY_LIMIT]\n# Finality\njustification_bits: Bitvector[JUSTIFICATION_BITS_LENGTH]  # Bit set for every recent justified epoch\nprevious_justified_checkpoint: Checkpoint\ncurrent_justified_checkpoint: Checkpoint\nfinalized_checkpoint: Checkpoint\n# Inactivity\ninactivity_scores: List[uint64, VALIDATOR_REGISTRY_LIMIT]\n# Sync\ncurrent_sync_committee: SyncCommittee\nnext_sync_committee: SyncCommittee\n# Execution\nlatest_execution_payload_header: ExecutionPayloadHeader  # [Modified in Electra:EIP6110:EIP7002]\n# Withdrawals\nnext_withdrawal_index: WithdrawalIndex\nnext_withdrawal_validator_index: ValidatorIndex\n# Deep history valid from Capella onwards\nhistorical_summaries: List[HistoricalSummary, HISTORICAL_ROOTS_LIMIT]\ndeposit_receipts_start_index: uint64  # [New in Electra:EIP6110]\ndeposit_balance_to_consume: Gwei  # [New in Electra:EIP7251]\nexit_balance_to_consume: Gwei  # [New in Electra:EIP7251]\nearliest_exit_epoch: Epoch  # [New in Electra:EIP7251]\nconsolidation_balance_to_consume: Gwei  # [New in Electra:EIP7251]\nearliest_consolidation_epoch: Epoch  # [New in Electra:EIP7251]\npending_balance_deposits: List[PendingBalanceDeposit, PENDING_BALANCE_DEPOSITS_LIMIT]  # [New in Electra:EIP7251]\n# [New in Electra:EIP7251]\npending_partial_withdrawals: List[PendingPartialWithdrawal, PENDING_PARTIAL_WITHDRAWALS_LIMIT]\npending_consolidations: List[PendingConsolidation, PENDING_CONSOLIDATIONS_LIMIT]  # [New in Electra:EIP7251]\n</code></pre>"},{"location":"specs/electra/beacon-chain/#helper-functions","title":"Helper functions","text":""},{"location":"specs/electra/beacon-chain/#predicates","title":"Predicates","text":""},{"location":"specs/electra/beacon-chain/#updated-is_eligible_for_activation_queue","title":"Updated <code>is_eligible_for_activation_queue</code>","text":"<pre><code>def is_eligible_for_activation_queue(validator: Validator) -&gt; bool:\n\"\"\"\n    Check if ``validator`` is eligible to be placed into the activation queue.\n    \"\"\"\nreturn (\nvalidator.activation_eligibility_epoch == FAR_FUTURE_EPOCH\nand validator.effective_balance &gt;= MIN_ACTIVATION_BALANCE  # [Modified in Electra:EIP7251]\n)\n</code></pre>"},{"location":"specs/electra/beacon-chain/#new-is_compounding_withdrawal_credential","title":"New <code>is_compounding_withdrawal_credential</code>","text":"<pre><code>def is_compounding_withdrawal_credential(withdrawal_credentials: Bytes32) -&gt; bool:\nreturn withdrawal_credentials[:1] == COMPOUNDING_WITHDRAWAL_PREFIX\n</code></pre>"},{"location":"specs/electra/beacon-chain/#new-has_compounding_withdrawal_credential","title":"New <code>has_compounding_withdrawal_credential</code>","text":"<pre><code>def has_compounding_withdrawal_credential(validator: Validator) -&gt; bool:\n\"\"\"\n    Check if ``validator`` has an 0x02 prefixed \"compounding\" withdrawal credential.\n    \"\"\"\nreturn is_compounding_withdrawal_credential(validator.withdrawal_credentials)\n</code></pre>"},{"location":"specs/electra/beacon-chain/#new-has_execution_withdrawal_credential","title":"New <code>has_execution_withdrawal_credential</code>","text":"<pre><code>def has_execution_withdrawal_credential(validator: Validator) -&gt; bool:\n\"\"\"\n    Check if ``validator`` has a 0x01 or 0x02 prefixed withdrawal credential.\n    \"\"\"\nreturn has_compounding_withdrawal_credential(validator) or has_eth1_withdrawal_credential(validator)\n</code></pre>"},{"location":"specs/electra/beacon-chain/#updated-is_fully_withdrawable_validator","title":"Updated <code>is_fully_withdrawable_validator</code>","text":"<pre><code>def is_fully_withdrawable_validator(validator: Validator, balance: Gwei, epoch: Epoch) -&gt; bool:\n\"\"\"\n    Check if ``validator`` is fully withdrawable.\n    \"\"\"\nreturn (\nhas_execution_withdrawal_credential(validator)  # [Modified in Electra:EIP7251]\nand validator.withdrawable_epoch &lt;= epoch\nand balance &gt; 0\n)\n</code></pre>"},{"location":"specs/electra/beacon-chain/#updated-is_partially_withdrawable_validator","title":"Updated <code>is_partially_withdrawable_validator</code>","text":"<pre><code>def is_partially_withdrawable_validator(validator: Validator, balance: Gwei) -&gt; bool:\n\"\"\"\n    Check if ``validator`` is partially withdrawable.\n    \"\"\"\nmax_effective_balance = get_validator_max_effective_balance(validator)\nhas_max_effective_balance = validator.effective_balance == max_effective_balance  # [Modified in Electra:EIP7251]\nhas_excess_balance = balance &gt; max_effective_balance  # [Modified in Electra:EIP7251]\nreturn (\nhas_execution_withdrawal_credential(validator)  # [Modified in Electra:EIP7251]\nand has_max_effective_balance\nand has_excess_balance\n)\n</code></pre>"},{"location":"specs/electra/beacon-chain/#misc_1","title":"Misc","text":""},{"location":"specs/electra/beacon-chain/#get_committee_indices","title":"<code>get_committee_indices</code>","text":"<pre><code>def get_committee_indices(commitee_bits: Bitvector) -&gt; Sequence[CommitteeIndex]:\nreturn [CommitteeIndex(index) for index, bit in enumerate(commitee_bits) if bit]\n</code></pre>"},{"location":"specs/electra/beacon-chain/#get_validator_max_effective_balance","title":"<code>get_validator_max_effective_balance</code>","text":"<pre><code>def get_validator_max_effective_balance(validator: Validator) -&gt; Gwei:\n\"\"\"\n    Get max effective balance for ``validator``.\n    \"\"\"\nif has_compounding_withdrawal_credential(validator):\nreturn MAX_EFFECTIVE_BALANCE_ELECTRA\nelse:\nreturn MIN_ACTIVATION_BALANCE\n</code></pre>"},{"location":"specs/electra/beacon-chain/#beacon-state-accessors","title":"Beacon state accessors","text":""},{"location":"specs/electra/beacon-chain/#new-get_balance_churn_limit","title":"New <code>get_balance_churn_limit</code>","text":"<pre><code>def get_balance_churn_limit(state: BeaconState) -&gt; Gwei:\n\"\"\"\n    Return the churn limit for the current epoch.\n    \"\"\"\nchurn = max(\nMIN_PER_EPOCH_CHURN_LIMIT_ELECTRA,\nget_total_active_balance(state) // CHURN_LIMIT_QUOTIENT\n)\nreturn churn - churn % EFFECTIVE_BALANCE_INCREMENT\n</code></pre>"},{"location":"specs/electra/beacon-chain/#new-get_activation_exit_churn_limit","title":"New <code>get_activation_exit_churn_limit</code>","text":"<pre><code>def get_activation_exit_churn_limit(state: BeaconState) -&gt; Gwei:\n\"\"\"\n    Return the churn limit for the current epoch dedicated to activations and exits.\n    \"\"\"\nreturn min(MAX_PER_EPOCH_ACTIVATION_EXIT_CHURN_LIMIT, get_balance_churn_limit(state))\n</code></pre>"},{"location":"specs/electra/beacon-chain/#new-get_consolidation_churn_limit","title":"New <code>get_consolidation_churn_limit</code>","text":"<pre><code>def get_consolidation_churn_limit(state: BeaconState) -&gt; Gwei:\nreturn get_balance_churn_limit(state) - get_activation_exit_churn_limit(state)\n</code></pre>"},{"location":"specs/electra/beacon-chain/#new-get_active_balance","title":"New <code>get_active_balance</code>","text":"<pre><code>def get_active_balance(state: BeaconState, validator_index: ValidatorIndex) -&gt; Gwei:\nmax_effective_balance = get_validator_max_effective_balance(state.validators[validator_index])\nreturn min(state.balances[validator_index], max_effective_balance)\n</code></pre>"},{"location":"specs/electra/beacon-chain/#new-get_pending_balance_to_withdraw","title":"New <code>get_pending_balance_to_withdraw</code>","text":"<pre><code>def get_pending_balance_to_withdraw(state: BeaconState, validator_index: ValidatorIndex) -&gt; Gwei:\nreturn sum(\nwithdrawal.amount for withdrawal in state.pending_partial_withdrawals if withdrawal.index == validator_index\n)\n</code></pre>"},{"location":"specs/electra/beacon-chain/#modified-get_attesting_indices","title":"Modified <code>get_attesting_indices</code>","text":"<pre><code>def get_attesting_indices(state: BeaconState, attestation: Attestation) -&gt; Set[ValidatorIndex]:\n\"\"\"\n    Return the set of attesting indices corresponding to ``aggregation_bits`` and ``committee_bits``.\n    \"\"\"\noutput: Set[ValidatorIndex] = set()\ncommittee_indices = get_committee_indices(attestation.committee_bits)\ncommittee_offset = 0\nfor index in committee_indices:\ncommittee = get_beacon_committee(state, attestation.data.slot, index)\ncommittee_attesters = set(\nindex for i, index in enumerate(committee) if attestation.aggregation_bits[committee_offset + i])\noutput = output.union(committee_attesters)\ncommittee_offset += len(committee)\nreturn output\n</code></pre>"},{"location":"specs/electra/beacon-chain/#beacon-state-mutators","title":"Beacon state mutators","text":""},{"location":"specs/electra/beacon-chain/#updated-initiate_validator_exit","title":"Updated  <code>initiate_validator_exit</code>","text":"<pre><code>def initiate_validator_exit(state: BeaconState, index: ValidatorIndex) -&gt; None:\n\"\"\"\n    Initiate the exit of the validator with index ``index``.\n    \"\"\"\n# Return if validator already initiated exit\nvalidator = state.validators[index]\nif validator.exit_epoch != FAR_FUTURE_EPOCH:\nreturn\n# Compute exit queue epoch [Modified in Electra:EIP7251]\nexit_queue_epoch = compute_exit_epoch_and_update_churn(state, validator.effective_balance)\n# Set validator exit epoch and withdrawable epoch\nvalidator.exit_epoch = exit_queue_epoch\nvalidator.withdrawable_epoch = Epoch(validator.exit_epoch + MIN_VALIDATOR_WITHDRAWABILITY_DELAY)\n</code></pre>"},{"location":"specs/electra/beacon-chain/#new-switch_to_compounding_validator","title":"New <code>switch_to_compounding_validator</code>","text":"<pre><code>def switch_to_compounding_validator(state: BeaconState, index: ValidatorIndex) -&gt; None:\nvalidator = state.validators[index]\nif has_eth1_withdrawal_credential(validator):\nvalidator.withdrawal_credentials = COMPOUNDING_WITHDRAWAL_PREFIX + validator.withdrawal_credentials[1:]\nqueue_excess_active_balance(state, index)\n</code></pre>"},{"location":"specs/electra/beacon-chain/#new-queue_excess_active_balance","title":"New <code>queue_excess_active_balance</code>","text":"<pre><code>def queue_excess_active_balance(state: BeaconState, index: ValidatorIndex) -&gt; None:\nbalance = state.balances[index]\nif balance &gt; MIN_ACTIVATION_BALANCE:\nexcess_balance = balance - MIN_ACTIVATION_BALANCE\nstate.balances[index] = MIN_ACTIVATION_BALANCE\nstate.pending_balance_deposits.append(\nPendingBalanceDeposit(index=index, amount=excess_balance)\n)\n</code></pre>"},{"location":"specs/electra/beacon-chain/#new-queue_entire_balance_and_reset_validator","title":"New <code>queue_entire_balance_and_reset_validator</code>","text":"<pre><code>def queue_entire_balance_and_reset_validator(state: BeaconState, index: ValidatorIndex) -&gt; None:\nbalance = state.balances[index]\nstate.balances[index] = 0\nvalidator = state.validators[index]\nvalidator.effective_balance = 0\nvalidator.activation_eligibility_epoch = FAR_FUTURE_EPOCH\nstate.pending_balance_deposits.append(\nPendingBalanceDeposit(index=index, amount=balance)\n)\n</code></pre>"},{"location":"specs/electra/beacon-chain/#new-compute_exit_epoch_and_update_churn","title":"New <code>compute_exit_epoch_and_update_churn</code>","text":"<pre><code>def compute_exit_epoch_and_update_churn(state: BeaconState, exit_balance: Gwei) -&gt; Epoch:\nearliest_exit_epoch = max(state.earliest_exit_epoch, compute_activation_exit_epoch(get_current_epoch(state)))\nper_epoch_churn = get_activation_exit_churn_limit(state)\n# New epoch for exits.\nif state.earliest_exit_epoch &lt; earliest_exit_epoch:\nexit_balance_to_consume = per_epoch_churn\nelse:\nexit_balance_to_consume = state.exit_balance_to_consume\n# Exit doesn't fit in the current earliest epoch.\nif exit_balance &gt; exit_balance_to_consume:\nbalance_to_process = exit_balance - exit_balance_to_consume\nadditional_epochs = (balance_to_process - 1) // per_epoch_churn + 1\nearliest_exit_epoch += additional_epochs\nexit_balance_to_consume += additional_epochs * per_epoch_churn\n# Consume the balance and update state variables.\nstate.exit_balance_to_consume = exit_balance_to_consume - exit_balance\nstate.earliest_exit_epoch = earliest_exit_epoch\nreturn state.earliest_exit_epoch\n</code></pre>"},{"location":"specs/electra/beacon-chain/#new-compute_consolidation_epoch_and_update_churn","title":"New <code>compute_consolidation_epoch_and_update_churn</code>","text":"<pre><code>def compute_consolidation_epoch_and_update_churn(state: BeaconState, consolidation_balance: Gwei) -&gt; Epoch:\nearliest_consolidation_epoch = max(\nstate.earliest_consolidation_epoch, compute_activation_exit_epoch(get_current_epoch(state)))\nper_epoch_consolidation_churn = get_consolidation_churn_limit(state)\n# New epoch for consolidations.\nif state.earliest_consolidation_epoch &lt; earliest_consolidation_epoch:\nconsolidation_balance_to_consume = per_epoch_consolidation_churn\nelse:\nconsolidation_balance_to_consume = state.consolidation_balance_to_consume\n# Consolidation doesn't fit in the current earliest epoch.\nif consolidation_balance &gt; consolidation_balance_to_consume:\nbalance_to_process = consolidation_balance - consolidation_balance_to_consume\nadditional_epochs = (balance_to_process - 1) // per_epoch_consolidation_churn + 1\nearliest_consolidation_epoch += additional_epochs\nconsolidation_balance_to_consume += additional_epochs * per_epoch_consolidation_churn\n# Consume the balance and update state variables.\nstate.consolidation_balance_to_consume = consolidation_balance_to_consume - consolidation_balance\nstate.earliest_consolidation_epoch = earliest_consolidation_epoch\nreturn state.earliest_consolidation_epoch\n</code></pre>"},{"location":"specs/electra/beacon-chain/#updated-slash_validator","title":"Updated <code>slash_validator</code>","text":"<pre><code>def slash_validator(state: BeaconState,\nslashed_index: ValidatorIndex,\nwhistleblower_index: ValidatorIndex=None) -&gt; None:\n\"\"\"\n    Slash the validator with index ``slashed_index``.\n    \"\"\"\nepoch = get_current_epoch(state)\ninitiate_validator_exit(state, slashed_index)\nvalidator = state.validators[slashed_index]\nvalidator.slashed = True\nvalidator.withdrawable_epoch = max(validator.withdrawable_epoch, Epoch(epoch + EPOCHS_PER_SLASHINGS_VECTOR))\nstate.slashings[epoch % EPOCHS_PER_SLASHINGS_VECTOR] += validator.effective_balance\n# [Modified in Electra:EIP7251]\nslashing_penalty = validator.effective_balance // MIN_SLASHING_PENALTY_QUOTIENT_ELECTRA\ndecrease_balance(state, slashed_index, slashing_penalty)\n# Apply proposer and whistleblower rewards\nproposer_index = get_beacon_proposer_index(state)\nif whistleblower_index is None:\nwhistleblower_index = proposer_index\nwhistleblower_reward = Gwei(\nvalidator.effective_balance // WHISTLEBLOWER_REWARD_QUOTIENT_ELECTRA)  # [Modified in Electra:EIP7251]\nproposer_reward = Gwei(whistleblower_reward * PROPOSER_WEIGHT // WEIGHT_DENOMINATOR)\nincrease_balance(state, proposer_index, proposer_reward)\nincrease_balance(state, whistleblower_index, Gwei(whistleblower_reward - proposer_reward))\n</code></pre>"},{"location":"specs/electra/beacon-chain/#beacon-chain-state-transition-function","title":"Beacon chain state transition function","text":""},{"location":"specs/electra/beacon-chain/#epoch-processing","title":"Epoch processing","text":""},{"location":"specs/electra/beacon-chain/#updated-process_epoch","title":"Updated <code>process_epoch</code>","text":"<pre><code>def process_epoch(state: BeaconState) -&gt; None:\nprocess_justification_and_finalization(state)\nprocess_inactivity_updates(state)\nprocess_rewards_and_penalties(state)\nprocess_registry_updates(state)  # [Modified in Electra:EIP7251]\nprocess_slashings(state)\nprocess_eth1_data_reset(state)\nprocess_pending_balance_deposits(state)  # [New in Electra:EIP7251]\nprocess_pending_consolidations(state)  # [New in Electra:EIP7251]\nprocess_effective_balance_updates(state)  # [Modified in Electra:EIP7251]\nprocess_slashings_reset(state)\nprocess_randao_mixes_reset(state)\nprocess_historical_summaries_update(state)\nprocess_participation_flag_updates(state)\nprocess_sync_committee_updates(state)\n</code></pre>"},{"location":"specs/electra/beacon-chain/#updated-process_registry_updates","title":"Updated  <code>process_registry_updates</code>","text":"<p><code>process_registry_updates</code> uses the updated definition of <code>initiate_validator_exit</code> and changes how the activation epochs are computed for eligible validators.</p> <pre><code>def process_registry_updates(state: BeaconState) -&gt; None:\n# Process activation eligibility and ejections\nfor index, validator in enumerate(state.validators):\nif is_eligible_for_activation_queue(validator):\nvalidator.activation_eligibility_epoch = get_current_epoch(state) + 1\nif (\nis_active_validator(validator, get_current_epoch(state))\nand validator.effective_balance &lt;= EJECTION_BALANCE\n):\ninitiate_validator_exit(state, ValidatorIndex(index))\n# Activate all eligible validators\nactivation_epoch = compute_activation_exit_epoch(get_current_epoch(state))\nfor validator in state.validators:\nif is_eligible_for_activation(state, validator):\nvalidator.activation_epoch = activation_epoch\n</code></pre>"},{"location":"specs/electra/beacon-chain/#new-process_pending_balance_deposits","title":"New <code>process_pending_balance_deposits</code>","text":"<pre><code>def process_pending_balance_deposits(state: BeaconState) -&gt; None:\navailable_for_processing = state.deposit_balance_to_consume + get_activation_exit_churn_limit(state)\nprocessed_amount = 0\nnext_deposit_index = 0\nfor deposit in state.pending_balance_deposits:\nif processed_amount + deposit.amount &gt; available_for_processing:\nbreak\nincrease_balance(state, deposit.index, deposit.amount)\nprocessed_amount += deposit.amount\nnext_deposit_index += 1\nstate.pending_balance_deposits = state.pending_balance_deposits[next_deposit_index:]\nif len(state.pending_balance_deposits) == 0:\nstate.deposit_balance_to_consume = Gwei(0)\nelse:\nstate.deposit_balance_to_consume = available_for_processing - processed_amount\n</code></pre>"},{"location":"specs/electra/beacon-chain/#new-process_pending_consolidations","title":"New <code>process_pending_consolidations</code>","text":"<pre><code>def process_pending_consolidations(state: BeaconState) -&gt; None:\nnext_pending_consolidation = 0\nfor pending_consolidation in state.pending_consolidations:\nsource_validator = state.validators[pending_consolidation.source_index]\nif source_validator.slashed:\nnext_pending_consolidation += 1\ncontinue\nif source_validator.withdrawable_epoch &gt; get_current_epoch(state):\nbreak\n# Churn any target excess active balance of target and raise its max\nswitch_to_compounding_validator(state, pending_consolidation.target_index)\n# Move active balance to target. Excess balance is withdrawable.\nactive_balance = get_active_balance(state, pending_consolidation.source_index)\ndecrease_balance(state, pending_consolidation.source_index, active_balance)\nincrease_balance(state, pending_consolidation.target_index, active_balance)\nnext_pending_consolidation += 1\nstate.pending_consolidations = state.pending_consolidations[next_pending_consolidation:]\n</code></pre>"},{"location":"specs/electra/beacon-chain/#updated-process_effective_balance_updates","title":"Updated <code>process_effective_balance_updates</code>","text":"<p><code>process_effective_balance_updates</code> is updated with a new limit for the maximum effective balance.</p> <pre><code>def process_effective_balance_updates(state: BeaconState) -&gt; None:\n# Update effective balances with hysteresis\nfor index, validator in enumerate(state.validators):\nbalance = state.balances[index]\nHYSTERESIS_INCREMENT = uint64(EFFECTIVE_BALANCE_INCREMENT // HYSTERESIS_QUOTIENT)\nDOWNWARD_THRESHOLD = HYSTERESIS_INCREMENT * HYSTERESIS_DOWNWARD_MULTIPLIER\nUPWARD_THRESHOLD = HYSTERESIS_INCREMENT * HYSTERESIS_UPWARD_MULTIPLIER\nEFFECTIVE_BALANCE_LIMIT = (\nMAX_EFFECTIVE_BALANCE_ELECTRA if has_compounding_withdrawal_credential(validator)\nelse MIN_ACTIVATION_BALANCE\n)\nif (\nbalance + DOWNWARD_THRESHOLD &lt; validator.effective_balance\nor validator.effective_balance + UPWARD_THRESHOLD &lt; balance\n):\nvalidator.effective_balance = min(balance - balance % EFFECTIVE_BALANCE_INCREMENT, EFFECTIVE_BALANCE_LIMIT)\n</code></pre>"},{"location":"specs/electra/beacon-chain/#block-processing","title":"Block processing","text":"<pre><code>def process_block(state: BeaconState, block: BeaconBlock) -&gt; None:\nprocess_block_header(state, block)\nprocess_withdrawals(state, block.body.execution_payload)  # [Modified in Electra:EIP7251]\nprocess_execution_payload(state, block.body, EXECUTION_ENGINE)  # [Modified in Electra:EIP6110]\nprocess_randao(state, block.body)\nprocess_eth1_data(state, block.body)\nprocess_operations(state, block.body)  # [Modified in Electra:EIP6110:EIP7002:EIP7549:EIP7251]\nprocess_sync_aggregate(state, block.body.sync_aggregate)\n</code></pre>"},{"location":"specs/electra/beacon-chain/#withdrawals","title":"Withdrawals","text":""},{"location":"specs/electra/beacon-chain/#updated-get_expected_withdrawals","title":"Updated <code>get_expected_withdrawals</code>","text":"<pre><code>def get_expected_withdrawals(state: BeaconState) -&gt; Tuple[Sequence[Withdrawal], uint64]:\nepoch = get_current_epoch(state)\nwithdrawal_index = state.next_withdrawal_index\nvalidator_index = state.next_withdrawal_validator_index\nwithdrawals: List[Withdrawal] = []\n# [New in Electra:EIP7251] Consume pending partial withdrawals\nfor withdrawal in state.pending_partial_withdrawals:\nif withdrawal.withdrawable_epoch &gt; epoch or len(withdrawals) == MAX_PENDING_PARTIALS_PER_WITHDRAWALS_SWEEP:\nbreak\nvalidator = state.validators[withdrawal.index]\nhas_sufficient_effective_balance = validator.effective_balance &gt;= MIN_ACTIVATION_BALANCE\nhas_excess_balance = state.balances[withdrawal.index] &gt; MIN_ACTIVATION_BALANCE\nif validator.exit_epoch == FAR_FUTURE_EPOCH and has_sufficient_effective_balance and has_excess_balance:\nwithdrawable_balance = min(state.balances[withdrawal.index] - MIN_ACTIVATION_BALANCE, withdrawal.amount)\nwithdrawals.append(Withdrawal(\nindex=withdrawal_index,\nvalidator_index=withdrawal.index,\naddress=ExecutionAddress(validator.withdrawal_credentials[12:]),\namount=withdrawable_balance,\n))\nwithdrawal_index += WithdrawalIndex(1)\npartial_withdrawals_count = len(withdrawals)\n# Sweep for remaining.\nbound = min(len(state.validators), MAX_VALIDATORS_PER_WITHDRAWALS_SWEEP)\nfor _ in range(bound):\nvalidator = state.validators[validator_index]\nbalance = state.balances[validator_index]\nif is_fully_withdrawable_validator(validator, balance, epoch):\nwithdrawals.append(Withdrawal(\nindex=withdrawal_index,\nvalidator_index=validator_index,\naddress=ExecutionAddress(validator.withdrawal_credentials[12:]),\namount=balance,\n))\nwithdrawal_index += WithdrawalIndex(1)\nelif is_partially_withdrawable_validator(validator, balance):\nwithdrawals.append(Withdrawal(\nindex=withdrawal_index,\nvalidator_index=validator_index,\naddress=ExecutionAddress(validator.withdrawal_credentials[12:]),\namount=balance - get_validator_max_effective_balance(validator),  # [Modified in Electra:EIP7251]\n))\nwithdrawal_index += WithdrawalIndex(1)\nif len(withdrawals) == MAX_WITHDRAWALS_PER_PAYLOAD:\nbreak\nvalidator_index = ValidatorIndex((validator_index + 1) % len(state.validators))\nreturn withdrawals, partial_withdrawals_count\n</code></pre>"},{"location":"specs/electra/beacon-chain/#updated-process_withdrawals","title":"Updated <code>process_withdrawals</code>","text":"<pre><code>def process_withdrawals(state: BeaconState, payload: ExecutionPayload) -&gt; None:\nexpected_withdrawals, partial_withdrawals_count = get_expected_withdrawals(state)  # [Modified in Electra:EIP7251]\nassert len(payload.withdrawals) == len(expected_withdrawals)\nfor expected_withdrawal, withdrawal in zip(expected_withdrawals, payload.withdrawals):\nassert withdrawal == expected_withdrawal\ndecrease_balance(state, withdrawal.validator_index, withdrawal.amount)\n# Update pending partial withdrawals [New in Electra:EIP7251]\nstate.pending_partial_withdrawals = state.pending_partial_withdrawals[partial_withdrawals_count:]\n# Update the next withdrawal index if this block contained withdrawals\nif len(expected_withdrawals) != 0:\nlatest_withdrawal = expected_withdrawals[-1]\nstate.next_withdrawal_index = WithdrawalIndex(latest_withdrawal.index + 1)\n# Update the next validator index to start the next withdrawal sweep\nif len(expected_withdrawals) == MAX_WITHDRAWALS_PER_PAYLOAD:\n# Next sweep starts after the latest withdrawal's validator index\nnext_validator_index = ValidatorIndex((expected_withdrawals[-1].validator_index + 1) % len(state.validators))\nstate.next_withdrawal_validator_index = next_validator_index\nelse:\n# Advance sweep by the max length of the sweep if there was not a full set of withdrawals\nnext_index = state.next_withdrawal_validator_index + MAX_VALIDATORS_PER_WITHDRAWALS_SWEEP\nnext_validator_index = ValidatorIndex(next_index % len(state.validators))\nstate.next_withdrawal_validator_index = next_validator_index\n</code></pre>"},{"location":"specs/electra/beacon-chain/#execution-payload","title":"Execution payload","text":""},{"location":"specs/electra/beacon-chain/#modified-process_execution_payload","title":"Modified <code>process_execution_payload</code>","text":"<p>Note: The function <code>process_execution_payload</code> is modified to use the new <code>ExecutionPayloadHeader</code> type.</p> <pre><code>def process_execution_payload(state: BeaconState, body: BeaconBlockBody, execution_engine: ExecutionEngine) -&gt; None:\npayload = body.execution_payload\n# Verify consistency of the parent hash with respect to the previous execution payload header\nassert payload.parent_hash == state.latest_execution_payload_header.block_hash\n# Verify prev_randao\nassert payload.prev_randao == get_randao_mix(state, get_current_epoch(state))\n# Verify timestamp\nassert payload.timestamp == compute_timestamp_at_slot(state, state.slot)\n# Verify commitments are under limit\nassert len(body.blob_kzg_commitments) &lt;= MAX_BLOBS_PER_BLOCK\n# Verify the execution payload is valid\nversioned_hashes = [kzg_commitment_to_versioned_hash(commitment) for commitment in body.blob_kzg_commitments]\nassert execution_engine.verify_and_notify_new_payload(\nNewPayloadRequest(\nexecution_payload=payload,\nversioned_hashes=versioned_hashes,\nparent_beacon_block_root=state.latest_block_header.parent_root,\n)\n)\n# Cache execution payload header\nstate.latest_execution_payload_header = ExecutionPayloadHeader(\nparent_hash=payload.parent_hash,\nfee_recipient=payload.fee_recipient,\nstate_root=payload.state_root,\nreceipts_root=payload.receipts_root,\nlogs_bloom=payload.logs_bloom,\nprev_randao=payload.prev_randao,\nblock_number=payload.block_number,\ngas_limit=payload.gas_limit,\ngas_used=payload.gas_used,\ntimestamp=payload.timestamp,\nextra_data=payload.extra_data,\nbase_fee_per_gas=payload.base_fee_per_gas,\nblock_hash=payload.block_hash,\ntransactions_root=hash_tree_root(payload.transactions),\nwithdrawals_root=hash_tree_root(payload.withdrawals),\nblob_gas_used=payload.blob_gas_used,\nexcess_blob_gas=payload.excess_blob_gas,\ndeposit_receipts_root=hash_tree_root(payload.deposit_receipts),  # [New in Electra:EIP6110]\nwithdrawal_requests_root=hash_tree_root(payload.withdrawal_requests),  # [New in Electra:EIP7002:EIP7251]\n)\n</code></pre>"},{"location":"specs/electra/beacon-chain/#operations","title":"Operations","text":""},{"location":"specs/electra/beacon-chain/#modified-process_operations","title":"Modified <code>process_operations</code>","text":"<p>Note: The function <code>process_operations</code> is modified to support all of the new functionality in Electra.</p> <pre><code>def process_operations(state: BeaconState, body: BeaconBlockBody) -&gt; None:\n# [Modified in Electra:EIP6110]\n# Disable former deposit mechanism once all prior deposits are processed\neth1_deposit_index_limit = min(state.eth1_data.deposit_count, state.deposit_receipts_start_index)\nif state.eth1_deposit_index &lt; eth1_deposit_index_limit:\nassert len(body.deposits) == min(MAX_DEPOSITS, eth1_deposit_index_limit - state.eth1_deposit_index)\nelse:\nassert len(body.deposits) == 0\ndef for_ops(operations: Sequence[Any], fn: Callable[[BeaconState, Any], None]) -&gt; None:\nfor operation in operations:\nfn(state, operation)\nfor_ops(body.proposer_slashings, process_proposer_slashing)\nfor_ops(body.attester_slashings, process_attester_slashing)\nfor_ops(body.attestations, process_attestation)  # [Modified in Electra:EIP7549]\nfor_ops(body.deposits, process_deposit)  # [Modified in Electra:EIP7251]\nfor_ops(body.voluntary_exits, process_voluntary_exit)  # [Modified in Electra:EIP7251]\nfor_ops(body.bls_to_execution_changes, process_bls_to_execution_change)\n# [New in Electra:EIP7002:EIP7251]\nfor_ops(body.execution_payload.withdrawal_requests, process_execution_layer_withdrawal_request)\nfor_ops(body.execution_payload.deposit_receipts, process_deposit_receipt)  # [New in Electra:EIP6110]\nfor_ops(body.consolidations, process_consolidation)  # [New in Electra:EIP7251]\n</code></pre>"},{"location":"specs/electra/beacon-chain/#attestations","title":"Attestations","text":""},{"location":"specs/electra/beacon-chain/#modified-process_attestation","title":"Modified <code>process_attestation</code>","text":"<pre><code>def process_attestation(state: BeaconState, attestation: Attestation) -&gt; None:\ndata = attestation.data\nassert data.target.epoch in (get_previous_epoch(state), get_current_epoch(state))\nassert data.target.epoch == compute_epoch_at_slot(data.slot)\nassert data.slot + MIN_ATTESTATION_INCLUSION_DELAY &lt;= state.slot\n# [Modified in Electra:EIP7549]\nassert data.index == 0\ncommittee_indices = get_committee_indices(attestation.committee_bits)\nparticipants_count = 0\nfor index in committee_indices:\nassert index &lt; get_committee_count_per_slot(state, data.target.epoch)\ncommittee = get_beacon_committee(state, data.slot, index)\nparticipants_count += len(committee)\nassert len(attestation.aggregation_bits) == participants_count\n# Participation flag indices\nparticipation_flag_indices = get_attestation_participation_flag_indices(state, data, state.slot - data.slot)\n# Verify signature\nassert is_valid_indexed_attestation(state, get_indexed_attestation(state, attestation))\n# Update epoch participation flags\nif data.target.epoch == get_current_epoch(state):\nepoch_participation = state.current_epoch_participation\nelse:\nepoch_participation = state.previous_epoch_participation\nproposer_reward_numerator = 0\nfor index in get_attesting_indices(state, attestation):\nfor flag_index, weight in enumerate(PARTICIPATION_FLAG_WEIGHTS):\nif flag_index in participation_flag_indices and not has_flag(epoch_participation[index], flag_index):\nepoch_participation[index] = add_flag(epoch_participation[index], flag_index)\nproposer_reward_numerator += get_base_reward(state, index) * weight\n# Reward proposer\nproposer_reward_denominator = (WEIGHT_DENOMINATOR - PROPOSER_WEIGHT) * WEIGHT_DENOMINATOR // PROPOSER_WEIGHT\nproposer_reward = Gwei(proposer_reward_numerator // proposer_reward_denominator)\nincrease_balance(state, get_beacon_proposer_index(state), proposer_reward)\n</code></pre>"},{"location":"specs/electra/beacon-chain/#deposits","title":"Deposits","text":""},{"location":"specs/electra/beacon-chain/#updated-apply_deposit","title":"Updated  <code>apply_deposit</code>","text":"<p>NOTE: <code>process_deposit</code> is updated with a new definition of <code>apply_deposit</code>.</p> <pre><code>def apply_deposit(state: BeaconState,\npubkey: BLSPubkey,\nwithdrawal_credentials: Bytes32,\namount: uint64,\nsignature: BLSSignature) -&gt; None:\nvalidator_pubkeys = [v.pubkey for v in state.validators]\nif pubkey not in validator_pubkeys:\n# Verify the deposit signature (proof of possession) which is not checked by the deposit contract\nif is_valid_deposit_signature(pubkey, withdrawal_credentials, amount, signature):\nadd_validator_to_registry(state, pubkey, withdrawal_credentials, amount)\nelse:\n# Increase balance by deposit amount\nindex = ValidatorIndex(validator_pubkeys.index(pubkey))\nstate.pending_balance_deposits.append(\nPendingBalanceDeposit(index=index, amount=amount)\n)  # [Modified in Electra:EIP-7251]\n# Check if valid deposit switch to compounding credentials\nif (\nis_compounding_withdrawal_credential(withdrawal_credentials)\nand has_eth1_withdrawal_credential(state.validators[index])\nand is_valid_deposit_signature(pubkey, withdrawal_credentials, amount, signature)\n):\nswitch_to_compounding_validator(state, index)\n</code></pre>"},{"location":"specs/electra/beacon-chain/#new-is_valid_deposit_signature","title":"New <code>is_valid_deposit_signature</code>","text":"<pre><code>def is_valid_deposit_signature(pubkey: BLSPubkey,\nwithdrawal_credentials: Bytes32,\namount: uint64,\nsignature: BLSSignature) -&gt; bool:\ndeposit_message = DepositMessage(\npubkey=pubkey,\nwithdrawal_credentials=withdrawal_credentials,\namount=amount,\n)\ndomain = compute_domain(DOMAIN_DEPOSIT)  # Fork-agnostic domain since deposits are valid across forks\nsigning_root = compute_signing_root(deposit_message, domain)\nreturn bls.Verify(pubkey, signing_root, signature)\n</code></pre>"},{"location":"specs/electra/beacon-chain/#modified-add_validator_to_registry","title":"Modified <code>add_validator_to_registry</code>","text":"<pre><code>def add_validator_to_registry(state: BeaconState,\npubkey: BLSPubkey,\nwithdrawal_credentials: Bytes32,\namount: uint64) -&gt; None:\nindex = get_index_for_new_validator(state)\nvalidator = get_validator_from_deposit(pubkey, withdrawal_credentials)\nset_or_append_list(state.validators, index, validator)\nset_or_append_list(state.balances, index, 0)  # [Modified in Electra:EIP7251]\nset_or_append_list(state.previous_epoch_participation, index, ParticipationFlags(0b0000_0000))\nset_or_append_list(state.current_epoch_participation, index, ParticipationFlags(0b0000_0000))\nset_or_append_list(state.inactivity_scores, index, uint64(0))\nstate.pending_balance_deposits.append(PendingBalanceDeposit(index=index, amount=amount))  # [New in Electra:EIP7251]\n</code></pre>"},{"location":"specs/electra/beacon-chain/#updated-get_validator_from_deposit","title":"Updated <code>get_validator_from_deposit</code>","text":"<pre><code>def get_validator_from_deposit(pubkey: BLSPubkey, withdrawal_credentials: Bytes32) -&gt; Validator:\nreturn Validator(\npubkey=pubkey,\nwithdrawal_credentials=withdrawal_credentials,\nactivation_eligibility_epoch=FAR_FUTURE_EPOCH,\nactivation_epoch=FAR_FUTURE_EPOCH,\nexit_epoch=FAR_FUTURE_EPOCH,\nwithdrawable_epoch=FAR_FUTURE_EPOCH,\neffective_balance=0,  # [Modified in Electra:EIP7251]\n)\n</code></pre>"},{"location":"specs/electra/beacon-chain/#voluntary-exits","title":"Voluntary exits","text":""},{"location":"specs/electra/beacon-chain/#updated-process_voluntary_exit","title":"Updated <code>process_voluntary_exit</code>","text":"<pre><code>def process_voluntary_exit(state: BeaconState, signed_voluntary_exit: SignedVoluntaryExit) -&gt; None:\nvoluntary_exit = signed_voluntary_exit.message\nvalidator = state.validators[voluntary_exit.validator_index]\n# Verify the validator is active\nassert is_active_validator(validator, get_current_epoch(state))\n# Verify exit has not been initiated\nassert validator.exit_epoch == FAR_FUTURE_EPOCH\n# Exits must specify an epoch when they become valid; they are not valid before then\nassert get_current_epoch(state) &gt;= voluntary_exit.epoch\n# Verify the validator has been active long enough\nassert get_current_epoch(state) &gt;= validator.activation_epoch + SHARD_COMMITTEE_PERIOD\n# Only exit validator if it has no pending withdrawals in the queue\nassert get_pending_balance_to_withdraw(state, voluntary_exit.validator_index) == 0  # [New in Electra:EIP7251]\n# Verify signature\ndomain = compute_domain(DOMAIN_VOLUNTARY_EXIT, CAPELLA_FORK_VERSION, state.genesis_validators_root)\nsigning_root = compute_signing_root(voluntary_exit, domain)\nassert bls.Verify(validator.pubkey, signing_root, signed_voluntary_exit.signature)\n# Initiate exit\ninitiate_validator_exit(state, voluntary_exit.validator_index)\n</code></pre>"},{"location":"specs/electra/beacon-chain/#execution-layer-withdrawal-requests","title":"Execution layer withdrawal requests","text":""},{"location":"specs/electra/beacon-chain/#new-process_execution_layer_withdrawal_request","title":"New <code>process_execution_layer_withdrawal_request</code>","text":"<p>Note: This function is new in Electra following EIP-7002 and EIP-7251.</p> <pre><code>def process_execution_layer_withdrawal_request(\nstate: BeaconState,\nexecution_layer_withdrawal_request: ExecutionLayerWithdrawalRequest\n) -&gt; None:\namount = execution_layer_withdrawal_request.amount\nis_full_exit_request = amount == FULL_EXIT_REQUEST_AMOUNT\n# If partial withdrawal queue is full, only full exits are processed\nif len(state.pending_partial_withdrawals) == PENDING_PARTIAL_WITHDRAWALS_LIMIT and not is_full_exit_request:\nreturn\nvalidator_pubkeys = [v.pubkey for v in state.validators]\n# Verify pubkey exists\nrequest_pubkey = execution_layer_withdrawal_request.validator_pubkey\nif request_pubkey not in validator_pubkeys:\nreturn\nindex = ValidatorIndex(validator_pubkeys.index(request_pubkey))\nvalidator = state.validators[index]\n# Verify withdrawal credentials\nhas_correct_credential = has_execution_withdrawal_credential(validator)\nis_correct_source_address = (\nvalidator.withdrawal_credentials[12:] == execution_layer_withdrawal_request.source_address\n)\nif not (has_correct_credential and is_correct_source_address):\nreturn\n# Verify the validator is active\nif not is_active_validator(validator, get_current_epoch(state)):\nreturn\n# Verify exit has not been initiated\nif validator.exit_epoch != FAR_FUTURE_EPOCH:\nreturn\n# Verify the validator has been active long enough\nif get_current_epoch(state) &lt; validator.activation_epoch + SHARD_COMMITTEE_PERIOD:\nreturn\npending_balance_to_withdraw = get_pending_balance_to_withdraw(state, index)\nif is_full_exit_request:\n# Only exit validator if it has no pending withdrawals in the queue\nif pending_balance_to_withdraw == 0:\ninitiate_validator_exit(state, index)\nreturn\nhas_sufficient_effective_balance = validator.effective_balance &gt;= MIN_ACTIVATION_BALANCE\nhas_excess_balance = state.balances[index] &gt; MIN_ACTIVATION_BALANCE + pending_balance_to_withdraw\n# Only allow partial withdrawals with compounding withdrawal credentials\nif has_compounding_withdrawal_credential(validator) and has_sufficient_effective_balance and has_excess_balance:\nto_withdraw = min(\nstate.balances[index] - MIN_ACTIVATION_BALANCE - pending_balance_to_withdraw,\namount\n)\nexit_queue_epoch = compute_exit_epoch_and_update_churn(state, to_withdraw)\nwithdrawable_epoch = Epoch(exit_queue_epoch + MIN_VALIDATOR_WITHDRAWABILITY_DELAY)\nstate.pending_partial_withdrawals.append(PendingPartialWithdrawal(\nindex=index,\namount=to_withdraw,\nwithdrawable_epoch=withdrawable_epoch,\n))\n</code></pre>"},{"location":"specs/electra/beacon-chain/#deposit-receipts","title":"Deposit receipts","text":""},{"location":"specs/electra/beacon-chain/#new-process_deposit_receipt","title":"New <code>process_deposit_receipt</code>","text":"<p>Note: This function is new in Electra:EIP6110.</p> <pre><code>def process_deposit_receipt(state: BeaconState, deposit_receipt: DepositReceipt) -&gt; None:\n# Set deposit receipt start index\nif state.deposit_receipts_start_index == UNSET_DEPOSIT_RECEIPTS_START_INDEX:\nstate.deposit_receipts_start_index = deposit_receipt.index\napply_deposit(\nstate=state,\npubkey=deposit_receipt.pubkey,\nwithdrawal_credentials=deposit_receipt.withdrawal_credentials,\namount=deposit_receipt.amount,\nsignature=deposit_receipt.signature,\n)\n</code></pre>"},{"location":"specs/electra/beacon-chain/#consolidations","title":"Consolidations","text":""},{"location":"specs/electra/beacon-chain/#new-process_consolidation","title":"New <code>process_consolidation</code>","text":"<pre><code>def process_consolidation(state: BeaconState, signed_consolidation: SignedConsolidation) -&gt; None:\n# If the pending consolidations queue is full, no consolidations are allowed in the block\nassert len(state.pending_consolidations) &lt; PENDING_CONSOLIDATIONS_LIMIT\n# If there is too little available consolidation churn limit, no consolidations are allowed in the block\nassert get_consolidation_churn_limit(state) &gt; MIN_ACTIVATION_BALANCE\nconsolidation = signed_consolidation.message\n# Verify that source != target, so a consolidation cannot be used as an exit.\nassert consolidation.source_index != consolidation.target_index\nsource_validator = state.validators[consolidation.source_index]\ntarget_validator = state.validators[consolidation.target_index]\n# Verify the source and the target are active\ncurrent_epoch = get_current_epoch(state)\nassert is_active_validator(source_validator, current_epoch)\nassert is_active_validator(target_validator, current_epoch)\n# Verify exits for source and target have not been initiated\nassert source_validator.exit_epoch == FAR_FUTURE_EPOCH\nassert target_validator.exit_epoch == FAR_FUTURE_EPOCH\n# Consolidations must specify an epoch when they become valid; they are not valid before then\nassert current_epoch &gt;= consolidation.epoch\n# Verify the source and the target have Execution layer withdrawal credentials\nassert has_execution_withdrawal_credential(source_validator)\nassert has_execution_withdrawal_credential(target_validator)\n# Verify the same withdrawal address\nassert source_validator.withdrawal_credentials[12:] == target_validator.withdrawal_credentials[12:]\n# Verify consolidation is signed by the source and the target\ndomain = compute_domain(DOMAIN_CONSOLIDATION, genesis_validators_root=state.genesis_validators_root)\nsigning_root = compute_signing_root(consolidation, domain)\npubkeys = [source_validator.pubkey, target_validator.pubkey]\nassert bls.FastAggregateVerify(pubkeys, signing_root, signed_consolidation.signature)\n# Initiate source validator exit and append pending consolidation\nsource_validator.exit_epoch = compute_consolidation_epoch_and_update_churn(\nstate, source_validator.effective_balance\n)\nsource_validator.withdrawable_epoch = Epoch(\nsource_validator.exit_epoch + MIN_VALIDATOR_WITHDRAWABILITY_DELAY\n)\nstate.pending_consolidations.append(PendingConsolidation(\nsource_index=consolidation.source_index,\ntarget_index=consolidation.target_index\n))\n</code></pre>"},{"location":"specs/electra/beacon-chain/#testing","title":"Testing","text":"<p>Note: The function <code>initialize_beacon_state_from_eth1</code> is modified for pure Electra testing only. Modifications include: 1. Use <code>ELECTRA_FORK_VERSION</code> as the previous and current fork version. 2. Utilize the Electra <code>BeaconBlockBody</code> when constructing the initial <code>latest_block_header</code>. 3. [New in Electra:EIP6110] Add <code>deposit_receipts_start_index</code> variable to the genesis state initialization. 4. [New in Electra:EIP7251] Initialize new fields to support increasing the maximum effective balance.</p> <pre><code>def initialize_beacon_state_from_eth1(eth1_block_hash: Hash32,\neth1_timestamp: uint64,\ndeposits: Sequence[Deposit],\nexecution_payload_header: ExecutionPayloadHeader=ExecutionPayloadHeader()\n) -&gt; BeaconState:\nfork = Fork(\nprevious_version=ELECTRA_FORK_VERSION,  # [Modified in Electra:EIP6110] for testing only\ncurrent_version=ELECTRA_FORK_VERSION,  # [Modified in Electra:EIP6110]\nepoch=GENESIS_EPOCH,\n)\nstate = BeaconState(\ngenesis_time=eth1_timestamp + GENESIS_DELAY,\nfork=fork,\neth1_data=Eth1Data(block_hash=eth1_block_hash, deposit_count=uint64(len(deposits))),\nlatest_block_header=BeaconBlockHeader(body_root=hash_tree_root(BeaconBlockBody())),\nrandao_mixes=[eth1_block_hash] * EPOCHS_PER_HISTORICAL_VECTOR,  # Seed RANDAO with Eth1 entropy\ndeposit_receipts_start_index=UNSET_DEPOSIT_RECEIPTS_START_INDEX,  # [New in Electra:EIP6110]\n)\n# Process deposits\nleaves = list(map(lambda deposit: deposit.data, deposits))\nfor index, deposit in enumerate(deposits):\ndeposit_data_list = List[DepositData, 2**DEPOSIT_CONTRACT_TREE_DEPTH](*leaves[:index + 1])\nstate.eth1_data.deposit_root = hash_tree_root(deposit_data_list)\nprocess_deposit(state, deposit)\n# Process deposit balance updates\nfor deposit in state.pending_balance_deposits:\nincrease_balance(state, deposit.index, deposit.amount)\nstate.pending_balance_deposits = []\n# Process activations\nfor index, validator in enumerate(state.validators):\nbalance = state.balances[index]\nvalidator.effective_balance = min(balance - balance % EFFECTIVE_BALANCE_INCREMENT, MAX_EFFECTIVE_BALANCE)\nif validator.effective_balance == MAX_EFFECTIVE_BALANCE:\nvalidator.activation_eligibility_epoch = GENESIS_EPOCH\nvalidator.activation_epoch = GENESIS_EPOCH\n# Set genesis validators root for domain separation and chain versioning\nstate.genesis_validators_root = hash_tree_root(state.validators)\n# Fill in sync committees\n# Note: A duplicate committee is assigned for the current and next committee at genesis\nstate.current_sync_committee = get_next_sync_committee(state)\nstate.next_sync_committee = get_next_sync_committee(state)\n# Initialize the execution payload header\nstate.latest_execution_payload_header = execution_payload_header\nreturn state\n</code></pre>"},{"location":"specs/electra/fork/","title":"Electra -- Fork Logic","text":"<p>Notice: This document is a work-in-progress for researchers and implementers.</p>"},{"location":"specs/electra/fork/#table-of-contents","title":"Table of contents","text":"<ul> <li>Introduction</li> <li>Configuration</li> <li>Helper functions</li> <li>Misc<ul> <li>Modified <code>compute_fork_version</code></li> </ul> </li> <li>Fork to Electra</li> <li>Fork trigger</li> <li>Upgrading the state</li> </ul>"},{"location":"specs/electra/fork/#introduction","title":"Introduction","text":"<p>This document describes the process of the Electra upgrade.</p>"},{"location":"specs/electra/fork/#configuration","title":"Configuration","text":"<p>Warning: this configuration is not definitive.</p> Name Value <code>ELECTRA_FORK_VERSION</code> <code>Version('0x05000000')</code> <code>ELECTRA_FORK_EPOCH</code> <code>Epoch(18446744073709551615)</code> TBD"},{"location":"specs/electra/fork/#helper-functions","title":"Helper functions","text":""},{"location":"specs/electra/fork/#misc","title":"Misc","text":""},{"location":"specs/electra/fork/#modified-compute_fork_version","title":"Modified <code>compute_fork_version</code>","text":"<pre><code>def compute_fork_version(epoch: Epoch) -&gt; Version:\n\"\"\"\n    Return the fork version at the given ``epoch``.\n    \"\"\"\nif epoch &gt;= ELECTRA_FORK_EPOCH:\nreturn ELECTRA_FORK_VERSION\nif epoch &gt;= DENEB_FORK_EPOCH:\nreturn DENEB_FORK_VERSION\nif epoch &gt;= CAPELLA_FORK_EPOCH:\nreturn CAPELLA_FORK_VERSION\nif epoch &gt;= BELLATRIX_FORK_EPOCH:\nreturn BELLATRIX_FORK_VERSION\nif epoch &gt;= ALTAIR_FORK_EPOCH:\nreturn ALTAIR_FORK_VERSION\nreturn GENESIS_FORK_VERSION\n</code></pre>"},{"location":"specs/electra/fork/#fork-to-electra","title":"Fork to Electra","text":""},{"location":"specs/electra/fork/#fork-trigger","title":"Fork trigger","text":"<p>TBD. This fork is defined for testing purposes, the EIP may be combined with other consensus-layer upgrade. For now, we assume the condition will be triggered at epoch <code>ELECTRA_FORK_EPOCH</code>.</p> <p>Note that for the pure Electra networks, we don't apply <code>upgrade_to_electra</code> since it starts with Electra version logic.</p>"},{"location":"specs/electra/fork/#upgrading-the-state","title":"Upgrading the state","text":"<p>If <code>state.slot % SLOTS_PER_EPOCH == 0</code> and <code>compute_epoch_at_slot(state.slot) == ELECTRA_FORK_EPOCH</code>, an irregular state change is made to upgrade to Electra.</p> <pre><code>def upgrade_to_electra(pre: deneb.BeaconState) -&gt; BeaconState:\nepoch = deneb.get_current_epoch(pre)\nlatest_execution_payload_header = ExecutionPayloadHeader(\nparent_hash=pre.latest_execution_payload_header.parent_hash,\nfee_recipient=pre.latest_execution_payload_header.fee_recipient,\nstate_root=pre.latest_execution_payload_header.state_root,\nreceipts_root=pre.latest_execution_payload_header.receipts_root,\nlogs_bloom=pre.latest_execution_payload_header.logs_bloom,\nprev_randao=pre.latest_execution_payload_header.prev_randao,\nblock_number=pre.latest_execution_payload_header.block_number,\ngas_limit=pre.latest_execution_payload_header.gas_limit,\ngas_used=pre.latest_execution_payload_header.gas_used,\ntimestamp=pre.latest_execution_payload_header.timestamp,\nextra_data=pre.latest_execution_payload_header.extra_data,\nbase_fee_per_gas=pre.latest_execution_payload_header.base_fee_per_gas,\nblock_hash=pre.latest_execution_payload_header.block_hash,\ntransactions_root=pre.latest_execution_payload_header.transactions_root,\nwithdrawals_root=pre.latest_execution_payload_header.withdrawals_root,\nblob_gas_used=pre.latest_execution_payload_header.blob_gas_used,\nexcess_blob_gas=pre.latest_execution_payload_header.excess_blob_gas,\ndeposit_receipts_root=Root(),  # [New in Electra:EIP6110]\nwithdrawal_requests_root=Root(),  # [New in Electra:EIP7002],\n)\nexit_epochs = [v.exit_epoch for v in pre.validators if v.exit_epoch != FAR_FUTURE_EPOCH]\nif not exit_epochs:\nexit_epochs = [get_current_epoch(pre)]\nearliest_exit_epoch = max(exit_epochs) + 1\npost = BeaconState(\n# Versioning\ngenesis_time=pre.genesis_time,\ngenesis_validators_root=pre.genesis_validators_root,\nslot=pre.slot,\nfork=Fork(\nprevious_version=pre.fork.current_version,\ncurrent_version=ELECTRA_FORK_VERSION,  # [Modified in Electra:EIP6110]\nepoch=epoch,\n),\n# History\nlatest_block_header=pre.latest_block_header,\nblock_roots=pre.block_roots,\nstate_roots=pre.state_roots,\nhistorical_roots=pre.historical_roots,\n# Eth1\neth1_data=pre.eth1_data,\neth1_data_votes=pre.eth1_data_votes,\neth1_deposit_index=pre.eth1_deposit_index,\n# Registry\nvalidators=pre.validators,\nbalances=pre.balances,\n# Randomness\nrandao_mixes=pre.randao_mixes,\n# Slashings\nslashings=pre.slashings,\n# Participation\nprevious_epoch_participation=pre.previous_epoch_participation,\ncurrent_epoch_participation=pre.current_epoch_participation,\n# Finality\njustification_bits=pre.justification_bits,\nprevious_justified_checkpoint=pre.previous_justified_checkpoint,\ncurrent_justified_checkpoint=pre.current_justified_checkpoint,\nfinalized_checkpoint=pre.finalized_checkpoint,\n# Inactivity\ninactivity_scores=pre.inactivity_scores,\n# Sync\ncurrent_sync_committee=pre.current_sync_committee,\nnext_sync_committee=pre.next_sync_committee,\n# Execution-layer\nlatest_execution_payload_header=latest_execution_payload_header,  # [Modified in Electra:EIP6110:EIP7002]\n# Withdrawals\nnext_withdrawal_index=pre.next_withdrawal_index,\nnext_withdrawal_validator_index=pre.next_withdrawal_validator_index,\n# Deep history valid from Capella onwards\nhistorical_summaries=pre.historical_summaries,\n# [New in Electra:EIP6110]\ndeposit_receipts_start_index=UNSET_DEPOSIT_RECEIPTS_START_INDEX,\n# [New in Electra:EIP7251]\ndeposit_balance_to_consume=0,\nexit_balance_to_consume=0,\nearliest_exit_epoch=earliest_exit_epoch,\nconsolidation_balance_to_consume=0,\nearliest_consolidation_epoch=compute_activation_exit_epoch(get_current_epoch(pre)),\npending_balance_deposits=[],\npending_partial_withdrawals=[],\npending_consolidations=[],\n)\npost.exit_balance_to_consume = get_activation_exit_churn_limit(post)\npost.consolidation_balance_to_consume = get_consolidation_churn_limit(post)\n# [New in Electra:EIP7251]\n# add validators that are not yet active to pending balance deposits\npre_activation = sorted([\nindex for index, validator in enumerate(post.validators)\nif validator.activation_epoch == FAR_FUTURE_EPOCH\n], key=lambda index: (\npost.validators[index].activation_eligibility_epoch,\nindex\n))\nfor index in pre_activation:\nqueue_entire_balance_and_reset_validator(post, ValidatorIndex(index))\n# Ensure early adopters of compounding credentials go through the activation churn\nfor index, validator in enumerate(post.validators):\nif has_compounding_withdrawal_credential(validator):\nqueue_excess_active_balance(post, ValidatorIndex(index))\nreturn post\n</code></pre>"},{"location":"specs/electra/p2p-interface/","title":"Electra -- Networking","text":"<p>This document contains the consensus-layer networking specification for Electra.</p> <p>The specification of these changes continues in the same format as the network specifications of previous upgrades, and assumes them as pre-requisite.</p>"},{"location":"specs/electra/p2p-interface/#table-of-contents","title":"Table of contents","text":"<ul> <li>Modifications in Electra</li> <li>The gossip domain: gossipsub<ul> <li>Topics and messages</li> <li>Global topics</li> <li><code>beacon_aggregate_and_proof</code></li> <li><code>beacon_attestation_{subnet_id}</code></li> </ul> </li> </ul>"},{"location":"specs/electra/p2p-interface/#modifications-in-electra","title":"Modifications in Electra","text":""},{"location":"specs/electra/p2p-interface/#the-gossip-domain-gossipsub","title":"The gossip domain: gossipsub","text":"<p>Some gossip meshes are upgraded in the fork of Electra to support upgraded types.</p>"},{"location":"specs/electra/p2p-interface/#topics-and-messages","title":"Topics and messages","text":"<p>Topics follow the same specification as in prior upgrades.</p> <p>The <code>beacon_block</code> topic is modified to also support Electra blocks.</p> <p>The <code>beacon_aggregate_and_proof</code> and <code>beacon_attestation_{subnet_id}</code> topics are modified to support the gossip of the new attestation type.</p> <p>The specification around the creation, validation, and dissemination of messages has not changed from the Capella document unless explicitly noted here.</p> <p>The derivation of the <code>message-id</code> remains stable.</p>"},{"location":"specs/electra/p2p-interface/#global-topics","title":"Global topics","text":""},{"location":"specs/electra/p2p-interface/#beacon_aggregate_and_proof","title":"<code>beacon_aggregate_and_proof</code>","text":"<p>The following convenience variables are re-defined - <code>index = get_committee_indices(aggregate.committee_bits)[0]</code></p> <p>The following validations are added: * [REJECT] <code>len(committee_indices) == 1</code>, where <code>committee_indices = get_committee_indices(aggregate)</code>. * [REJECT] <code>aggregate.data.index == 0</code></p>"},{"location":"specs/electra/p2p-interface/#beacon_attestation_subnet_id","title":"<code>beacon_attestation_{subnet_id}</code>","text":"<p>The following convenience variables are re-defined - <code>index = get_committee_indices(attestation.committee_bits)[0]</code></p> <p>The following validations are added: * [REJECT] <code>len(committee_indices) == 1</code>, where <code>committee_indices = get_committee_indices(attestation)</code>. * [REJECT] <code>attestation.data.index == 0</code></p>"},{"location":"specs/electra/validator/","title":"Electra -- Honest Validator","text":""},{"location":"specs/electra/validator/#table-of-contents","title":"Table of contents","text":"<ul> <li>Introduction</li> <li>Prerequisites</li> <li>Block proposal</li> <li>Constructing the <code>BeaconBlockBody</code><ul> <li>Attester slashings</li> <li>Attestations</li> <li>Deposits</li> <li>Execution payload</li> </ul> </li> <li>Attesting</li> <li>Construct attestation</li> <li>Attestation aggregation</li> <li>Construct aggregate</li> </ul>"},{"location":"specs/electra/validator/#introduction","title":"Introduction","text":"<p>This document represents the changes to be made in the code of an \"honest validator\" to implement Electra.</p>"},{"location":"specs/electra/validator/#prerequisites","title":"Prerequisites","text":"<p>This document is an extension of the Deneb -- Honest Validator guide. All behaviors and definitions defined in this document, and documents it extends, carry over unless explicitly noted or overridden.</p> <p>All terminology, constants, functions, and protocol mechanics defined in the updated Beacon Chain doc of Electra are requisite for this document and used throughout. Please see related Beacon Chain doc before continuing and use them as a reference throughout.</p>"},{"location":"specs/electra/validator/#block-proposal","title":"Block proposal","text":""},{"location":"specs/electra/validator/#constructing-the-beaconblockbody","title":"Constructing the <code>BeaconBlockBody</code>","text":""},{"location":"specs/electra/validator/#attester-slashings","title":"Attester slashings","text":"<p>Changed the max attester slashings size to <code>MAX_ATTESTER_SLASHINGS_ELECTRA</code>.</p>"},{"location":"specs/electra/validator/#attestations","title":"Attestations","text":"<p>Changed the max attestations size to <code>MAX_ATTESTATIONS_ELECTRA</code>.</p> <p>The network attestation aggregates contain only the assigned committee attestations. Attestation aggregates received by the block proposer from the committee aggregators with disjoint <code>committee_bits</code> sets and equal <code>AttestationData</code> SHOULD be consolidated into a single <code>Attestation</code> object. The proposer should run the following function to construct an on chain final aggregate form a list of network aggregates with equal <code>AttestationData</code>:</p> <pre><code>def compute_on_chain_aggregate(network_aggregates: Sequence[Attestation]) -&gt; Attestation:\naggregates = sorted(network_aggregates, key=lambda a: get_committee_indices(a.committee_bits)[0])\ndata = aggregates[0].data\naggregation_bits = Bitlist[MAX_VALIDATORS_PER_COMMITTEE * MAX_COMMITTEES_PER_SLOT]()\nfor a in aggregates:\nfor b in a.aggregation_bits:\naggregation_bits.append(b)\nsignature = bls.Aggregate([a.signature for a in aggregates])\ncommittee_indices = [get_committee_indices(a.committee_bits)[0] for a in aggregates]\ncommittee_flags = [(index in committee_indices) for index in range(0, MAX_COMMITTEES_PER_SLOT)]\ncommittee_bits = Bitvector[MAX_COMMITTEES_PER_SLOT](committee_flags)\nreturn Attestation(\naggregation_bits=aggregation_bits,\ndata=data,\ncommittee_bits=committee_bits,\nsignature=signature,\n)\n</code></pre>"},{"location":"specs/electra/validator/#deposits","title":"Deposits","text":"<p>[New in Electra:EIP6110] The expected number of deposits MUST be changed from <code>min(MAX_DEPOSITS, eth1_data.deposit_count - state.eth1_deposit_index)</code> to the result of the following function:</p> <pre><code>def get_eth1_pending_deposit_count(state: BeaconState) -&gt; uint64:\neth1_deposit_index_limit = min(state.eth1_data.deposit_count, state.deposit_receipts_start_index)\nif state.eth1_deposit_index &lt; eth1_deposit_index_limit:\nreturn min(MAX_DEPOSITS, eth1_deposit_index_limit - state.eth1_deposit_index)\nelse:\nreturn uint64(0)\n</code></pre>"},{"location":"specs/electra/validator/#execution-payload","title":"Execution payload","text":"<p><code>prepare_execution_payload</code> is updated from the Deneb specs.</p> <p>Note: In this section, <code>state</code> is the state of the slot for the block proposal without the block yet applied. That is, <code>state</code> is the <code>previous_state</code> processed through any empty slots up to the assigned slot using <code>process_slots(previous_state, slot)</code>.</p> <p>Note: The only change to <code>prepare_execution_payload</code> is the new definition of <code>get_expected_withdrawals</code>.</p> <pre><code>def prepare_execution_payload(state: BeaconState,\nsafe_block_hash: Hash32,\nfinalized_block_hash: Hash32,\nsuggested_fee_recipient: ExecutionAddress,\nexecution_engine: ExecutionEngine) -&gt; Optional[PayloadId]:\n# Verify consistency of the parent hash with respect to the previous execution payload header\nparent_hash = state.latest_execution_payload_header.block_hash\n# Set the forkchoice head and initiate the payload build process\nwithdrawals, _ = get_expected_withdrawals(state)  # [Modified in EIP-7251]\npayload_attributes = PayloadAttributes(\ntimestamp=compute_timestamp_at_slot(state, state.slot),\nprev_randao=get_randao_mix(state, get_current_epoch(state)),\nsuggested_fee_recipient=suggested_fee_recipient,\nwithdrawals=withdrawals,\nparent_beacon_block_root=hash_tree_root(state.latest_block_header),\n)\nreturn execution_engine.notify_forkchoice_updated(\nhead_block_hash=parent_hash,\nsafe_block_hash=safe_block_hash,\nfinalized_block_hash=finalized_block_hash,\npayload_attributes=payload_attributes,\n)\n</code></pre>"},{"location":"specs/electra/validator/#attesting","title":"Attesting","text":""},{"location":"specs/electra/validator/#construct-attestation","title":"Construct attestation","text":"<ul> <li>Set <code>attestation_data.index = 0</code>.</li> <li>Let <code>attestation.aggregation_bits</code> be a <code>Bitlist[MAX_VALIDATORS_PER_COMMITTEE * MAX_COMMITTEES_PER_SLOT]</code> of length <code>len(committee)</code>, where the bit of the index of the validator in the <code>committee</code> is set to <code>0b1</code>.</li> <li>Let <code>attestation.committee_bits</code> be a <code>Bitvector[MAX_COMMITTEES_PER_SLOT]</code>, where the bit at the index associated with the validator's committee is set to <code>0b1</code>.</li> </ul> <p>Note: Calling <code>get_attesting_indices(state, attestation)</code> should return a list of length equal to 1, containing <code>validator_index</code>.</p>"},{"location":"specs/electra/validator/#attestation-aggregation","title":"Attestation aggregation","text":""},{"location":"specs/electra/validator/#construct-aggregate","title":"Construct aggregate","text":"<ul> <li>Set <code>attestation_data.index = 0</code>.</li> <li>Let <code>aggregation_bits</code> be a <code>Bitlist[MAX_VALIDATORS_PER_COMMITTEE * MAX_COMMITTEES_PER_SLOT]</code> of length <code>len(committee)</code>, where each bit set from each individual attestation is set to <code>0b1</code>.</li> <li>Set <code>attestation.committee_bits = committee_bits</code>, where <code>committee_bits</code> has the same value as in each individual attestation.</li> </ul>"},{"location":"specs/phase0/beacon-chain/","title":"Phase 0 -- The Beacon Chain","text":""},{"location":"specs/phase0/beacon-chain/#table-of-contents","title":"Table of contents","text":"<ul> <li>Introduction</li> <li>Notation</li> <li>Custom types</li> <li>Constants</li> <li>Misc</li> <li>Withdrawal prefixes</li> <li>Domain types</li> <li>Preset</li> <li>Misc</li> <li>Gwei values</li> <li>Time parameters</li> <li>State list lengths</li> <li>Rewards and penalties</li> <li>Max operations per block</li> <li>Configuration</li> <li>Genesis settings</li> <li>Time parameters</li> <li>Validator cycle</li> <li>Containers</li> <li>Misc dependencies<ul> <li><code>Fork</code></li> <li><code>ForkData</code></li> <li><code>Checkpoint</code></li> <li><code>Validator</code></li> <li><code>AttestationData</code></li> <li><code>IndexedAttestation</code></li> <li><code>PendingAttestation</code></li> <li><code>Eth1Data</code></li> <li><code>HistoricalBatch</code></li> <li><code>DepositMessage</code></li> <li><code>DepositData</code></li> <li><code>BeaconBlockHeader</code></li> <li><code>SigningData</code></li> </ul> </li> <li>Beacon operations<ul> <li><code>ProposerSlashing</code></li> <li><code>AttesterSlashing</code></li> <li><code>Attestation</code></li> <li><code>Deposit</code></li> <li><code>VoluntaryExit</code></li> </ul> </li> <li>Beacon blocks<ul> <li><code>BeaconBlockBody</code></li> <li><code>BeaconBlock</code></li> </ul> </li> <li>Beacon state<ul> <li><code>BeaconState</code></li> </ul> </li> <li>Signed envelopes<ul> <li><code>SignedVoluntaryExit</code></li> <li><code>SignedBeaconBlock</code></li> <li><code>SignedBeaconBlockHeader</code></li> </ul> </li> <li>Helper functions</li> <li>Math<ul> <li><code>integer_squareroot</code></li> <li><code>xor</code></li> <li><code>uint_to_bytes</code></li> <li><code>bytes_to_uint64</code></li> <li><code>saturating_sub</code></li> </ul> </li> <li>Crypto<ul> <li><code>hash</code></li> <li><code>hash_tree_root</code></li> <li>BLS signatures</li> </ul> </li> <li>Predicates<ul> <li><code>is_active_validator</code></li> <li><code>is_eligible_for_activation_queue</code></li> <li><code>is_eligible_for_activation</code></li> <li><code>is_slashable_validator</code></li> <li><code>is_slashable_attestation_data</code></li> <li><code>is_valid_indexed_attestation</code></li> <li><code>is_valid_merkle_branch</code></li> </ul> </li> <li>Misc<ul> <li><code>compute_shuffled_index</code></li> <li><code>compute_proposer_index</code></li> <li><code>compute_committee</code></li> <li><code>compute_epoch_at_slot</code></li> <li><code>compute_start_slot_at_epoch</code></li> <li><code>compute_activation_exit_epoch</code></li> <li><code>compute_fork_data_root</code></li> <li><code>compute_fork_digest</code></li> <li><code>compute_domain</code></li> <li><code>compute_signing_root</code></li> </ul> </li> <li>Beacon state accessors<ul> <li><code>get_current_epoch</code></li> <li><code>get_previous_epoch</code></li> <li><code>get_block_root</code></li> <li><code>get_block_root_at_slot</code></li> <li><code>get_randao_mix</code></li> <li><code>get_active_validator_indices</code></li> <li><code>get_validator_churn_limit</code></li> <li><code>get_seed</code></li> <li><code>get_committee_count_per_slot</code></li> <li><code>get_beacon_committee</code></li> <li><code>get_beacon_proposer_index</code></li> <li><code>get_total_balance</code></li> <li><code>get_total_active_balance</code></li> <li><code>get_domain</code></li> <li><code>get_indexed_attestation</code></li> <li><code>get_attesting_indices</code></li> </ul> </li> <li>Beacon state mutators<ul> <li><code>increase_balance</code></li> <li><code>decrease_balance</code></li> <li><code>initiate_validator_exit</code></li> <li><code>slash_validator</code></li> </ul> </li> <li>Genesis</li> <li>Genesis state</li> <li>Genesis block</li> <li>Beacon chain state transition function</li> <li>Epoch processing<ul> <li>Helper functions</li> <li>Justification and finalization</li> <li>Rewards and penalties</li> <li>Helpers</li> <li>Components of attestation deltas</li> <li><code>get_attestation_deltas</code></li> <li><code>process_rewards_and_penalties</code></li> <li>Registry updates</li> <li>Slashings</li> <li>Eth1 data votes updates</li> <li>Effective balances updates</li> <li>Slashings balances updates</li> <li>Randao mixes updates</li> <li>Historical roots updates</li> <li>Participation records rotation</li> </ul> </li> <li>Block processing<ul> <li>Block header</li> <li>RANDAO</li> <li>Eth1 data</li> <li>Operations</li> <li>Proposer slashings</li> <li>Attester slashings</li> <li>Attestations</li> <li>Deposits</li> <li>Voluntary exits</li> </ul> </li> </ul>"},{"location":"specs/phase0/beacon-chain/#introduction","title":"Introduction","text":"<p>This document represents the specification for Phase 0 -- The Beacon Chain.</p> <p>At the core of Ethereum proof-of-stake is a system chain called the \"beacon chain\". The beacon chain stores and manages the registry of validators. In the initial deployment phases of proof-of-stake, the only mechanism to become a validator is to make a one-way ETH transaction to a deposit contract on the Ethereum proof-of-work chain. Activation as a validator happens when deposit receipts are processed by the beacon chain, the activation balance is reached, and a queuing process is completed. Exit is either voluntary or done forcibly as a penalty for misbehavior. The primary source of load on the beacon chain is \"attestations\". Attestations are simultaneously availability votes for a shard block (in a later upgrade) and proof-of-stake votes for a beacon block (Phase 0).</p>"},{"location":"specs/phase0/beacon-chain/#notation","title":"Notation","text":"<p>Code snippets appearing in <code>this style</code> are to be interpreted as Python 3 code.</p>"},{"location":"specs/phase0/beacon-chain/#custom-types","title":"Custom types","text":"<p>We define the following Python custom types for type hinting and readability:</p> Name SSZ equivalent Description <code>Slot</code> <code>uint64</code> a slot number <code>Epoch</code> <code>uint64</code> an epoch number <code>CommitteeIndex</code> <code>uint64</code> a committee index at a slot <code>ValidatorIndex</code> <code>uint64</code> a validator registry index <code>Gwei</code> <code>uint64</code> an amount in Gwei <code>Root</code> <code>Bytes32</code> a Merkle root <code>Hash32</code> <code>Bytes32</code> a 256-bit hash <code>Version</code> <code>Bytes4</code> a fork version number <code>DomainType</code> <code>Bytes4</code> a domain type <code>ForkDigest</code> <code>Bytes4</code> a digest of the current fork data <code>Domain</code> <code>Bytes32</code> a signature domain <code>BLSPubkey</code> <code>Bytes48</code> a BLS12-381 public key <code>BLSSignature</code> <code>Bytes96</code> a BLS12-381 signature"},{"location":"specs/phase0/beacon-chain/#constants","title":"Constants","text":"<p>The following values are (non-configurable) constants used throughout the specification.</p>"},{"location":"specs/phase0/beacon-chain/#misc","title":"Misc","text":"Name Value <code>UINT64_MAX</code> <code>uint64(2**64 - 1)</code> <code>UINT64_MAX_SQRT</code> <code>uint64(4294967295)</code> <code>GENESIS_SLOT</code> <code>Slot(0)</code> <code>GENESIS_EPOCH</code> <code>Epoch(0)</code> <code>FAR_FUTURE_EPOCH</code> <code>Epoch(2**64 - 1)</code> <code>BASE_REWARDS_PER_EPOCH</code> <code>uint64(4)</code> <code>DEPOSIT_CONTRACT_TREE_DEPTH</code> <code>uint64(2**5)</code> (= 32) <code>JUSTIFICATION_BITS_LENGTH</code> <code>uint64(4)</code> <code>ENDIANNESS</code> <code>'little'</code>"},{"location":"specs/phase0/beacon-chain/#withdrawal-prefixes","title":"Withdrawal prefixes","text":"Name Value <code>BLS_WITHDRAWAL_PREFIX</code> <code>Bytes1('0x00')</code> <code>ETH1_ADDRESS_WITHDRAWAL_PREFIX</code> <code>Bytes1('0x01')</code>"},{"location":"specs/phase0/beacon-chain/#domain-types","title":"Domain types","text":"Name Value <code>DOMAIN_BEACON_PROPOSER</code> <code>DomainType('0x00000000')</code> <code>DOMAIN_BEACON_ATTESTER</code> <code>DomainType('0x01000000')</code> <code>DOMAIN_RANDAO</code> <code>DomainType('0x02000000')</code> <code>DOMAIN_DEPOSIT</code> <code>DomainType('0x03000000')</code> <code>DOMAIN_VOLUNTARY_EXIT</code> <code>DomainType('0x04000000')</code> <code>DOMAIN_SELECTION_PROOF</code> <code>DomainType('0x05000000')</code> <code>DOMAIN_AGGREGATE_AND_PROOF</code> <code>DomainType('0x06000000')</code> <code>DOMAIN_APPLICATION_MASK</code> <code>DomainType('0x00000001')</code> <p>Note: <code>DOMAIN_APPLICATION_MASK</code> reserves the rest of the bitspace in <code>DomainType</code> for application usage. This means for some <code>DomainType</code> <code>DOMAIN_SOME_APPLICATION</code>, <code>DOMAIN_SOME_APPLICATION &amp; DOMAIN_APPLICATION_MASK</code> MUST be non-zero. This expression for any other <code>DomainType</code> in the consensus specs MUST be zero.</p>"},{"location":"specs/phase0/beacon-chain/#preset","title":"Preset","text":"<p>Note: The below configuration is bundled as a preset: a bundle of configuration variables which are expected to differ between different modes of operation, e.g. testing, but not generally between different networks. Additional preset configurations can be found in the <code>configs</code> directory.</p>"},{"location":"specs/phase0/beacon-chain/#misc_1","title":"Misc","text":"Name Value <code>MAX_COMMITTEES_PER_SLOT</code> <code>uint64(2**6)</code> (= 64) <code>TARGET_COMMITTEE_SIZE</code> <code>uint64(2**7)</code> (= 128) <code>MAX_VALIDATORS_PER_COMMITTEE</code> <code>uint64(2**11)</code> (= 2,048) <code>SHUFFLE_ROUND_COUNT</code> <code>uint64(90)</code> <code>HYSTERESIS_QUOTIENT</code> <code>uint64(4)</code> <code>HYSTERESIS_DOWNWARD_MULTIPLIER</code> <code>uint64(1)</code> <code>HYSTERESIS_UPWARD_MULTIPLIER</code> <code>uint64(5)</code> <ul> <li>For the safety of committees, <code>TARGET_COMMITTEE_SIZE</code> exceeds the recommended minimum committee size of 111; with sufficient active validators (at least <code>SLOTS_PER_EPOCH * TARGET_COMMITTEE_SIZE</code>), the shuffling algorithm ensures committee sizes of at least <code>TARGET_COMMITTEE_SIZE</code>. (Unbiasable randomness with a Verifiable Delay Function (VDF) will improve committee robustness and lower the safe minimum committee size.)</li> </ul>"},{"location":"specs/phase0/beacon-chain/#gwei-values","title":"Gwei values","text":"Name Value <code>MIN_DEPOSIT_AMOUNT</code> <code>Gwei(2**0 * 10**9)</code> (= 1,000,000,000) <code>MAX_EFFECTIVE_BALANCE</code> <code>Gwei(2**5 * 10**9)</code> (= 32,000,000,000) <code>EFFECTIVE_BALANCE_INCREMENT</code> <code>Gwei(2**0 * 10**9)</code> (= 1,000,000,000)"},{"location":"specs/phase0/beacon-chain/#time-parameters","title":"Time parameters","text":"Name Value Unit Duration <code>MIN_ATTESTATION_INCLUSION_DELAY</code> <code>uint64(2**0)</code> (= 1) slots 12 seconds <code>SLOTS_PER_EPOCH</code> <code>uint64(2**5)</code> (= 32) slots 6.4 minutes <code>MIN_SEED_LOOKAHEAD</code> <code>uint64(2**0)</code> (= 1) epochs 6.4 minutes <code>MAX_SEED_LOOKAHEAD</code> <code>uint64(2**2)</code> (= 4) epochs 25.6 minutes <code>MIN_EPOCHS_TO_INACTIVITY_PENALTY</code> <code>uint64(2**2)</code> (= 4) epochs 25.6 minutes <code>EPOCHS_PER_ETH1_VOTING_PERIOD</code> <code>uint64(2**6)</code> (= 64) epochs ~6.8 hours <code>SLOTS_PER_HISTORICAL_ROOT</code> <code>uint64(2**13)</code> (= 8,192) slots ~27 hours"},{"location":"specs/phase0/beacon-chain/#state-list-lengths","title":"State list lengths","text":"Name Value Unit Duration <code>EPOCHS_PER_HISTORICAL_VECTOR</code> <code>uint64(2**16)</code> (= 65,536) epochs ~0.8 years <code>EPOCHS_PER_SLASHINGS_VECTOR</code> <code>uint64(2**13)</code> (= 8,192) epochs ~36 days <code>HISTORICAL_ROOTS_LIMIT</code> <code>uint64(2**24)</code> (= 16,777,216) historical roots ~52,262 years <code>VALIDATOR_REGISTRY_LIMIT</code> <code>uint64(2**40)</code> (= 1,099,511,627,776) validators"},{"location":"specs/phase0/beacon-chain/#rewards-and-penalties","title":"Rewards and penalties","text":"Name Value <code>BASE_REWARD_FACTOR</code> <code>uint64(2**6)</code> (= 64) <code>WHISTLEBLOWER_REWARD_QUOTIENT</code> <code>uint64(2**9)</code> (= 512) <code>PROPOSER_REWARD_QUOTIENT</code> <code>uint64(2**3)</code> (= 8) <code>INACTIVITY_PENALTY_QUOTIENT</code> <code>uint64(2**26)</code> (= 67,108,864) <code>MIN_SLASHING_PENALTY_QUOTIENT</code> <code>uint64(2**7)</code> (= 128) <code>PROPORTIONAL_SLASHING_MULTIPLIER</code> <code>uint64(1)</code> <ul> <li>The <code>INACTIVITY_PENALTY_QUOTIENT</code> equals <code>INVERSE_SQRT_E_DROP_TIME**2</code> where <code>INVERSE_SQRT_E_DROP_TIME := 2**13</code> epochs (about 36 days) is the time it takes the inactivity penalty to reduce the balance of non-participating validators to about <code>1/sqrt(e) ~= 60.6%</code>. Indeed, the balance retained by offline validators after <code>n</code> epochs is about <code>(1 - 1/INACTIVITY_PENALTY_QUOTIENT)**(n**2/2)</code>; so after <code>INVERSE_SQRT_E_DROP_TIME</code> epochs, it is roughly <code>(1 - 1/INACTIVITY_PENALTY_QUOTIENT)**(INACTIVITY_PENALTY_QUOTIENT/2) ~= 1/sqrt(e)</code>. Note this value will be upgraded to <code>2**24</code> after Phase 0 mainnet stabilizes to provide a faster recovery in the event of an inactivity leak.</li> </ul> <ul> <li>The <code>PROPORTIONAL_SLASHING_MULTIPLIER</code> is set to <code>1</code> at initial mainnet launch, resulting in one-third of the minimum accountable safety margin in the event of a finality attack. After Phase 0 mainnet stabilizes, this value will be upgraded to <code>3</code> to provide the maximal minimum accountable safety margin.</li> </ul>"},{"location":"specs/phase0/beacon-chain/#max-operations-per-block","title":"Max operations per block","text":"Name Value <code>MAX_PROPOSER_SLASHINGS</code> <code>2**4</code> (= 16) <code>MAX_ATTESTER_SLASHINGS</code> <code>2**1</code> (= 2) <code>MAX_ATTESTATIONS</code> <code>2**7</code> (= 128) <code>MAX_DEPOSITS</code> <code>2**4</code> (= 16) <code>MAX_VOLUNTARY_EXITS</code> <code>2**4</code> (= 16)"},{"location":"specs/phase0/beacon-chain/#configuration","title":"Configuration","text":"<p>Note: The default mainnet configuration values are included here for illustrative purposes. Defaults for this more dynamic type of configuration are available with the presets in the <code>configs</code> directory. Testnets and other types of chain instances may use a different configuration.</p>"},{"location":"specs/phase0/beacon-chain/#genesis-settings","title":"Genesis settings","text":"Name Value <code>MIN_GENESIS_ACTIVE_VALIDATOR_COUNT</code> <code>uint64(2**14)</code> (= 16,384) <code>MIN_GENESIS_TIME</code> <code>uint64(1606824000)</code> (Dec 1, 2020, 12pm UTC) <code>GENESIS_FORK_VERSION</code> <code>Version('0x00000000')</code> <code>GENESIS_DELAY</code> <code>uint64(604800)</code> (7 days)"},{"location":"specs/phase0/beacon-chain/#time-parameters_1","title":"Time parameters","text":"Name Value Unit Duration <code>SECONDS_PER_SLOT</code> <code>uint64(12)</code> seconds 12 seconds <code>SECONDS_PER_ETH1_BLOCK</code> <code>uint64(14)</code> seconds 14 seconds <code>MIN_VALIDATOR_WITHDRAWABILITY_DELAY</code> <code>uint64(2**8)</code> (= 256) epochs ~27 hours <code>SHARD_COMMITTEE_PERIOD</code> <code>uint64(2**8)</code> (= 256) epochs ~27 hours <code>ETH1_FOLLOW_DISTANCE</code> <code>uint64(2**11)</code> (= 2,048) Eth1 blocks ~8 hours"},{"location":"specs/phase0/beacon-chain/#validator-cycle","title":"Validator cycle","text":"Name Value <code>EJECTION_BALANCE</code> <code>Gwei(2**4 * 10**9)</code> (= 16,000,000,000) <code>MIN_PER_EPOCH_CHURN_LIMIT</code> <code>uint64(2**2)</code> (= 4) <code>CHURN_LIMIT_QUOTIENT</code> <code>uint64(2**16)</code> (= 65,536)"},{"location":"specs/phase0/beacon-chain/#containers","title":"Containers","text":"<p>The following types are SimpleSerialize (SSZ) containers.</p> <p>Note: The definitions are ordered topologically to facilitate execution of the spec.</p> <p>Note: Fields missing in container instantiations default to their zero value.</p>"},{"location":"specs/phase0/beacon-chain/#misc-dependencies","title":"Misc dependencies","text":""},{"location":"specs/phase0/beacon-chain/#fork","title":"<code>Fork</code>","text":"<pre><code>class Fork(Container):\nprevious_version: Version\ncurrent_version: Version\nepoch: Epoch  # Epoch of latest fork\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#forkdata","title":"<code>ForkData</code>","text":"<pre><code>class ForkData(Container):\ncurrent_version: Version\ngenesis_validators_root: Root\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#checkpoint","title":"<code>Checkpoint</code>","text":"<pre><code>class Checkpoint(Container):\nepoch: Epoch\nroot: Root\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#validator","title":"<code>Validator</code>","text":"<pre><code>class Validator(Container):\npubkey: BLSPubkey\nwithdrawal_credentials: Bytes32  # Commitment to pubkey for withdrawals\neffective_balance: Gwei  # Balance at stake\nslashed: boolean\n# Status epochs\nactivation_eligibility_epoch: Epoch  # When criteria for activation were met\nactivation_epoch: Epoch\nexit_epoch: Epoch\nwithdrawable_epoch: Epoch  # When validator can withdraw funds\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#attestationdata","title":"<code>AttestationData</code>","text":"<pre><code>class AttestationData(Container):\nslot: Slot\nindex: CommitteeIndex\n# LMD GHOST vote\nbeacon_block_root: Root\n# FFG vote\nsource: Checkpoint\ntarget: Checkpoint\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#indexedattestation","title":"<code>IndexedAttestation</code>","text":"<pre><code>class IndexedAttestation(Container):\nattesting_indices: List[ValidatorIndex, MAX_VALIDATORS_PER_COMMITTEE]\ndata: AttestationData\nsignature: BLSSignature\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#pendingattestation","title":"<code>PendingAttestation</code>","text":"<pre><code>class PendingAttestation(Container):\naggregation_bits: Bitlist[MAX_VALIDATORS_PER_COMMITTEE]\ndata: AttestationData\ninclusion_delay: Slot\nproposer_index: ValidatorIndex\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#eth1data","title":"<code>Eth1Data</code>","text":"<pre><code>class Eth1Data(Container):\ndeposit_root: Root\ndeposit_count: uint64\nblock_hash: Hash32\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#historicalbatch","title":"<code>HistoricalBatch</code>","text":"<pre><code>class HistoricalBatch(Container):\nblock_roots: Vector[Root, SLOTS_PER_HISTORICAL_ROOT]\nstate_roots: Vector[Root, SLOTS_PER_HISTORICAL_ROOT]\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#depositmessage","title":"<code>DepositMessage</code>","text":"<pre><code>class DepositMessage(Container):\npubkey: BLSPubkey\nwithdrawal_credentials: Bytes32\namount: Gwei\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#depositdata","title":"<code>DepositData</code>","text":"<pre><code>class DepositData(Container):\npubkey: BLSPubkey\nwithdrawal_credentials: Bytes32\namount: Gwei\nsignature: BLSSignature  # Signing over DepositMessage\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#beaconblockheader","title":"<code>BeaconBlockHeader</code>","text":"<pre><code>class BeaconBlockHeader(Container):\nslot: Slot\nproposer_index: ValidatorIndex\nparent_root: Root\nstate_root: Root\nbody_root: Root\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#signingdata","title":"<code>SigningData</code>","text":"<pre><code>class SigningData(Container):\nobject_root: Root\ndomain: Domain\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#beacon-operations","title":"Beacon operations","text":""},{"location":"specs/phase0/beacon-chain/#proposerslashing","title":"<code>ProposerSlashing</code>","text":"<pre><code>class ProposerSlashing(Container):\nsigned_header_1: SignedBeaconBlockHeader\nsigned_header_2: SignedBeaconBlockHeader\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#attesterslashing","title":"<code>AttesterSlashing</code>","text":"<pre><code>class AttesterSlashing(Container):\nattestation_1: IndexedAttestation\nattestation_2: IndexedAttestation\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#attestation","title":"<code>Attestation</code>","text":"<pre><code>class Attestation(Container):\naggregation_bits: Bitlist[MAX_VALIDATORS_PER_COMMITTEE]\ndata: AttestationData\nsignature: BLSSignature\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#deposit","title":"<code>Deposit</code>","text":"<pre><code>class Deposit(Container):\nproof: Vector[Bytes32, DEPOSIT_CONTRACT_TREE_DEPTH + 1]  # Merkle path to deposit root\ndata: DepositData\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#voluntaryexit","title":"<code>VoluntaryExit</code>","text":"<pre><code>class VoluntaryExit(Container):\nepoch: Epoch  # Earliest epoch when voluntary exit can be processed\nvalidator_index: ValidatorIndex\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#beacon-blocks","title":"Beacon blocks","text":""},{"location":"specs/phase0/beacon-chain/#beaconblockbody","title":"<code>BeaconBlockBody</code>","text":"<pre><code>class BeaconBlockBody(Container):\nrandao_reveal: BLSSignature\neth1_data: Eth1Data  # Eth1 data vote\ngraffiti: Bytes32  # Arbitrary data\n# Operations\nproposer_slashings: List[ProposerSlashing, MAX_PROPOSER_SLASHINGS]\nattester_slashings: List[AttesterSlashing, MAX_ATTESTER_SLASHINGS]\nattestations: List[Attestation, MAX_ATTESTATIONS]\ndeposits: List[Deposit, MAX_DEPOSITS]\nvoluntary_exits: List[SignedVoluntaryExit, MAX_VOLUNTARY_EXITS]\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#beaconblock","title":"<code>BeaconBlock</code>","text":"<pre><code>class BeaconBlock(Container):\nslot: Slot\nproposer_index: ValidatorIndex\nparent_root: Root\nstate_root: Root\nbody: BeaconBlockBody\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#beacon-state","title":"Beacon state","text":""},{"location":"specs/phase0/beacon-chain/#beaconstate","title":"<code>BeaconState</code>","text":"<pre><code>class BeaconState(Container):\n# Versioning\ngenesis_time: uint64\ngenesis_validators_root: Root\nslot: Slot\nfork: Fork\n# History\nlatest_block_header: BeaconBlockHeader\nblock_roots: Vector[Root, SLOTS_PER_HISTORICAL_ROOT]\nstate_roots: Vector[Root, SLOTS_PER_HISTORICAL_ROOT]\nhistorical_roots: List[Root, HISTORICAL_ROOTS_LIMIT]\n# Eth1\neth1_data: Eth1Data\neth1_data_votes: List[Eth1Data, EPOCHS_PER_ETH1_VOTING_PERIOD * SLOTS_PER_EPOCH]\neth1_deposit_index: uint64\n# Registry\nvalidators: List[Validator, VALIDATOR_REGISTRY_LIMIT]\nbalances: List[Gwei, VALIDATOR_REGISTRY_LIMIT]\n# Randomness\nrandao_mixes: Vector[Bytes32, EPOCHS_PER_HISTORICAL_VECTOR]\n# Slashings\nslashings: Vector[Gwei, EPOCHS_PER_SLASHINGS_VECTOR]  # Per-epoch sums of slashed effective balances\n# Attestations\nprevious_epoch_attestations: List[PendingAttestation, MAX_ATTESTATIONS * SLOTS_PER_EPOCH]\ncurrent_epoch_attestations: List[PendingAttestation, MAX_ATTESTATIONS * SLOTS_PER_EPOCH]\n# Finality\njustification_bits: Bitvector[JUSTIFICATION_BITS_LENGTH]  # Bit set for every recent justified epoch\nprevious_justified_checkpoint: Checkpoint  # Previous epoch snapshot\ncurrent_justified_checkpoint: Checkpoint\nfinalized_checkpoint: Checkpoint\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#signed-envelopes","title":"Signed envelopes","text":""},{"location":"specs/phase0/beacon-chain/#signedvoluntaryexit","title":"<code>SignedVoluntaryExit</code>","text":"<pre><code>class SignedVoluntaryExit(Container):\nmessage: VoluntaryExit\nsignature: BLSSignature\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#signedbeaconblock","title":"<code>SignedBeaconBlock</code>","text":"<pre><code>class SignedBeaconBlock(Container):\nmessage: BeaconBlock\nsignature: BLSSignature\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#signedbeaconblockheader","title":"<code>SignedBeaconBlockHeader</code>","text":"<pre><code>class SignedBeaconBlockHeader(Container):\nmessage: BeaconBlockHeader\nsignature: BLSSignature\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#helper-functions","title":"Helper functions","text":"<p>Note: The definitions below are for specification purposes and are not necessarily optimal implementations.</p>"},{"location":"specs/phase0/beacon-chain/#math","title":"Math","text":""},{"location":"specs/phase0/beacon-chain/#integer_squareroot","title":"<code>integer_squareroot</code>","text":"<pre><code>def integer_squareroot(n: uint64) -&gt; uint64:\n\"\"\"\n    Return the largest integer ``x`` such that ``x**2 &lt;= n``.\n    \"\"\"\nif n == UINT64_MAX:\nreturn UINT64_MAX_SQRT\nx = n\ny = (x + 1) // 2\nwhile y &lt; x:\nx = y\ny = (x + n // x) // 2\nreturn x\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#xor","title":"<code>xor</code>","text":"<pre><code>def xor(bytes_1: Bytes32, bytes_2: Bytes32) -&gt; Bytes32:\n\"\"\"\n    Return the exclusive-or of two 32-byte strings.\n    \"\"\"\nreturn Bytes32(a ^ b for a, b in zip(bytes_1, bytes_2))\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#uint_to_bytes","title":"<code>uint_to_bytes</code>","text":"<p><code>def uint_to_bytes(n: uint) -&gt; bytes</code> is a function for serializing the <code>uint</code> type object to bytes in <code>ENDIANNESS</code>-endian. The expected length of the output is the byte-length of the <code>uint</code> type.</p>"},{"location":"specs/phase0/beacon-chain/#bytes_to_uint64","title":"<code>bytes_to_uint64</code>","text":"<pre><code>def bytes_to_uint64(data: bytes) -&gt; uint64:\n\"\"\"\n    Return the integer deserialization of ``data`` interpreted as ``ENDIANNESS``-endian.\n    \"\"\"\nreturn uint64(int.from_bytes(data, ENDIANNESS))\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#saturating_sub","title":"<code>saturating_sub</code>","text":"<pre><code>def saturating_sub(a: int, b: int) -&gt; int:\n\"\"\"\n    Computes a - b, saturating at numeric bounds.\n    \"\"\"\nreturn a - b if a &gt; b else 0\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#crypto","title":"Crypto","text":""},{"location":"specs/phase0/beacon-chain/#hash","title":"<code>hash</code>","text":"<p><code>def hash(data: bytes) -&gt; Bytes32</code> is SHA256.</p>"},{"location":"specs/phase0/beacon-chain/#hash_tree_root","title":"<code>hash_tree_root</code>","text":"<p><code>def hash_tree_root(object: SSZSerializable) -&gt; Root</code> is a function for hashing objects into a single root by utilizing a hash tree structure, as defined in the SSZ spec.</p>"},{"location":"specs/phase0/beacon-chain/#bls-signatures","title":"BLS signatures","text":"<p>The IETF BLS signature draft standard v4 with ciphersuite <code>BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_POP_</code> defines the following functions:</p> <ul> <li><code>def Sign(privkey: int, message: Bytes) -&gt; BLSSignature</code></li> <li><code>def Verify(pubkey: BLSPubkey, message: Bytes, signature: BLSSignature) -&gt; bool</code></li> <li><code>def Aggregate(signatures: Sequence[BLSSignature]) -&gt; BLSSignature</code></li> <li><code>def FastAggregateVerify(pubkeys: Sequence[BLSPubkey], message: Bytes, signature: BLSSignature) -&gt; bool</code></li> <li><code>def AggregateVerify(pubkeys: Sequence[BLSPubkey], messages: Sequence[Bytes], signature: BLSSignature) -&gt; bool</code></li> <li><code>def KeyValidate(pubkey: BLSPubkey) -&gt; bool</code></li> </ul> <p>The above functions are accessed through the <code>bls</code> module, e.g. <code>bls.Verify</code>.</p>"},{"location":"specs/phase0/beacon-chain/#predicates","title":"Predicates","text":""},{"location":"specs/phase0/beacon-chain/#is_active_validator","title":"<code>is_active_validator</code>","text":"<pre><code>def is_active_validator(validator: Validator, epoch: Epoch) -&gt; bool:\n\"\"\"\n    Check if ``validator`` is active.\n    \"\"\"\nreturn validator.activation_epoch &lt;= epoch &lt; validator.exit_epoch\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#is_eligible_for_activation_queue","title":"<code>is_eligible_for_activation_queue</code>","text":"<pre><code>def is_eligible_for_activation_queue(validator: Validator) -&gt; bool:\n\"\"\"\n    Check if ``validator`` is eligible to be placed into the activation queue.\n    \"\"\"\nreturn (\nvalidator.activation_eligibility_epoch == FAR_FUTURE_EPOCH\nand validator.effective_balance == MAX_EFFECTIVE_BALANCE\n)\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#is_eligible_for_activation","title":"<code>is_eligible_for_activation</code>","text":"<pre><code>def is_eligible_for_activation(state: BeaconState, validator: Validator) -&gt; bool:\n\"\"\"\n    Check if ``validator`` is eligible for activation.\n    \"\"\"\nreturn (\n# Placement in queue is finalized\nvalidator.activation_eligibility_epoch &lt;= state.finalized_checkpoint.epoch\n# Has not yet been activated\nand validator.activation_epoch == FAR_FUTURE_EPOCH\n)\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#is_slashable_validator","title":"<code>is_slashable_validator</code>","text":"<pre><code>def is_slashable_validator(validator: Validator, epoch: Epoch) -&gt; bool:\n\"\"\"\n    Check if ``validator`` is slashable.\n    \"\"\"\nreturn (not validator.slashed) and (validator.activation_epoch &lt;= epoch &lt; validator.withdrawable_epoch)\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#is_slashable_attestation_data","title":"<code>is_slashable_attestation_data</code>","text":"<pre><code>def is_slashable_attestation_data(data_1: AttestationData, data_2: AttestationData) -&gt; bool:\n\"\"\"\n    Check if ``data_1`` and ``data_2`` are slashable according to Casper FFG rules.\n    \"\"\"\nreturn (\n# Double vote\n(data_1 != data_2 and data_1.target.epoch == data_2.target.epoch) or\n# Surround vote\n(data_1.source.epoch &lt; data_2.source.epoch and data_2.target.epoch &lt; data_1.target.epoch)\n)\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#is_valid_indexed_attestation","title":"<code>is_valid_indexed_attestation</code>","text":"<pre><code>def is_valid_indexed_attestation(state: BeaconState, indexed_attestation: IndexedAttestation) -&gt; bool:\n\"\"\"\n    Check if ``indexed_attestation`` is not empty, has sorted and unique indices and has a valid aggregate signature.\n    \"\"\"\n# Verify indices are sorted and unique\nindices = indexed_attestation.attesting_indices\nif len(indices) == 0 or not indices == sorted(set(indices)):\nreturn False\n# Verify aggregate signature\npubkeys = [state.validators[i].pubkey for i in indices]\ndomain = get_domain(state, DOMAIN_BEACON_ATTESTER, indexed_attestation.data.target.epoch)\nsigning_root = compute_signing_root(indexed_attestation.data, domain)\nreturn bls.FastAggregateVerify(pubkeys, signing_root, indexed_attestation.signature)\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#is_valid_merkle_branch","title":"<code>is_valid_merkle_branch</code>","text":"<pre><code>def is_valid_merkle_branch(leaf: Bytes32, branch: Sequence[Bytes32], depth: uint64, index: uint64, root: Root) -&gt; bool:\n\"\"\"\n    Check if ``leaf`` at ``index`` verifies against the Merkle ``root`` and ``branch``.\n    \"\"\"\nvalue = leaf\nfor i in range(depth):\nif index // (2**i) % 2:\nvalue = hash(branch[i] + value)\nelse:\nvalue = hash(value + branch[i])\nreturn value == root\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#misc_2","title":"Misc","text":""},{"location":"specs/phase0/beacon-chain/#compute_shuffled_index","title":"<code>compute_shuffled_index</code>","text":"<pre><code>def compute_shuffled_index(index: uint64, index_count: uint64, seed: Bytes32) -&gt; uint64:\n\"\"\"\n    Return the shuffled index corresponding to ``seed`` (and ``index_count``).\n    \"\"\"\nassert index &lt; index_count\n# Swap or not (https://link.springer.com/content/pdf/10.1007%2F978-3-642-32009-5_1.pdf)\n# See the 'generalized domain' algorithm on page 3\nfor current_round in range(SHUFFLE_ROUND_COUNT):\npivot = bytes_to_uint64(hash(seed + uint_to_bytes(uint8(current_round)))[0:8]) % index_count\nflip = (pivot + index_count - index) % index_count\nposition = max(index, flip)\nsource = hash(\nseed\n+ uint_to_bytes(uint8(current_round))\n+ uint_to_bytes(uint32(position // 256))\n)\nbyte = uint8(source[(position % 256) // 8])\nbit = (byte &gt;&gt; (position % 8)) % 2\nindex = flip if bit else index\nreturn index\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#compute_proposer_index","title":"<code>compute_proposer_index</code>","text":"<pre><code>def compute_proposer_index(state: BeaconState, indices: Sequence[ValidatorIndex], seed: Bytes32) -&gt; ValidatorIndex:\n\"\"\"\n    Return from ``indices`` a random index sampled by effective balance.\n    \"\"\"\nassert len(indices) &gt; 0\nMAX_RANDOM_BYTE = 2**8 - 1\ni = uint64(0)\ntotal = uint64(len(indices))\nwhile True:\ncandidate_index = indices[compute_shuffled_index(i % total, total, seed)]\nrandom_byte = hash(seed + uint_to_bytes(uint64(i // 32)))[i % 32]\neffective_balance = state.validators[candidate_index].effective_balance\nif effective_balance * MAX_RANDOM_BYTE &gt;= MAX_EFFECTIVE_BALANCE * random_byte:\nreturn candidate_index\ni += 1\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#compute_committee","title":"<code>compute_committee</code>","text":"<pre><code>def compute_committee(indices: Sequence[ValidatorIndex],\nseed: Bytes32,\nindex: uint64,\ncount: uint64) -&gt; Sequence[ValidatorIndex]:\n\"\"\"\n    Return the committee corresponding to ``indices``, ``seed``, ``index``, and committee ``count``.\n    \"\"\"\nstart = (len(indices) * index) // count\nend = (len(indices) * uint64(index + 1)) // count\nreturn [indices[compute_shuffled_index(uint64(i), uint64(len(indices)), seed)] for i in range(start, end)]\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#compute_epoch_at_slot","title":"<code>compute_epoch_at_slot</code>","text":"<pre><code>def compute_epoch_at_slot(slot: Slot) -&gt; Epoch:\n\"\"\"\n    Return the epoch number at ``slot``.\n    \"\"\"\nreturn Epoch(slot // SLOTS_PER_EPOCH)\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#compute_start_slot_at_epoch","title":"<code>compute_start_slot_at_epoch</code>","text":"<pre><code>def compute_start_slot_at_epoch(epoch: Epoch) -&gt; Slot:\n\"\"\"\n    Return the start slot of ``epoch``.\n    \"\"\"\nreturn Slot(epoch * SLOTS_PER_EPOCH)\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#compute_activation_exit_epoch","title":"<code>compute_activation_exit_epoch</code>","text":"<pre><code>def compute_activation_exit_epoch(epoch: Epoch) -&gt; Epoch:\n\"\"\"\n    Return the epoch during which validator activations and exits initiated in ``epoch`` take effect.\n    \"\"\"\nreturn Epoch(epoch + 1 + MAX_SEED_LOOKAHEAD)\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#compute_fork_data_root","title":"<code>compute_fork_data_root</code>","text":"<pre><code>def compute_fork_data_root(current_version: Version, genesis_validators_root: Root) -&gt; Root:\n\"\"\"\n    Return the 32-byte fork data root for the ``current_version`` and ``genesis_validators_root``.\n    This is used primarily in signature domains to avoid collisions across forks/chains.\n    \"\"\"\nreturn hash_tree_root(ForkData(\ncurrent_version=current_version,\ngenesis_validators_root=genesis_validators_root,\n))\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#compute_fork_digest","title":"<code>compute_fork_digest</code>","text":"<pre><code>def compute_fork_digest(current_version: Version, genesis_validators_root: Root) -&gt; ForkDigest:\n\"\"\"\n    Return the 4-byte fork digest for the ``current_version`` and ``genesis_validators_root``.\n    This is a digest primarily used for domain separation on the p2p layer.\n    4-bytes suffices for practical separation of forks/chains.\n    \"\"\"\nreturn ForkDigest(compute_fork_data_root(current_version, genesis_validators_root)[:4])\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#compute_domain","title":"<code>compute_domain</code>","text":"<pre><code>def compute_domain(domain_type: DomainType, fork_version: Version=None, genesis_validators_root: Root=None) -&gt; Domain:\n\"\"\"\n    Return the domain for the ``domain_type`` and ``fork_version``.\n    \"\"\"\nif fork_version is None:\nfork_version = GENESIS_FORK_VERSION\nif genesis_validators_root is None:\ngenesis_validators_root = Root()  # all bytes zero by default\nfork_data_root = compute_fork_data_root(fork_version, genesis_validators_root)\nreturn Domain(domain_type + fork_data_root[:28])\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#compute_signing_root","title":"<code>compute_signing_root</code>","text":"<pre><code>def compute_signing_root(ssz_object: SSZObject, domain: Domain) -&gt; Root:\n\"\"\"\n    Return the signing root for the corresponding signing data.\n    \"\"\"\nreturn hash_tree_root(SigningData(\nobject_root=hash_tree_root(ssz_object),\ndomain=domain,\n))\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#beacon-state-accessors","title":"Beacon state accessors","text":""},{"location":"specs/phase0/beacon-chain/#get_current_epoch","title":"<code>get_current_epoch</code>","text":"<pre><code>def get_current_epoch(state: BeaconState) -&gt; Epoch:\n\"\"\"\n    Return the current epoch.\n    \"\"\"\nreturn compute_epoch_at_slot(state.slot)\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#get_previous_epoch","title":"<code>get_previous_epoch</code>","text":"<pre><code>def get_previous_epoch(state: BeaconState) -&gt; Epoch:\n\"\"\"`\n    Return the previous epoch (unless the current epoch is ``GENESIS_EPOCH``).\n    \"\"\"\ncurrent_epoch = get_current_epoch(state)\nreturn GENESIS_EPOCH if current_epoch == GENESIS_EPOCH else Epoch(current_epoch - 1)\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#get_block_root","title":"<code>get_block_root</code>","text":"<pre><code>def get_block_root(state: BeaconState, epoch: Epoch) -&gt; Root:\n\"\"\"\n    Return the block root at the start of a recent ``epoch``.\n    \"\"\"\nreturn get_block_root_at_slot(state, compute_start_slot_at_epoch(epoch))\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#get_block_root_at_slot","title":"<code>get_block_root_at_slot</code>","text":"<pre><code>def get_block_root_at_slot(state: BeaconState, slot: Slot) -&gt; Root:\n\"\"\"\n    Return the block root at a recent ``slot``.\n    \"\"\"\nassert slot &lt; state.slot &lt;= slot + SLOTS_PER_HISTORICAL_ROOT\nreturn state.block_roots[slot % SLOTS_PER_HISTORICAL_ROOT]\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#get_randao_mix","title":"<code>get_randao_mix</code>","text":"<pre><code>def get_randao_mix(state: BeaconState, epoch: Epoch) -&gt; Bytes32:\n\"\"\"\n    Return the randao mix at a recent ``epoch``.\n    \"\"\"\nreturn state.randao_mixes[epoch % EPOCHS_PER_HISTORICAL_VECTOR]\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#get_active_validator_indices","title":"<code>get_active_validator_indices</code>","text":"<pre><code>def get_active_validator_indices(state: BeaconState, epoch: Epoch) -&gt; Sequence[ValidatorIndex]:\n\"\"\"\n    Return the sequence of active validator indices at ``epoch``.\n    \"\"\"\nreturn [ValidatorIndex(i) for i, v in enumerate(state.validators) if is_active_validator(v, epoch)]\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#get_validator_churn_limit","title":"<code>get_validator_churn_limit</code>","text":"<pre><code>def get_validator_churn_limit(state: BeaconState) -&gt; uint64:\n\"\"\"\n    Return the validator churn limit for the current epoch.\n    \"\"\"\nactive_validator_indices = get_active_validator_indices(state, get_current_epoch(state))\nreturn max(MIN_PER_EPOCH_CHURN_LIMIT, uint64(len(active_validator_indices)) // CHURN_LIMIT_QUOTIENT)\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#get_seed","title":"<code>get_seed</code>","text":"<pre><code>def get_seed(state: BeaconState, epoch: Epoch, domain_type: DomainType) -&gt; Bytes32:\n\"\"\"\n    Return the seed at ``epoch``.\n    \"\"\"\nmix = get_randao_mix(state, Epoch(epoch + EPOCHS_PER_HISTORICAL_VECTOR - MIN_SEED_LOOKAHEAD - 1))  # Avoid underflow\nreturn hash(domain_type + uint_to_bytes(epoch) + mix)\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#get_committee_count_per_slot","title":"<code>get_committee_count_per_slot</code>","text":"<pre><code>def get_committee_count_per_slot(state: BeaconState, epoch: Epoch) -&gt; uint64:\n\"\"\"\n    Return the number of committees in each slot for the given ``epoch``.\n    \"\"\"\nreturn max(uint64(1), min(\nMAX_COMMITTEES_PER_SLOT,\nuint64(len(get_active_validator_indices(state, epoch))) // SLOTS_PER_EPOCH // TARGET_COMMITTEE_SIZE,\n))\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#get_beacon_committee","title":"<code>get_beacon_committee</code>","text":"<pre><code>def get_beacon_committee(state: BeaconState, slot: Slot, index: CommitteeIndex) -&gt; Sequence[ValidatorIndex]:\n\"\"\"\n    Return the beacon committee at ``slot`` for ``index``.\n    \"\"\"\nepoch = compute_epoch_at_slot(slot)\ncommittees_per_slot = get_committee_count_per_slot(state, epoch)\nreturn compute_committee(\nindices=get_active_validator_indices(state, epoch),\nseed=get_seed(state, epoch, DOMAIN_BEACON_ATTESTER),\nindex=(slot % SLOTS_PER_EPOCH) * committees_per_slot + index,\ncount=committees_per_slot * SLOTS_PER_EPOCH,\n)\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#get_beacon_proposer_index","title":"<code>get_beacon_proposer_index</code>","text":"<pre><code>def get_beacon_proposer_index(state: BeaconState) -&gt; ValidatorIndex:\n\"\"\"\n    Return the beacon proposer index at the current slot.\n    \"\"\"\nepoch = get_current_epoch(state)\nseed = hash(get_seed(state, epoch, DOMAIN_BEACON_PROPOSER) + uint_to_bytes(state.slot))\nindices = get_active_validator_indices(state, epoch)\nreturn compute_proposer_index(state, indices, seed)\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#get_total_balance","title":"<code>get_total_balance</code>","text":"<pre><code>def get_total_balance(state: BeaconState, indices: Set[ValidatorIndex]) -&gt; Gwei:\n\"\"\"\n    Return the combined effective balance of the ``indices``.\n    ``EFFECTIVE_BALANCE_INCREMENT`` Gwei minimum to avoid divisions by zero.\n    Math safe up to ~10B ETH, after which this overflows uint64.\n    \"\"\"\nreturn Gwei(max(EFFECTIVE_BALANCE_INCREMENT, sum([state.validators[index].effective_balance for index in indices])))\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#get_total_active_balance","title":"<code>get_total_active_balance</code>","text":"<pre><code>def get_total_active_balance(state: BeaconState) -&gt; Gwei:\n\"\"\"\n    Return the combined effective balance of the active validators.\n    Note: ``get_total_balance`` returns ``EFFECTIVE_BALANCE_INCREMENT`` Gwei minimum to avoid divisions by zero.\n    \"\"\"\nreturn get_total_balance(state, set(get_active_validator_indices(state, get_current_epoch(state))))\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#get_domain","title":"<code>get_domain</code>","text":"<pre><code>def get_domain(state: BeaconState, domain_type: DomainType, epoch: Epoch=None) -&gt; Domain:\n\"\"\"\n    Return the signature domain (fork version concatenated with domain type) of a message.\n    \"\"\"\nepoch = get_current_epoch(state) if epoch is None else epoch\nfork_version = state.fork.previous_version if epoch &lt; state.fork.epoch else state.fork.current_version\nreturn compute_domain(domain_type, fork_version, state.genesis_validators_root)\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#get_indexed_attestation","title":"<code>get_indexed_attestation</code>","text":"<pre><code>def get_indexed_attestation(state: BeaconState, attestation: Attestation) -&gt; IndexedAttestation:\n\"\"\"\n    Return the indexed attestation corresponding to ``attestation``.\n    \"\"\"\nattesting_indices = get_attesting_indices(state, attestation)\nreturn IndexedAttestation(\nattesting_indices=sorted(attesting_indices),\ndata=attestation.data,\nsignature=attestation.signature,\n)\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#get_attesting_indices","title":"<code>get_attesting_indices</code>","text":"<pre><code>def get_attesting_indices(state: BeaconState, attestation: Attestation) -&gt; Set[ValidatorIndex]:\n\"\"\"\n    Return the set of attesting indices corresponding to ``data`` and ``bits``.\n    \"\"\"\ncommittee = get_beacon_committee(state, attestation.data.slot, attestation.data.index)\nreturn set(index for i, index in enumerate(committee) if attestation.aggregation_bits[i])\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#beacon-state-mutators","title":"Beacon state mutators","text":""},{"location":"specs/phase0/beacon-chain/#increase_balance","title":"<code>increase_balance</code>","text":"<pre><code>def increase_balance(state: BeaconState, index: ValidatorIndex, delta: Gwei) -&gt; None:\n\"\"\"\n    Increase the validator balance at index ``index`` by ``delta``.\n    \"\"\"\nstate.balances[index] += delta\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#decrease_balance","title":"<code>decrease_balance</code>","text":"<pre><code>def decrease_balance(state: BeaconState, index: ValidatorIndex, delta: Gwei) -&gt; None:\n\"\"\"\n    Decrease the validator balance at index ``index`` by ``delta``, with underflow protection.\n    \"\"\"\nstate.balances[index] = 0 if delta &gt; state.balances[index] else state.balances[index] - delta\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#initiate_validator_exit","title":"<code>initiate_validator_exit</code>","text":"<pre><code>def initiate_validator_exit(state: BeaconState, index: ValidatorIndex) -&gt; None:\n\"\"\"\n    Initiate the exit of the validator with index ``index``.\n    \"\"\"\n# Return if validator already initiated exit\nvalidator = state.validators[index]\nif validator.exit_epoch != FAR_FUTURE_EPOCH:\nreturn\n# Compute exit queue epoch\nexit_epochs = [v.exit_epoch for v in state.validators if v.exit_epoch != FAR_FUTURE_EPOCH]\nexit_queue_epoch = max(exit_epochs + [compute_activation_exit_epoch(get_current_epoch(state))])\nexit_queue_churn = len([v for v in state.validators if v.exit_epoch == exit_queue_epoch])\nif exit_queue_churn &gt;= get_validator_churn_limit(state):\nexit_queue_epoch += Epoch(1)\n# Set validator exit epoch and withdrawable epoch\nvalidator.exit_epoch = exit_queue_epoch\nvalidator.withdrawable_epoch = Epoch(validator.exit_epoch + MIN_VALIDATOR_WITHDRAWABILITY_DELAY)\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#slash_validator","title":"<code>slash_validator</code>","text":"<pre><code>def slash_validator(state: BeaconState,\nslashed_index: ValidatorIndex,\nwhistleblower_index: ValidatorIndex=None) -&gt; None:\n\"\"\"\n    Slash the validator with index ``slashed_index``.\n    \"\"\"\nepoch = get_current_epoch(state)\ninitiate_validator_exit(state, slashed_index)\nvalidator = state.validators[slashed_index]\nvalidator.slashed = True\nvalidator.withdrawable_epoch = max(validator.withdrawable_epoch, Epoch(epoch + EPOCHS_PER_SLASHINGS_VECTOR))\nstate.slashings[epoch % EPOCHS_PER_SLASHINGS_VECTOR] += validator.effective_balance\ndecrease_balance(state, slashed_index, validator.effective_balance // MIN_SLASHING_PENALTY_QUOTIENT)\n# Apply proposer and whistleblower rewards\nproposer_index = get_beacon_proposer_index(state)\nif whistleblower_index is None:\nwhistleblower_index = proposer_index\nwhistleblower_reward = Gwei(validator.effective_balance // WHISTLEBLOWER_REWARD_QUOTIENT)\nproposer_reward = Gwei(whistleblower_reward // PROPOSER_REWARD_QUOTIENT)\nincrease_balance(state, proposer_index, proposer_reward)\nincrease_balance(state, whistleblower_index, Gwei(whistleblower_reward - proposer_reward))\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#genesis","title":"Genesis","text":"<p>Before the Ethereum beacon chain genesis has been triggered, and for every Ethereum proof-of-work block, let <code>candidate_state = initialize_beacon_state_from_eth1(eth1_block_hash, eth1_timestamp, deposits)</code> where:</p> <ul> <li><code>eth1_block_hash</code> is the hash of the Ethereum proof-of-work block</li> <li><code>eth1_timestamp</code> is the Unix timestamp corresponding to <code>eth1_block_hash</code></li> <li><code>deposits</code> is the sequence of all deposits, ordered chronologically, up to (and including) the block with hash <code>eth1_block_hash</code></li> </ul> <p>Proof-of-work blocks must only be considered once they are at least <code>SECONDS_PER_ETH1_BLOCK * ETH1_FOLLOW_DISTANCE</code> seconds old (i.e. <code>eth1_timestamp + SECONDS_PER_ETH1_BLOCK * ETH1_FOLLOW_DISTANCE &lt;= current_unix_time</code>). Due to this constraint, if <code>GENESIS_DELAY &lt; SECONDS_PER_ETH1_BLOCK * ETH1_FOLLOW_DISTANCE</code>, then the <code>genesis_time</code> can happen before the time/state is first known. Values should be configured to avoid this case.</p> <pre><code>def initialize_beacon_state_from_eth1(eth1_block_hash: Hash32,\neth1_timestamp: uint64,\ndeposits: Sequence[Deposit]) -&gt; BeaconState:\nfork = Fork(\nprevious_version=GENESIS_FORK_VERSION,\ncurrent_version=GENESIS_FORK_VERSION,\nepoch=GENESIS_EPOCH,\n)\nstate = BeaconState(\ngenesis_time=eth1_timestamp + GENESIS_DELAY,\nfork=fork,\neth1_data=Eth1Data(block_hash=eth1_block_hash, deposit_count=uint64(len(deposits))),\nlatest_block_header=BeaconBlockHeader(body_root=hash_tree_root(BeaconBlockBody())),\nrandao_mixes=[eth1_block_hash] * EPOCHS_PER_HISTORICAL_VECTOR,  # Seed RANDAO with Eth1 entropy\n)\n# Process deposits\nleaves = list(map(lambda deposit: deposit.data, deposits))\nfor index, deposit in enumerate(deposits):\ndeposit_data_list = List[DepositData, 2**DEPOSIT_CONTRACT_TREE_DEPTH](*leaves[:index + 1])\nstate.eth1_data.deposit_root = hash_tree_root(deposit_data_list)\nprocess_deposit(state, deposit)\n# Process activations\nfor index, validator in enumerate(state.validators):\nbalance = state.balances[index]\nvalidator.effective_balance = min(balance - balance % EFFECTIVE_BALANCE_INCREMENT, MAX_EFFECTIVE_BALANCE)\nif validator.effective_balance == MAX_EFFECTIVE_BALANCE:\nvalidator.activation_eligibility_epoch = GENESIS_EPOCH\nvalidator.activation_epoch = GENESIS_EPOCH\n# Set genesis validators root for domain separation and chain versioning\nstate.genesis_validators_root = hash_tree_root(state.validators)\nreturn state\n</code></pre> <p>Note: The ETH1 block with <code>eth1_timestamp</code> meeting the minimum genesis active validator count criteria can also occur before <code>MIN_GENESIS_TIME</code>.</p>"},{"location":"specs/phase0/beacon-chain/#genesis-state","title":"Genesis state","text":"<p>Let <code>genesis_state = candidate_state</code> whenever <code>is_valid_genesis_state(candidate_state) is True</code> for the first time.</p> <pre><code>def is_valid_genesis_state(state: BeaconState) -&gt; bool:\nif state.genesis_time &lt; MIN_GENESIS_TIME:\nreturn False\nif len(get_active_validator_indices(state, GENESIS_EPOCH)) &lt; MIN_GENESIS_ACTIVE_VALIDATOR_COUNT:\nreturn False\nreturn True\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#genesis-block","title":"Genesis block","text":"<p>Let <code>genesis_block = BeaconBlock(state_root=hash_tree_root(genesis_state))</code>.</p>"},{"location":"specs/phase0/beacon-chain/#beacon-chain-state-transition-function","title":"Beacon chain state transition function","text":"<p>The post-state corresponding to a pre-state <code>state</code> and a signed block <code>signed_block</code> is defined as <code>state_transition(state, signed_block)</code>. State transitions that trigger an unhandled exception (e.g. a failed <code>assert</code> or an out-of-range list access) are considered invalid. State transitions that cause a <code>uint64</code> overflow or underflow are also considered invalid.</p> <pre><code>def state_transition(state: BeaconState, signed_block: SignedBeaconBlock, validate_result: bool=True) -&gt; None:\nblock = signed_block.message\n# Process slots (including those with no blocks) since block\nprocess_slots(state, block.slot)\n# Verify signature\nif validate_result:\nassert verify_block_signature(state, signed_block)\n# Process block\nprocess_block(state, block)\n# Verify state root\nif validate_result:\nassert block.state_root == hash_tree_root(state)\n</code></pre> <pre><code>def verify_block_signature(state: BeaconState, signed_block: SignedBeaconBlock) -&gt; bool:\nproposer = state.validators[signed_block.message.proposer_index]\nsigning_root = compute_signing_root(signed_block.message, get_domain(state, DOMAIN_BEACON_PROPOSER))\nreturn bls.Verify(proposer.pubkey, signing_root, signed_block.signature)\n</code></pre> <pre><code>def process_slots(state: BeaconState, slot: Slot) -&gt; None:\nassert state.slot &lt; slot\nwhile state.slot &lt; slot:\nprocess_slot(state)\n# Process epoch on the start slot of the next epoch\nif (state.slot + 1) % SLOTS_PER_EPOCH == 0:\nprocess_epoch(state)\nstate.slot = Slot(state.slot + 1)\n</code></pre> <pre><code>def process_slot(state: BeaconState) -&gt; None:\n# Cache state root\nprevious_state_root = hash_tree_root(state)\nstate.state_roots[state.slot % SLOTS_PER_HISTORICAL_ROOT] = previous_state_root\n# Cache latest block header state root\nif state.latest_block_header.state_root == Bytes32():\nstate.latest_block_header.state_root = previous_state_root\n# Cache block root\nprevious_block_root = hash_tree_root(state.latest_block_header)\nstate.block_roots[state.slot % SLOTS_PER_HISTORICAL_ROOT] = previous_block_root\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#epoch-processing","title":"Epoch processing","text":"<pre><code>def process_epoch(state: BeaconState) -&gt; None:\nprocess_justification_and_finalization(state)\nprocess_rewards_and_penalties(state)\nprocess_registry_updates(state)\nprocess_slashings(state)\nprocess_eth1_data_reset(state)\nprocess_effective_balance_updates(state)\nprocess_slashings_reset(state)\nprocess_randao_mixes_reset(state)\nprocess_historical_roots_update(state)\nprocess_participation_record_updates(state)\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#helper-functions_1","title":"Helper functions","text":"<pre><code>def get_matching_source_attestations(state: BeaconState, epoch: Epoch) -&gt; Sequence[PendingAttestation]:\nassert epoch in (get_previous_epoch(state), get_current_epoch(state))\nreturn state.current_epoch_attestations if epoch == get_current_epoch(state) else state.previous_epoch_attestations\n</code></pre> <pre><code>def get_matching_target_attestations(state: BeaconState, epoch: Epoch) -&gt; Sequence[PendingAttestation]:\nreturn [\na for a in get_matching_source_attestations(state, epoch)\nif a.data.target.root == get_block_root(state, epoch)\n]\n</code></pre> <pre><code>def get_matching_head_attestations(state: BeaconState, epoch: Epoch) -&gt; Sequence[PendingAttestation]:\nreturn [\na for a in get_matching_target_attestations(state, epoch)\nif a.data.beacon_block_root == get_block_root_at_slot(state, a.data.slot)\n]\n</code></pre> <pre><code>def get_unslashed_attesting_indices(state: BeaconState,\nattestations: Sequence[PendingAttestation]) -&gt; Set[ValidatorIndex]:\noutput = set()  # type: Set[ValidatorIndex]\nfor a in attestations:\noutput = output.union(get_attesting_indices(state, a))\nreturn set(filter(lambda index: not state.validators[index].slashed, output))\n</code></pre> <pre><code>def get_attesting_balance(state: BeaconState, attestations: Sequence[PendingAttestation]) -&gt; Gwei:\n\"\"\"\n    Return the combined effective balance of the set of unslashed validators participating in ``attestations``.\n    Note: ``get_total_balance`` returns ``EFFECTIVE_BALANCE_INCREMENT`` Gwei minimum to avoid divisions by zero.\n    \"\"\"\nreturn get_total_balance(state, get_unslashed_attesting_indices(state, attestations))\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#justification-and-finalization","title":"Justification and finalization","text":"<pre><code>def process_justification_and_finalization(state: BeaconState) -&gt; None:\n# Initial FFG checkpoint values have a `0x00` stub for `root`.\n# Skip FFG updates in the first two epochs to avoid corner cases that might result in modifying this stub.\nif get_current_epoch(state) &lt;= GENESIS_EPOCH + 1:\nreturn\nprevious_attestations = get_matching_target_attestations(state, get_previous_epoch(state))\ncurrent_attestations = get_matching_target_attestations(state, get_current_epoch(state))\ntotal_active_balance = get_total_active_balance(state)\nprevious_target_balance = get_attesting_balance(state, previous_attestations)\ncurrent_target_balance = get_attesting_balance(state, current_attestations)\nweigh_justification_and_finalization(state, total_active_balance, previous_target_balance, current_target_balance)\n</code></pre> <pre><code>def weigh_justification_and_finalization(state: BeaconState,\ntotal_active_balance: Gwei,\nprevious_epoch_target_balance: Gwei,\ncurrent_epoch_target_balance: Gwei) -&gt; None:\nprevious_epoch = get_previous_epoch(state)\ncurrent_epoch = get_current_epoch(state)\nold_previous_justified_checkpoint = state.previous_justified_checkpoint\nold_current_justified_checkpoint = state.current_justified_checkpoint\n# Process justifications\nstate.previous_justified_checkpoint = state.current_justified_checkpoint\nstate.justification_bits[1:] = state.justification_bits[:JUSTIFICATION_BITS_LENGTH - 1]\nstate.justification_bits[0] = 0b0\nif previous_epoch_target_balance * 3 &gt;= total_active_balance * 2:\nstate.current_justified_checkpoint = Checkpoint(epoch=previous_epoch,\nroot=get_block_root(state, previous_epoch))\nstate.justification_bits[1] = 0b1\nif current_epoch_target_balance * 3 &gt;= total_active_balance * 2:\nstate.current_justified_checkpoint = Checkpoint(epoch=current_epoch,\nroot=get_block_root(state, current_epoch))\nstate.justification_bits[0] = 0b1\n# Process finalizations\nbits = state.justification_bits\n# The 2nd/3rd/4th most recent epochs are justified, the 2nd using the 4th as source\nif all(bits[1:4]) and old_previous_justified_checkpoint.epoch + 3 == current_epoch:\nstate.finalized_checkpoint = old_previous_justified_checkpoint\n# The 2nd/3rd most recent epochs are justified, the 2nd using the 3rd as source\nif all(bits[1:3]) and old_previous_justified_checkpoint.epoch + 2 == current_epoch:\nstate.finalized_checkpoint = old_previous_justified_checkpoint\n# The 1st/2nd/3rd most recent epochs are justified, the 1st using the 3rd as source\nif all(bits[0:3]) and old_current_justified_checkpoint.epoch + 2 == current_epoch:\nstate.finalized_checkpoint = old_current_justified_checkpoint\n# The 1st/2nd most recent epochs are justified, the 1st using the 2nd as source\nif all(bits[0:2]) and old_current_justified_checkpoint.epoch + 1 == current_epoch:\nstate.finalized_checkpoint = old_current_justified_checkpoint\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#rewards-and-penalties_1","title":"Rewards and penalties","text":""},{"location":"specs/phase0/beacon-chain/#helpers","title":"Helpers","text":"<pre><code>def get_base_reward(state: BeaconState, index: ValidatorIndex) -&gt; Gwei:\ntotal_balance = get_total_active_balance(state)\neffective_balance = state.validators[index].effective_balance\nreturn Gwei(effective_balance * BASE_REWARD_FACTOR // integer_squareroot(total_balance) // BASE_REWARDS_PER_EPOCH)\n</code></pre> <pre><code>def get_proposer_reward(state: BeaconState, attesting_index: ValidatorIndex) -&gt; Gwei:\nreturn Gwei(get_base_reward(state, attesting_index) // PROPOSER_REWARD_QUOTIENT)\n</code></pre> <pre><code>def get_finality_delay(state: BeaconState) -&gt; uint64:\nreturn get_previous_epoch(state) - state.finalized_checkpoint.epoch\n</code></pre> <pre><code>def is_in_inactivity_leak(state: BeaconState) -&gt; bool:\nreturn get_finality_delay(state) &gt; MIN_EPOCHS_TO_INACTIVITY_PENALTY\n</code></pre> <pre><code>def get_eligible_validator_indices(state: BeaconState) -&gt; Sequence[ValidatorIndex]:\nprevious_epoch = get_previous_epoch(state)\nreturn [\nValidatorIndex(index) for index, v in enumerate(state.validators)\nif is_active_validator(v, previous_epoch) or (v.slashed and previous_epoch + 1 &lt; v.withdrawable_epoch)\n]\n</code></pre> <pre><code>def get_attestation_component_deltas(state: BeaconState,\nattestations: Sequence[PendingAttestation]\n) -&gt; Tuple[Sequence[Gwei], Sequence[Gwei]]:\n\"\"\"\n    Helper with shared logic for use by get source, target, and head deltas functions\n    \"\"\"\nrewards = [Gwei(0)] * len(state.validators)\npenalties = [Gwei(0)] * len(state.validators)\ntotal_balance = get_total_active_balance(state)\nunslashed_attesting_indices = get_unslashed_attesting_indices(state, attestations)\nattesting_balance = get_total_balance(state, unslashed_attesting_indices)\nfor index in get_eligible_validator_indices(state):\nif index in unslashed_attesting_indices:\nincrement = EFFECTIVE_BALANCE_INCREMENT  # Factored out from balance totals to avoid uint64 overflow\nif is_in_inactivity_leak(state):\n# Since full base reward will be canceled out by inactivity penalty deltas,\n# optimal participation receives full base reward compensation here.\nrewards[index] += get_base_reward(state, index)\nelse:\nreward_numerator = get_base_reward(state, index) * (attesting_balance // increment)\nrewards[index] += reward_numerator // (total_balance // increment)\nelse:\npenalties[index] += get_base_reward(state, index)\nreturn rewards, penalties\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#components-of-attestation-deltas","title":"Components of attestation deltas","text":"<pre><code>def get_source_deltas(state: BeaconState) -&gt; Tuple[Sequence[Gwei], Sequence[Gwei]]:\n\"\"\"\n    Return attester micro-rewards/penalties for source-vote for each validator.\n    \"\"\"\nmatching_source_attestations = get_matching_source_attestations(state, get_previous_epoch(state))\nreturn get_attestation_component_deltas(state, matching_source_attestations)\n</code></pre> <pre><code>def get_target_deltas(state: BeaconState) -&gt; Tuple[Sequence[Gwei], Sequence[Gwei]]:\n\"\"\"\n    Return attester micro-rewards/penalties for target-vote for each validator.\n    \"\"\"\nmatching_target_attestations = get_matching_target_attestations(state, get_previous_epoch(state))\nreturn get_attestation_component_deltas(state, matching_target_attestations)\n</code></pre> <pre><code>def get_head_deltas(state: BeaconState) -&gt; Tuple[Sequence[Gwei], Sequence[Gwei]]:\n\"\"\"\n    Return attester micro-rewards/penalties for head-vote for each validator.\n    \"\"\"\nmatching_head_attestations = get_matching_head_attestations(state, get_previous_epoch(state))\nreturn get_attestation_component_deltas(state, matching_head_attestations)\n</code></pre> <pre><code>def get_inclusion_delay_deltas(state: BeaconState) -&gt; Tuple[Sequence[Gwei], Sequence[Gwei]]:\n\"\"\"\n    Return proposer and inclusion delay micro-rewards/penalties for each validator.\n    \"\"\"\nrewards = [Gwei(0) for _ in range(len(state.validators))]\nmatching_source_attestations = get_matching_source_attestations(state, get_previous_epoch(state))\nfor index in get_unslashed_attesting_indices(state, matching_source_attestations):\nattestation = min([\na for a in matching_source_attestations\nif index in get_attesting_indices(state, a)\n], key=lambda a: a.inclusion_delay)\nrewards[attestation.proposer_index] += get_proposer_reward(state, index)\nmax_attester_reward = Gwei(get_base_reward(state, index) - get_proposer_reward(state, index))\nrewards[index] += Gwei(max_attester_reward // attestation.inclusion_delay)\n# No penalties associated with inclusion delay\npenalties = [Gwei(0) for _ in range(len(state.validators))]\nreturn rewards, penalties\n</code></pre> <pre><code>def get_inactivity_penalty_deltas(state: BeaconState) -&gt; Tuple[Sequence[Gwei], Sequence[Gwei]]:\n\"\"\"\n    Return inactivity reward/penalty deltas for each validator.\n    \"\"\"\npenalties = [Gwei(0) for _ in range(len(state.validators))]\nif is_in_inactivity_leak(state):\nmatching_target_attestations = get_matching_target_attestations(state, get_previous_epoch(state))\nmatching_target_attesting_indices = get_unslashed_attesting_indices(state, matching_target_attestations)\nfor index in get_eligible_validator_indices(state):\n# If validator is performing optimally this cancels all rewards for a neutral balance\nbase_reward = get_base_reward(state, index)\npenalties[index] += Gwei(BASE_REWARDS_PER_EPOCH * base_reward - get_proposer_reward(state, index))\nif index not in matching_target_attesting_indices:\neffective_balance = state.validators[index].effective_balance\npenalties[index] += Gwei(effective_balance * get_finality_delay(state) // INACTIVITY_PENALTY_QUOTIENT)\n# No rewards associated with inactivity penalties\nrewards = [Gwei(0) for _ in range(len(state.validators))]\nreturn rewards, penalties\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#get_attestation_deltas","title":"<code>get_attestation_deltas</code>","text":"<pre><code>def get_attestation_deltas(state: BeaconState) -&gt; Tuple[Sequence[Gwei], Sequence[Gwei]]:\n\"\"\"\n    Return attestation reward/penalty deltas for each validator.\n    \"\"\"\nsource_rewards, source_penalties = get_source_deltas(state)\ntarget_rewards, target_penalties = get_target_deltas(state)\nhead_rewards, head_penalties = get_head_deltas(state)\ninclusion_delay_rewards, _ = get_inclusion_delay_deltas(state)\n_, inactivity_penalties = get_inactivity_penalty_deltas(state)\nrewards = [\nsource_rewards[i] + target_rewards[i] + head_rewards[i] + inclusion_delay_rewards[i]\nfor i in range(len(state.validators))\n]\npenalties = [\nsource_penalties[i] + target_penalties[i] + head_penalties[i] + inactivity_penalties[i]\nfor i in range(len(state.validators))\n]\nreturn rewards, penalties\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#process_rewards_and_penalties","title":"<code>process_rewards_and_penalties</code>","text":"<pre><code>def process_rewards_and_penalties(state: BeaconState) -&gt; None:\n# No rewards are applied at the end of `GENESIS_EPOCH` because rewards are for work done in the previous epoch\nif get_current_epoch(state) == GENESIS_EPOCH:\nreturn\nrewards, penalties = get_attestation_deltas(state)\nfor index in range(len(state.validators)):\nincrease_balance(state, ValidatorIndex(index), rewards[index])\ndecrease_balance(state, ValidatorIndex(index), penalties[index])\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#registry-updates","title":"Registry updates","text":"<pre><code>def process_registry_updates(state: BeaconState) -&gt; None:\n# Process activation eligibility and ejections\nfor index, validator in enumerate(state.validators):\nif is_eligible_for_activation_queue(validator):\nvalidator.activation_eligibility_epoch = get_current_epoch(state) + 1\nif (\nis_active_validator(validator, get_current_epoch(state))\nand validator.effective_balance &lt;= EJECTION_BALANCE\n):\ninitiate_validator_exit(state, ValidatorIndex(index))\n# Queue validators eligible for activation and not yet dequeued for activation\nactivation_queue = sorted([\nindex for index, validator in enumerate(state.validators)\nif is_eligible_for_activation(state, validator)\n# Order by the sequence of activation_eligibility_epoch setting and then index\n], key=lambda index: (state.validators[index].activation_eligibility_epoch, index))\n# Dequeued validators for activation up to churn limit\nfor index in activation_queue[:get_validator_churn_limit(state)]:\nvalidator = state.validators[index]\nvalidator.activation_epoch = compute_activation_exit_epoch(get_current_epoch(state))\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#slashings","title":"Slashings","text":"<pre><code>def process_slashings(state: BeaconState) -&gt; None:\nepoch = get_current_epoch(state)\ntotal_balance = get_total_active_balance(state)\nadjusted_total_slashing_balance = min(sum(state.slashings) * PROPORTIONAL_SLASHING_MULTIPLIER, total_balance)\nfor index, validator in enumerate(state.validators):\nif validator.slashed and epoch + EPOCHS_PER_SLASHINGS_VECTOR // 2 == validator.withdrawable_epoch:\nincrement = EFFECTIVE_BALANCE_INCREMENT  # Factored out from penalty numerator to avoid uint64 overflow\npenalty_numerator = validator.effective_balance // increment * adjusted_total_slashing_balance\npenalty = penalty_numerator // total_balance * increment\ndecrease_balance(state, ValidatorIndex(index), penalty)\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#eth1-data-votes-updates","title":"Eth1 data votes updates","text":"<pre><code>def process_eth1_data_reset(state: BeaconState) -&gt; None:\nnext_epoch = Epoch(get_current_epoch(state) + 1)\n# Reset eth1 data votes\nif next_epoch % EPOCHS_PER_ETH1_VOTING_PERIOD == 0:\nstate.eth1_data_votes = []\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#effective-balances-updates","title":"Effective balances updates","text":"<pre><code>def process_effective_balance_updates(state: BeaconState) -&gt; None:\n# Update effective balances with hysteresis\nfor index, validator in enumerate(state.validators):\nbalance = state.balances[index]\nHYSTERESIS_INCREMENT = uint64(EFFECTIVE_BALANCE_INCREMENT // HYSTERESIS_QUOTIENT)\nDOWNWARD_THRESHOLD = HYSTERESIS_INCREMENT * HYSTERESIS_DOWNWARD_MULTIPLIER\nUPWARD_THRESHOLD = HYSTERESIS_INCREMENT * HYSTERESIS_UPWARD_MULTIPLIER\nif (\nbalance + DOWNWARD_THRESHOLD &lt; validator.effective_balance\nor validator.effective_balance + UPWARD_THRESHOLD &lt; balance\n):\nvalidator.effective_balance = min(balance - balance % EFFECTIVE_BALANCE_INCREMENT, MAX_EFFECTIVE_BALANCE)\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#slashings-balances-updates","title":"Slashings balances updates","text":"<pre><code>def process_slashings_reset(state: BeaconState) -&gt; None:\nnext_epoch = Epoch(get_current_epoch(state) + 1)\n# Reset slashings\nstate.slashings[next_epoch % EPOCHS_PER_SLASHINGS_VECTOR] = Gwei(0)\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#randao-mixes-updates","title":"Randao mixes updates","text":"<pre><code>def process_randao_mixes_reset(state: BeaconState) -&gt; None:\ncurrent_epoch = get_current_epoch(state)\nnext_epoch = Epoch(current_epoch + 1)\n# Set randao mix\nstate.randao_mixes[next_epoch % EPOCHS_PER_HISTORICAL_VECTOR] = get_randao_mix(state, current_epoch)\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#historical-roots-updates","title":"Historical roots updates","text":"<pre><code>def process_historical_roots_update(state: BeaconState) -&gt; None:\n# Set historical root accumulator\nnext_epoch = Epoch(get_current_epoch(state) + 1)\nif next_epoch % (SLOTS_PER_HISTORICAL_ROOT // SLOTS_PER_EPOCH) == 0:\nhistorical_batch = HistoricalBatch(block_roots=state.block_roots, state_roots=state.state_roots)\nstate.historical_roots.append(hash_tree_root(historical_batch))\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#participation-records-rotation","title":"Participation records rotation","text":"<pre><code>def process_participation_record_updates(state: BeaconState) -&gt; None:\n# Rotate current/previous epoch attestations\nstate.previous_epoch_attestations = state.current_epoch_attestations\nstate.current_epoch_attestations = []\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#block-processing","title":"Block processing","text":"<pre><code>def process_block(state: BeaconState, block: BeaconBlock) -&gt; None:\nprocess_block_header(state, block)\nprocess_randao(state, block.body)\nprocess_eth1_data(state, block.body)\nprocess_operations(state, block.body)\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#block-header","title":"Block header","text":"<pre><code>def process_block_header(state: BeaconState, block: BeaconBlock) -&gt; None:\n# Verify that the slots match\nassert block.slot == state.slot\n# Verify that the block is newer than latest block header\nassert block.slot &gt; state.latest_block_header.slot\n# Verify that proposer index is the correct index\nassert block.proposer_index == get_beacon_proposer_index(state)\n# Verify that the parent matches\nassert block.parent_root == hash_tree_root(state.latest_block_header)\n# Cache current block as the new latest block\nstate.latest_block_header = BeaconBlockHeader(\nslot=block.slot,\nproposer_index=block.proposer_index,\nparent_root=block.parent_root,\nstate_root=Bytes32(),  # Overwritten in the next process_slot call\nbody_root=hash_tree_root(block.body),\n)\n# Verify proposer is not slashed\nproposer = state.validators[block.proposer_index]\nassert not proposer.slashed\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#randao","title":"RANDAO","text":"<pre><code>def process_randao(state: BeaconState, body: BeaconBlockBody) -&gt; None:\nepoch = get_current_epoch(state)\n# Verify RANDAO reveal\nproposer = state.validators[get_beacon_proposer_index(state)]\nsigning_root = compute_signing_root(epoch, get_domain(state, DOMAIN_RANDAO))\nassert bls.Verify(proposer.pubkey, signing_root, body.randao_reveal)\n# Mix in RANDAO reveal\nmix = xor(get_randao_mix(state, epoch), hash(body.randao_reveal))\nstate.randao_mixes[epoch % EPOCHS_PER_HISTORICAL_VECTOR] = mix\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#eth1-data","title":"Eth1 data","text":"<pre><code>def process_eth1_data(state: BeaconState, body: BeaconBlockBody) -&gt; None:\nstate.eth1_data_votes.append(body.eth1_data)\nif state.eth1_data_votes.count(body.eth1_data) * 2 &gt; EPOCHS_PER_ETH1_VOTING_PERIOD * SLOTS_PER_EPOCH:\nstate.eth1_data = body.eth1_data\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#operations","title":"Operations","text":"<pre><code>def process_operations(state: BeaconState, body: BeaconBlockBody) -&gt; None:\n# Verify that outstanding deposits are processed up to the maximum number of deposits\nassert len(body.deposits) == min(MAX_DEPOSITS, state.eth1_data.deposit_count - state.eth1_deposit_index)\ndef for_ops(operations: Sequence[Any], fn: Callable[[BeaconState, Any], None]) -&gt; None:\nfor operation in operations:\nfn(state, operation)\nfor_ops(body.proposer_slashings, process_proposer_slashing)\nfor_ops(body.attester_slashings, process_attester_slashing)\nfor_ops(body.attestations, process_attestation)\nfor_ops(body.deposits, process_deposit)\nfor_ops(body.voluntary_exits, process_voluntary_exit)\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#proposer-slashings","title":"Proposer slashings","text":"<pre><code>def process_proposer_slashing(state: BeaconState, proposer_slashing: ProposerSlashing) -&gt; None:\nheader_1 = proposer_slashing.signed_header_1.message\nheader_2 = proposer_slashing.signed_header_2.message\n# Verify header slots match\nassert header_1.slot == header_2.slot\n# Verify header proposer indices match\nassert header_1.proposer_index == header_2.proposer_index\n# Verify the headers are different\nassert header_1 != header_2\n# Verify the proposer is slashable\nproposer = state.validators[header_1.proposer_index]\nassert is_slashable_validator(proposer, get_current_epoch(state))\n# Verify signatures\nfor signed_header in (proposer_slashing.signed_header_1, proposer_slashing.signed_header_2):\ndomain = get_domain(state, DOMAIN_BEACON_PROPOSER, compute_epoch_at_slot(signed_header.message.slot))\nsigning_root = compute_signing_root(signed_header.message, domain)\nassert bls.Verify(proposer.pubkey, signing_root, signed_header.signature)\nslash_validator(state, header_1.proposer_index)\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#attester-slashings","title":"Attester slashings","text":"<pre><code>def process_attester_slashing(state: BeaconState, attester_slashing: AttesterSlashing) -&gt; None:\nattestation_1 = attester_slashing.attestation_1\nattestation_2 = attester_slashing.attestation_2\nassert is_slashable_attestation_data(attestation_1.data, attestation_2.data)\nassert is_valid_indexed_attestation(state, attestation_1)\nassert is_valid_indexed_attestation(state, attestation_2)\nslashed_any = False\nindices = set(attestation_1.attesting_indices).intersection(attestation_2.attesting_indices)\nfor index in sorted(indices):\nif is_slashable_validator(state.validators[index], get_current_epoch(state)):\nslash_validator(state, index)\nslashed_any = True\nassert slashed_any\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#attestations","title":"Attestations","text":"<pre><code>def process_attestation(state: BeaconState, attestation: Attestation) -&gt; None:\ndata = attestation.data\nassert data.target.epoch in (get_previous_epoch(state), get_current_epoch(state))\nassert data.target.epoch == compute_epoch_at_slot(data.slot)\nassert data.slot + MIN_ATTESTATION_INCLUSION_DELAY &lt;= state.slot &lt;= data.slot + SLOTS_PER_EPOCH\nassert data.index &lt; get_committee_count_per_slot(state, data.target.epoch)\ncommittee = get_beacon_committee(state, data.slot, data.index)\nassert len(attestation.aggregation_bits) == len(committee)\npending_attestation = PendingAttestation(\ndata=data,\naggregation_bits=attestation.aggregation_bits,\ninclusion_delay=state.slot - data.slot,\nproposer_index=get_beacon_proposer_index(state),\n)\nif data.target.epoch == get_current_epoch(state):\nassert data.source == state.current_justified_checkpoint\nstate.current_epoch_attestations.append(pending_attestation)\nelse:\nassert data.source == state.previous_justified_checkpoint\nstate.previous_epoch_attestations.append(pending_attestation)\n# Verify signature\nassert is_valid_indexed_attestation(state, get_indexed_attestation(state, attestation))\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#deposits","title":"Deposits","text":"<pre><code>def get_validator_from_deposit(pubkey: BLSPubkey, withdrawal_credentials: Bytes32, amount: uint64) -&gt; Validator:\neffective_balance = min(amount - amount % EFFECTIVE_BALANCE_INCREMENT, MAX_EFFECTIVE_BALANCE)\nreturn Validator(\npubkey=pubkey,\nwithdrawal_credentials=withdrawal_credentials,\nactivation_eligibility_epoch=FAR_FUTURE_EPOCH,\nactivation_epoch=FAR_FUTURE_EPOCH,\nexit_epoch=FAR_FUTURE_EPOCH,\nwithdrawable_epoch=FAR_FUTURE_EPOCH,\neffective_balance=effective_balance,\n)\n</code></pre> <pre><code>def add_validator_to_registry(state: BeaconState,\npubkey: BLSPubkey,\nwithdrawal_credentials: Bytes32,\namount: uint64) -&gt; None:\nstate.validators.append(get_validator_from_deposit(pubkey, withdrawal_credentials, amount))\nstate.balances.append(amount)\n</code></pre> <pre><code>def apply_deposit(state: BeaconState,\npubkey: BLSPubkey,\nwithdrawal_credentials: Bytes32,\namount: uint64,\nsignature: BLSSignature) -&gt; None:\nvalidator_pubkeys = [v.pubkey for v in state.validators]\nif pubkey not in validator_pubkeys:\n# Verify the deposit signature (proof of possession) which is not checked by the deposit contract\ndeposit_message = DepositMessage(\npubkey=pubkey,\nwithdrawal_credentials=withdrawal_credentials,\namount=amount,\n)\ndomain = compute_domain(DOMAIN_DEPOSIT)  # Fork-agnostic domain since deposits are valid across forks\nsigning_root = compute_signing_root(deposit_message, domain)\nif bls.Verify(pubkey, signing_root, signature):\nadd_validator_to_registry(state, pubkey, withdrawal_credentials, amount)\nelse:\n# Increase balance by deposit amount\nindex = ValidatorIndex(validator_pubkeys.index(pubkey))\nincrease_balance(state, index, amount)\n</code></pre> <pre><code>def process_deposit(state: BeaconState, deposit: Deposit) -&gt; None:\n# Verify the Merkle branch\nassert is_valid_merkle_branch(\nleaf=hash_tree_root(deposit.data),\nbranch=deposit.proof,\ndepth=DEPOSIT_CONTRACT_TREE_DEPTH + 1,  # Add 1 for the List length mix-in\nindex=state.eth1_deposit_index,\nroot=state.eth1_data.deposit_root,\n)\n# Deposits must be processed in order\nstate.eth1_deposit_index += 1\napply_deposit(\nstate=state,\npubkey=deposit.data.pubkey,\nwithdrawal_credentials=deposit.data.withdrawal_credentials,\namount=deposit.data.amount,\nsignature=deposit.data.signature,\n)\n</code></pre>"},{"location":"specs/phase0/beacon-chain/#voluntary-exits","title":"Voluntary exits","text":"<pre><code>def process_voluntary_exit(state: BeaconState, signed_voluntary_exit: SignedVoluntaryExit) -&gt; None:\nvoluntary_exit = signed_voluntary_exit.message\nvalidator = state.validators[voluntary_exit.validator_index]\n# Verify the validator is active\nassert is_active_validator(validator, get_current_epoch(state))\n# Verify exit has not been initiated\nassert validator.exit_epoch == FAR_FUTURE_EPOCH\n# Exits must specify an epoch when they become valid; they are not valid before then\nassert get_current_epoch(state) &gt;= voluntary_exit.epoch\n# Verify the validator has been active long enough\nassert get_current_epoch(state) &gt;= validator.activation_epoch + SHARD_COMMITTEE_PERIOD\n# Verify signature\ndomain = get_domain(state, DOMAIN_VOLUNTARY_EXIT, voluntary_exit.epoch)\nsigning_root = compute_signing_root(voluntary_exit, domain)\nassert bls.Verify(validator.pubkey, signing_root, signed_voluntary_exit.signature)\n# Initiate exit\ninitiate_validator_exit(state, voluntary_exit.validator_index)\n</code></pre>"},{"location":"specs/phase0/deposit-contract/","title":"Phase 0 -- Deposit Contract","text":""},{"location":"specs/phase0/deposit-contract/#table-of-contents","title":"Table of contents","text":"<ul> <li>Introduction</li> <li>Constants</li> <li>Configuration</li> <li>Staking deposit contract</li> <li><code>deposit</code> function<ul> <li>Deposit amount</li> <li>Withdrawal credentials</li> <li><code>DepositEvent</code> log</li> </ul> </li> <li>Solidity code</li> </ul>"},{"location":"specs/phase0/deposit-contract/#introduction","title":"Introduction","text":"<p>This document represents the specification for the beacon chain deposit contract, part of Phase 0.</p>"},{"location":"specs/phase0/deposit-contract/#constants","title":"Constants","text":"<p>The following values are (non-configurable) constants used throughout the specification.</p> Name Value <code>DEPOSIT_CONTRACT_TREE_DEPTH</code> <code>2**5</code> (= 32)"},{"location":"specs/phase0/deposit-contract/#configuration","title":"Configuration","text":"<p>Note: The default mainnet configuration values are included here for spec-design purposes. The different configurations for mainnet, testnets, and YAML-based testing can be found in the <code>configs/constant_presets</code> directory. These configurations are updated for releases and may be out of sync during <code>dev</code> changes.</p> Name Value <code>DEPOSIT_CHAIN_ID</code> <code>1</code> <code>DEPOSIT_NETWORK_ID</code> <code>1</code> <code>DEPOSIT_CONTRACT_ADDRESS</code> <code>0x00000000219ab540356cBB839Cbe05303d7705Fa</code>"},{"location":"specs/phase0/deposit-contract/#staking-deposit-contract","title":"Staking deposit contract","text":"<p>The initial deployment phases of Ethereum proof-of-stake are implemented without consensus changes to the existing Ethereum proof-of-work chain. A deposit contract at address <code>DEPOSIT_CONTRACT_ADDRESS</code> is added to the Ethereum proof-of-work chain defined by the chain-id -- <code>DEPOSIT_CHAIN_ID</code> -- and the network-id -- <code>DEPOSIT_NETWORK_ID</code> -- for deposits of ETH to the beacon chain. Validator balances will be withdrawable to the execution-layer in a followup fork after Bellatrix upgrade.</p> <p>Note: See here for a comprehensive list of public Ethereum chain chain-id's and network-id's.</p>"},{"location":"specs/phase0/deposit-contract/#deposit-function","title":"<code>deposit</code> function","text":"<p>The deposit contract has a public <code>deposit</code> function to make deposits. It takes as arguments <code>bytes calldata pubkey, bytes calldata withdrawal_credentials, bytes calldata signature, bytes32 deposit_data_root</code>. The first three arguments populate a <code>DepositData</code> object, and <code>deposit_data_root</code> is the expected <code>DepositData</code> root as a protection against malformatted calldata.</p>"},{"location":"specs/phase0/deposit-contract/#deposit-amount","title":"Deposit amount","text":"<p>The amount of ETH (rounded down to the closest Gwei) sent to the deposit contract is the deposit amount, which must be of size at least <code>MIN_DEPOSIT_AMOUNT</code> Gwei. Note that ETH consumed by the deposit contract is no longer usable on the execution-layer until sometime after Bellatrix upgrade.</p>"},{"location":"specs/phase0/deposit-contract/#withdrawal-credentials","title":"Withdrawal credentials","text":"<p>One of the <code>DepositData</code> fields is <code>withdrawal_credentials</code> which constrains validator withdrawals. The first byte of this 32-byte field is a withdrawal prefix which defines the semantics of the remaining 31 bytes. The withdrawal prefixes currently supported are <code>BLS_WITHDRAWAL_PREFIX</code> and <code>ETH1_ADDRESS_WITHDRAWAL_PREFIX</code>. Read more in the validator guide.</p> <p>Note: The deposit contract does not validate the <code>withdrawal_credentials</code> field. Support for new withdrawal prefixes can be added without modifying the deposit contract.</p>"},{"location":"specs/phase0/deposit-contract/#depositevent-log","title":"<code>DepositEvent</code> log","text":"<p>Every deposit emits a <code>DepositEvent</code> log for consumption by the beacon chain. The deposit contract does little validation, pushing most of the validator onboarding logic to the beacon chain. In particular, the proof of possession (a BLS12-381 signature) is not verified by the deposit contract.</p>"},{"location":"specs/phase0/deposit-contract/#solidity-code","title":"Solidity code","text":"<p>The deposit contract source code, written in Solidity, is available here.</p> <p>Note: To save on gas, the deposit contract uses a progressive Merkle root calculation algorithm that requires only O(log(n)) storage. See here for a Python implementation, and here for a formal correctness proof.</p>"},{"location":"specs/phase0/fork-choice/","title":"Phase 0 -- Beacon Chain Fork Choice","text":""},{"location":"specs/phase0/fork-choice/#table-of-contents","title":"Table of contents","text":"<ul> <li>Introduction</li> <li>Fork choice</li> <li>Constant</li> <li>Configuration</li> <li>Helpers<ul> <li><code>LatestMessage</code></li> <li><code>Store</code></li> <li><code>is_previous_epoch_justified</code></li> <li><code>get_forkchoice_store</code></li> <li><code>get_slots_since_genesis</code></li> <li><code>get_current_slot</code></li> <li><code>get_current_store_epoch</code></li> <li><code>compute_slots_since_epoch_start</code></li> <li><code>get_ancestor</code></li> <li><code>calculate_committee_fraction</code></li> <li><code>get_checkpoint_block</code></li> <li><code>get_proposer_score</code></li> <li><code>get_weight</code></li> <li><code>get_voting_source</code></li> <li><code>filter_block_tree</code></li> <li><code>get_filtered_block_tree</code></li> <li><code>get_head</code></li> <li><code>update_checkpoints</code></li> <li><code>update_unrealized_checkpoints</code></li> <li>Proposer head and reorg helpers</li> <li><code>is_head_late</code></li> <li><code>is_shuffling_stable</code></li> <li><code>is_ffg_competitive</code></li> <li><code>is_finalization_ok</code></li> <li><code>is_proposing_on_time</code></li> <li><code>is_head_weak</code></li> <li><code>is_parent_strong</code></li> <li><code>get_proposer_head</code></li> <li>Pull-up tip helpers</li> <li><code>compute_pulled_up_tip</code></li> <li><code>on_tick</code> helpers</li> <li><code>on_tick_per_slot</code></li> <li><code>on_attestation</code> helpers</li> <li><code>validate_target_epoch_against_current_time</code></li> <li><code>validate_on_attestation</code></li> <li><code>store_target_checkpoint_state</code></li> <li><code>update_latest_messages</code></li> </ul> </li> <li>Handlers<ul> <li><code>on_tick</code></li> <li><code>on_block</code></li> <li><code>on_attestation</code></li> <li><code>on_attester_slashing</code></li> </ul> </li> </ul>"},{"location":"specs/phase0/fork-choice/#introduction","title":"Introduction","text":"<p>This document is the beacon chain fork choice spec, part of Phase 0. It assumes the beacon chain state transition function spec.</p>"},{"location":"specs/phase0/fork-choice/#fork-choice","title":"Fork choice","text":"<p>The head block root associated with a <code>store</code> is defined as <code>get_head(store)</code>. At genesis, let <code>store = get_forkchoice_store(genesis_state, genesis_block)</code> and update <code>store</code> by running:</p> <ul> <li><code>on_tick(store, time)</code> whenever <code>time &gt; store.time</code> where <code>time</code> is the current Unix time</li> <li><code>on_block(store, block)</code> whenever a block <code>block: SignedBeaconBlock</code> is received</li> <li><code>on_attestation(store, attestation)</code> whenever an attestation <code>attestation</code> is received</li> <li><code>on_attester_slashing(store, attester_slashing)</code> whenever an attester slashing <code>attester_slashing</code> is received</li> </ul> <p>Any of the above handlers that trigger an unhandled exception (e.g. a failed assert or an out-of-range list access) are considered invalid. Invalid calls to handlers must not modify <code>store</code>.</p> <p>Notes:</p> <p>1) Leap seconds: Slots will last <code>SECONDS_PER_SLOT + 1</code> or <code>SECONDS_PER_SLOT - 1</code> seconds around leap seconds. This is automatically handled by UNIX time. 2) Honest clocks: Honest nodes are assumed to have clocks synchronized within <code>SECONDS_PER_SLOT</code> seconds of each other. 3) Eth1 data: The large <code>ETH1_FOLLOW_DISTANCE</code> specified in the honest validator document should ensure that <code>state.latest_eth1_data</code> of the canonical beacon chain remains consistent with the canonical Ethereum proof-of-work chain. If not, emergency manual intervention will be required. 4) Manual forks: Manual forks may arbitrarily change the fork choice rule but are expected to be enacted at epoch transitions, with the fork details reflected in <code>state.fork</code>. 5) Implementation: The implementation found in this specification is constructed for ease of understanding rather than for optimization in computation, space, or any other resource. A number of optimized alternatives can be found here.</p>"},{"location":"specs/phase0/fork-choice/#constant","title":"Constant","text":"Name Value <code>INTERVALS_PER_SLOT</code> <code>uint64(3)</code>"},{"location":"specs/phase0/fork-choice/#configuration","title":"Configuration","text":"Name Value <code>PROPOSER_SCORE_BOOST</code> <code>uint64(40)</code> <code>REORG_HEAD_WEIGHT_THRESHOLD</code> <code>uint64(20)</code> <code>REORG_PARENT_WEIGHT_THRESHOLD</code> <code>uint64(160)</code> <code>REORG_MAX_EPOCHS_SINCE_FINALIZATION</code> <code>Epoch(2)</code> <ul> <li>The proposer score boost and re-org weight threshold are percentage   values that are measured with respect to the weight of a single committee. See   <code>calculate_committee_fraction</code>.</li> </ul>"},{"location":"specs/phase0/fork-choice/#helpers","title":"Helpers","text":""},{"location":"specs/phase0/fork-choice/#latestmessage","title":"<code>LatestMessage</code>","text":"<pre><code>@dataclass(eq=True, frozen=True)\nclass LatestMessage(object):\nepoch: Epoch\nroot: Root\n</code></pre>"},{"location":"specs/phase0/fork-choice/#store","title":"<code>Store</code>","text":"<p>The <code>Store</code> is responsible for tracking information required for the fork choice algorithm. The important fields being tracked are described below:</p> <ul> <li><code>justified_checkpoint</code>: the justified checkpoint used as the starting point for the LMD GHOST fork choice algorithm.</li> <li><code>finalized_checkpoint</code>: the highest known finalized checkpoint. The fork choice only considers blocks that are not conflicting with this checkpoint.</li> <li><code>unrealized_justified_checkpoint</code> &amp; <code>unrealized_finalized_checkpoint</code>: these track the highest justified &amp; finalized checkpoints resp., without regard to whether on-chain realization has occurred, i.e. FFG processing of new attestations within the state transition function. This is an important distinction from <code>justified_checkpoint</code> &amp; <code>finalized_checkpoint</code>, because they will only track the checkpoints that are realized on-chain. Note that on-chain processing of FFG information only happens at epoch boundaries.</li> <li><code>unrealized_justifications</code>: stores a map of block root to the unrealized justified checkpoint observed in that block.</li> </ul> <pre><code>@dataclass\nclass Store(object):\ntime: uint64\ngenesis_time: uint64\njustified_checkpoint: Checkpoint\nfinalized_checkpoint: Checkpoint\nunrealized_justified_checkpoint: Checkpoint\nunrealized_finalized_checkpoint: Checkpoint\nproposer_boost_root: Root\nequivocating_indices: Set[ValidatorIndex]\nblocks: Dict[Root, BeaconBlock] = field(default_factory=dict)\nblock_states: Dict[Root, BeaconState] = field(default_factory=dict)\nblock_timeliness: Dict[Root, boolean] = field(default_factory=dict)\ncheckpoint_states: Dict[Checkpoint, BeaconState] = field(default_factory=dict)\nlatest_messages: Dict[ValidatorIndex, LatestMessage] = field(default_factory=dict)\nunrealized_justifications: Dict[Root, Checkpoint] = field(default_factory=dict)\n</code></pre>"},{"location":"specs/phase0/fork-choice/#is_previous_epoch_justified","title":"<code>is_previous_epoch_justified</code>","text":"<pre><code>def is_previous_epoch_justified(store: Store) -&gt; bool:\ncurrent_epoch = get_current_store_epoch(store)\nreturn store.justified_checkpoint.epoch + 1 == current_epoch\n</code></pre>"},{"location":"specs/phase0/fork-choice/#get_forkchoice_store","title":"<code>get_forkchoice_store</code>","text":"<p>The provided anchor-state will be regarded as a trusted state, to not roll back beyond. This should be the genesis state for a full client.</p> <p>Note With regards to fork choice, block headers are interchangeable with blocks. The spec is likely to move to headers for reduced overhead in test vectors and better encapsulation. Full implementations store blocks as part of their database and will often use full blocks when dealing with production fork choice.</p> <pre><code>def get_forkchoice_store(anchor_state: BeaconState, anchor_block: BeaconBlock) -&gt; Store:\nassert anchor_block.state_root == hash_tree_root(anchor_state)\nanchor_root = hash_tree_root(anchor_block)\nanchor_epoch = get_current_epoch(anchor_state)\njustified_checkpoint = Checkpoint(epoch=anchor_epoch, root=anchor_root)\nfinalized_checkpoint = Checkpoint(epoch=anchor_epoch, root=anchor_root)\nproposer_boost_root = Root()\nreturn Store(\ntime=uint64(anchor_state.genesis_time + SECONDS_PER_SLOT * anchor_state.slot),\ngenesis_time=anchor_state.genesis_time,\njustified_checkpoint=justified_checkpoint,\nfinalized_checkpoint=finalized_checkpoint,\nunrealized_justified_checkpoint=justified_checkpoint,\nunrealized_finalized_checkpoint=finalized_checkpoint,\nproposer_boost_root=proposer_boost_root,\nequivocating_indices=set(),\nblocks={anchor_root: copy(anchor_block)},\nblock_states={anchor_root: copy(anchor_state)},\ncheckpoint_states={justified_checkpoint: copy(anchor_state)},\nunrealized_justifications={anchor_root: justified_checkpoint}\n)\n</code></pre>"},{"location":"specs/phase0/fork-choice/#get_slots_since_genesis","title":"<code>get_slots_since_genesis</code>","text":"<pre><code>def get_slots_since_genesis(store: Store) -&gt; int:\nreturn (store.time - store.genesis_time) // SECONDS_PER_SLOT\n</code></pre>"},{"location":"specs/phase0/fork-choice/#get_current_slot","title":"<code>get_current_slot</code>","text":"<pre><code>def get_current_slot(store: Store) -&gt; Slot:\nreturn Slot(GENESIS_SLOT + get_slots_since_genesis(store))\n</code></pre>"},{"location":"specs/phase0/fork-choice/#get_current_store_epoch","title":"<code>get_current_store_epoch</code>","text":"<pre><code>def get_current_store_epoch(store: Store) -&gt; Epoch:\nreturn compute_epoch_at_slot(get_current_slot(store))\n</code></pre>"},{"location":"specs/phase0/fork-choice/#compute_slots_since_epoch_start","title":"<code>compute_slots_since_epoch_start</code>","text":"<pre><code>def compute_slots_since_epoch_start(slot: Slot) -&gt; int:\nreturn slot - compute_start_slot_at_epoch(compute_epoch_at_slot(slot))\n</code></pre>"},{"location":"specs/phase0/fork-choice/#get_ancestor","title":"<code>get_ancestor</code>","text":"<pre><code>def get_ancestor(store: Store, root: Root, slot: Slot) -&gt; Root:\nblock = store.blocks[root]\nif block.slot &gt; slot:\nreturn get_ancestor(store, block.parent_root, slot)\nreturn root\n</code></pre>"},{"location":"specs/phase0/fork-choice/#calculate_committee_fraction","title":"<code>calculate_committee_fraction</code>","text":"<pre><code>def calculate_committee_fraction(state: BeaconState, committee_percent: uint64) -&gt; Gwei:\ncommittee_weight = get_total_active_balance(state) // SLOTS_PER_EPOCH\nreturn Gwei((committee_weight * committee_percent) // 100)\n</code></pre>"},{"location":"specs/phase0/fork-choice/#get_checkpoint_block","title":"<code>get_checkpoint_block</code>","text":"<pre><code>def get_checkpoint_block(store: Store, root: Root, epoch: Epoch) -&gt; Root:\n\"\"\"\n    Compute the checkpoint block for epoch ``epoch`` in the chain of block ``root``\n    \"\"\"\nepoch_first_slot = compute_start_slot_at_epoch(epoch)\nreturn get_ancestor(store, root, epoch_first_slot)\n</code></pre>"},{"location":"specs/phase0/fork-choice/#get_proposer_score","title":"<code>get_proposer_score</code>","text":"<pre><code>def get_proposer_score(store: Store) -&gt; Gwei:\njustified_checkpoint_state = store.checkpoint_states[store.justified_checkpoint]\ncommittee_weight = get_total_active_balance(justified_checkpoint_state) // SLOTS_PER_EPOCH\nreturn (committee_weight * PROPOSER_SCORE_BOOST) // 100\n</code></pre>"},{"location":"specs/phase0/fork-choice/#get_weight","title":"<code>get_weight</code>","text":"<pre><code>def get_weight(store: Store, root: Root) -&gt; Gwei:\nstate = store.checkpoint_states[store.justified_checkpoint]\nunslashed_and_active_indices = [\ni for i in get_active_validator_indices(state, get_current_epoch(state))\nif not state.validators[i].slashed\n]\nattestation_score = Gwei(sum(\nstate.validators[i].effective_balance for i in unslashed_and_active_indices\nif (i in store.latest_messages\nand i not in store.equivocating_indices\nand get_ancestor(store, store.latest_messages[i].root, store.blocks[root].slot) == root)\n))\nif store.proposer_boost_root == Root():\n# Return only attestation score if ``proposer_boost_root`` is not set\nreturn attestation_score\n# Calculate proposer score if ``proposer_boost_root`` is set\nproposer_score = Gwei(0)\n# Boost is applied if ``root`` is an ancestor of ``proposer_boost_root``\nif get_ancestor(store, store.proposer_boost_root, store.blocks[root].slot) == root:\nproposer_score = get_proposer_score(store)\nreturn attestation_score + proposer_score\n</code></pre>"},{"location":"specs/phase0/fork-choice/#get_voting_source","title":"<code>get_voting_source</code>","text":"<pre><code>def get_voting_source(store: Store, block_root: Root) -&gt; Checkpoint:\n\"\"\"\n    Compute the voting source checkpoint in event that block with root ``block_root`` is the head block\n    \"\"\"\nblock = store.blocks[block_root]\ncurrent_epoch = get_current_store_epoch(store)\nblock_epoch = compute_epoch_at_slot(block.slot)\nif current_epoch &gt; block_epoch:\n# The block is from a prior epoch, the voting source will be pulled-up\nreturn store.unrealized_justifications[block_root]\nelse:\n# The block is not from a prior epoch, therefore the voting source is not pulled up\nhead_state = store.block_states[block_root]\nreturn head_state.current_justified_checkpoint\n</code></pre>"},{"location":"specs/phase0/fork-choice/#filter_block_tree","title":"<code>filter_block_tree</code>","text":"<p>Note: External calls to <code>filter_block_tree</code> (i.e., any calls that are not made by the recursive logic in this function) MUST set <code>block_root</code> to <code>store.justified_checkpoint</code>.</p> <pre><code>def filter_block_tree(store: Store, block_root: Root, blocks: Dict[Root, BeaconBlock]) -&gt; bool:\nblock = store.blocks[block_root]\nchildren = [\nroot for root in store.blocks.keys()\nif store.blocks[root].parent_root == block_root\n]\n# If any children branches contain expected finalized/justified checkpoints,\n# add to filtered block-tree and signal viability to parent.\nif any(children):\nfilter_block_tree_result = [filter_block_tree(store, child, blocks) for child in children]\nif any(filter_block_tree_result):\nblocks[block_root] = block\nreturn True\nreturn False\ncurrent_epoch = get_current_store_epoch(store)\nvoting_source = get_voting_source(store, block_root)\n# The voting source should be either at the same height as the store's justified checkpoint or\n# not more than two epochs ago\ncorrect_justified = (\nstore.justified_checkpoint.epoch == GENESIS_EPOCH\nor voting_source.epoch == store.justified_checkpoint.epoch\nor voting_source.epoch + 2 &gt;= current_epoch\n)\nfinalized_checkpoint_block = get_checkpoint_block(\nstore,\nblock_root,\nstore.finalized_checkpoint.epoch,\n)\ncorrect_finalized = (\nstore.finalized_checkpoint.epoch == GENESIS_EPOCH\nor store.finalized_checkpoint.root == finalized_checkpoint_block\n)\n# If expected finalized/justified, add to viable block-tree and signal viability to parent.\nif correct_justified and correct_finalized:\nblocks[block_root] = block\nreturn True\n# Otherwise, branch not viable\nreturn False\n</code></pre>"},{"location":"specs/phase0/fork-choice/#get_filtered_block_tree","title":"<code>get_filtered_block_tree</code>","text":"<pre><code>def get_filtered_block_tree(store: Store) -&gt; Dict[Root, BeaconBlock]:\n\"\"\"\n    Retrieve a filtered block tree from ``store``, only returning branches\n    whose leaf state's justified/finalized info agrees with that in ``store``.\n    \"\"\"\nbase = store.justified_checkpoint.root\nblocks: Dict[Root, BeaconBlock] = {}\nfilter_block_tree(store, base, blocks)\nreturn blocks\n</code></pre>"},{"location":"specs/phase0/fork-choice/#get_head","title":"<code>get_head</code>","text":"<pre><code>def get_head(store: Store) -&gt; Root:\n# Get filtered block tree that only includes viable branches\nblocks = get_filtered_block_tree(store)\n# Execute the LMD-GHOST fork choice\nhead = store.justified_checkpoint.root\nwhile True:\nchildren = [\nroot for root in blocks.keys()\nif blocks[root].parent_root == head\n]\nif len(children) == 0:\nreturn head\n# Sort by latest attesting balance with ties broken lexicographically\n# Ties broken by favoring block with lexicographically higher root\nhead = max(children, key=lambda root: (get_weight(store, root), root))\n</code></pre>"},{"location":"specs/phase0/fork-choice/#update_checkpoints","title":"<code>update_checkpoints</code>","text":"<pre><code>def update_checkpoints(store: Store, justified_checkpoint: Checkpoint, finalized_checkpoint: Checkpoint) -&gt; None:\n\"\"\"\n    Update checkpoints in store if necessary\n    \"\"\"\n# Update justified checkpoint\nif justified_checkpoint.epoch &gt; store.justified_checkpoint.epoch:\nstore.justified_checkpoint = justified_checkpoint\n# Update finalized checkpoint\nif finalized_checkpoint.epoch &gt; store.finalized_checkpoint.epoch:\nstore.finalized_checkpoint = finalized_checkpoint\n</code></pre>"},{"location":"specs/phase0/fork-choice/#update_unrealized_checkpoints","title":"<code>update_unrealized_checkpoints</code>","text":"<pre><code>def update_unrealized_checkpoints(store: Store, unrealized_justified_checkpoint: Checkpoint,\nunrealized_finalized_checkpoint: Checkpoint) -&gt; None:\n\"\"\"\n    Update unrealized checkpoints in store if necessary\n    \"\"\"\n# Update unrealized justified checkpoint\nif unrealized_justified_checkpoint.epoch &gt; store.unrealized_justified_checkpoint.epoch:\nstore.unrealized_justified_checkpoint = unrealized_justified_checkpoint\n# Update unrealized finalized checkpoint\nif unrealized_finalized_checkpoint.epoch &gt; store.unrealized_finalized_checkpoint.epoch:\nstore.unrealized_finalized_checkpoint = unrealized_finalized_checkpoint\n</code></pre>"},{"location":"specs/phase0/fork-choice/#proposer-head-and-reorg-helpers","title":"Proposer head and reorg helpers","text":"<p>Implementing these helpers is optional.</p>"},{"location":"specs/phase0/fork-choice/#is_head_late","title":"<code>is_head_late</code>","text":"<pre><code>def is_head_late(store: Store, head_root: Root) -&gt; bool:\nreturn not store.block_timeliness[head_root]\n</code></pre>"},{"location":"specs/phase0/fork-choice/#is_shuffling_stable","title":"<code>is_shuffling_stable</code>","text":"<pre><code>def is_shuffling_stable(slot: Slot) -&gt; bool:\nreturn slot % SLOTS_PER_EPOCH != 0\n</code></pre>"},{"location":"specs/phase0/fork-choice/#is_ffg_competitive","title":"<code>is_ffg_competitive</code>","text":"<pre><code>def is_ffg_competitive(store: Store, head_root: Root, parent_root: Root) -&gt; bool:\nreturn (store.unrealized_justifications[head_root] == store.unrealized_justifications[parent_root])\n</code></pre>"},{"location":"specs/phase0/fork-choice/#is_finalization_ok","title":"<code>is_finalization_ok</code>","text":"<pre><code>def is_finalization_ok(store: Store, slot: Slot) -&gt; bool:\nepochs_since_finalization = compute_epoch_at_slot(slot) - store.finalized_checkpoint.epoch\nreturn epochs_since_finalization &lt;= REORG_MAX_EPOCHS_SINCE_FINALIZATION\n</code></pre>"},{"location":"specs/phase0/fork-choice/#is_proposing_on_time","title":"<code>is_proposing_on_time</code>","text":"<pre><code>def is_proposing_on_time(store: Store) -&gt; bool:\n# Use half `SECONDS_PER_SLOT // INTERVALS_PER_SLOT` as the proposer reorg deadline\ntime_into_slot = (store.time - store.genesis_time) % SECONDS_PER_SLOT\nproposer_reorg_cutoff = SECONDS_PER_SLOT // INTERVALS_PER_SLOT // 2\nreturn time_into_slot &lt;= proposer_reorg_cutoff\n</code></pre>"},{"location":"specs/phase0/fork-choice/#is_head_weak","title":"<code>is_head_weak</code>","text":"<pre><code>def is_head_weak(store: Store, head_root: Root) -&gt; bool:\njustified_state = store.checkpoint_states[store.justified_checkpoint]\nreorg_threshold = calculate_committee_fraction(justified_state, REORG_HEAD_WEIGHT_THRESHOLD)\nhead_weight = get_weight(store, head_root)\nreturn head_weight &lt; reorg_threshold\n</code></pre>"},{"location":"specs/phase0/fork-choice/#is_parent_strong","title":"<code>is_parent_strong</code>","text":"<pre><code>def is_parent_strong(store: Store, parent_root: Root) -&gt; bool:\njustified_state = store.checkpoint_states[store.justified_checkpoint]\nparent_threshold = calculate_committee_fraction(justified_state, REORG_PARENT_WEIGHT_THRESHOLD)\nparent_weight = get_weight(store, parent_root)\nreturn parent_weight &gt; parent_threshold\n</code></pre>"},{"location":"specs/phase0/fork-choice/#get_proposer_head","title":"<code>get_proposer_head</code>","text":"<pre><code>def get_proposer_head(store: Store, head_root: Root, slot: Slot) -&gt; Root:\nhead_block = store.blocks[head_root]\nparent_root = head_block.parent_root\nparent_block = store.blocks[parent_root]\n# Only re-org the head block if it arrived later than the attestation deadline.\nhead_late = is_head_late(store, head_root)\n# Do not re-org on an epoch boundary where the proposer shuffling could change.\nshuffling_stable = is_shuffling_stable(slot)\n# Ensure that the FFG information of the new head will be competitive with the current head.\nffg_competitive = is_ffg_competitive(store, head_root, parent_root)\n# Do not re-org if the chain is not finalizing with acceptable frequency.\nfinalization_ok = is_finalization_ok(store, slot)\n# Only re-org if we are proposing on-time.\nproposing_on_time = is_proposing_on_time(store)\n# Only re-org a single slot at most.\nparent_slot_ok = parent_block.slot + 1 == head_block.slot\ncurrent_time_ok = head_block.slot + 1 == slot\nsingle_slot_reorg = parent_slot_ok and current_time_ok\n# Check that the head has few enough votes to be overpowered by our proposer boost.\nassert store.proposer_boost_root != head_root  # ensure boost has worn off\nhead_weak = is_head_weak(store, head_root)\n# Check that the missing votes are assigned to the parent and not being hoarded.\nparent_strong = is_parent_strong(store, parent_root)\nif all([head_late, shuffling_stable, ffg_competitive, finalization_ok,\nproposing_on_time, single_slot_reorg, head_weak, parent_strong]):\n# We can re-org the current head by building upon its parent block.\nreturn parent_root\nelse:\nreturn head_root\n</code></pre> <p>Note: The ordering of conditions is a suggestion only. Implementations are free to optimize by re-ordering the conditions from least to most expensive and by returning early if any of the early conditions are <code>False</code>.</p>"},{"location":"specs/phase0/fork-choice/#pull-up-tip-helpers","title":"Pull-up tip helpers","text":""},{"location":"specs/phase0/fork-choice/#compute_pulled_up_tip","title":"<code>compute_pulled_up_tip</code>","text":"<pre><code>def compute_pulled_up_tip(store: Store, block_root: Root) -&gt; None:\nstate = store.block_states[block_root].copy()\n# Pull up the post-state of the block to the next epoch boundary\nprocess_justification_and_finalization(state)\nstore.unrealized_justifications[block_root] = state.current_justified_checkpoint\nupdate_unrealized_checkpoints(store, state.current_justified_checkpoint, state.finalized_checkpoint)\n# If the block is from a prior epoch, apply the realized values\nblock_epoch = compute_epoch_at_slot(store.blocks[block_root].slot)\ncurrent_epoch = get_current_store_epoch(store)\nif block_epoch &lt; current_epoch:\nupdate_checkpoints(store, state.current_justified_checkpoint, state.finalized_checkpoint)\n</code></pre>"},{"location":"specs/phase0/fork-choice/#on_tick-helpers","title":"<code>on_tick</code> helpers","text":""},{"location":"specs/phase0/fork-choice/#on_tick_per_slot","title":"<code>on_tick_per_slot</code>","text":"<pre><code>def on_tick_per_slot(store: Store, time: uint64) -&gt; None:\nprevious_slot = get_current_slot(store)\n# Update store time\nstore.time = time\ncurrent_slot = get_current_slot(store)\n# If this is a new slot, reset store.proposer_boost_root\nif current_slot &gt; previous_slot:\nstore.proposer_boost_root = Root()\n# If a new epoch, pull-up justification and finalization from previous epoch\nif current_slot &gt; previous_slot and compute_slots_since_epoch_start(current_slot) == 0:\nupdate_checkpoints(store, store.unrealized_justified_checkpoint, store.unrealized_finalized_checkpoint)\n</code></pre>"},{"location":"specs/phase0/fork-choice/#on_attestation-helpers","title":"<code>on_attestation</code> helpers","text":""},{"location":"specs/phase0/fork-choice/#validate_target_epoch_against_current_time","title":"<code>validate_target_epoch_against_current_time</code>","text":"<pre><code>def validate_target_epoch_against_current_time(store: Store, attestation: Attestation) -&gt; None:\ntarget = attestation.data.target\n# Attestations must be from the current or previous epoch\ncurrent_epoch = get_current_store_epoch(store)\n# Use GENESIS_EPOCH for previous when genesis to avoid underflow\nprevious_epoch = current_epoch - 1 if current_epoch &gt; GENESIS_EPOCH else GENESIS_EPOCH\n# If attestation target is from a future epoch, delay consideration until the epoch arrives\nassert target.epoch in [current_epoch, previous_epoch]\n</code></pre>"},{"location":"specs/phase0/fork-choice/#validate_on_attestation","title":"<code>validate_on_attestation</code>","text":"<pre><code>def validate_on_attestation(store: Store, attestation: Attestation, is_from_block: bool) -&gt; None:\ntarget = attestation.data.target\n# If the given attestation is not from a beacon block message, we have to check the target epoch scope.\nif not is_from_block:\nvalidate_target_epoch_against_current_time(store, attestation)\n# Check that the epoch number and slot number are matching\nassert target.epoch == compute_epoch_at_slot(attestation.data.slot)\n# Attestation target must be for a known block. If target block is unknown, delay consideration until block is found\nassert target.root in store.blocks\n# Attestations must be for a known block. If block is unknown, delay consideration until the block is found\nassert attestation.data.beacon_block_root in store.blocks\n# Attestations must not be for blocks in the future. If not, the attestation should not be considered\nassert store.blocks[attestation.data.beacon_block_root].slot &lt;= attestation.data.slot\n# LMD vote must be consistent with FFG vote target\nassert target.root == get_checkpoint_block(store, attestation.data.beacon_block_root, target.epoch)\n# Attestations can only affect the fork choice of subsequent slots.\n# Delay consideration in the fork choice until their slot is in the past.\nassert get_current_slot(store) &gt;= attestation.data.slot + 1\n</code></pre>"},{"location":"specs/phase0/fork-choice/#store_target_checkpoint_state","title":"<code>store_target_checkpoint_state</code>","text":"<pre><code>def store_target_checkpoint_state(store: Store, target: Checkpoint) -&gt; None:\n# Store target checkpoint state if not yet seen\nif target not in store.checkpoint_states:\nbase_state = copy(store.block_states[target.root])\nif base_state.slot &lt; compute_start_slot_at_epoch(target.epoch):\nprocess_slots(base_state, compute_start_slot_at_epoch(target.epoch))\nstore.checkpoint_states[target] = base_state\n</code></pre>"},{"location":"specs/phase0/fork-choice/#update_latest_messages","title":"<code>update_latest_messages</code>","text":"<pre><code>def update_latest_messages(store: Store, attesting_indices: Sequence[ValidatorIndex], attestation: Attestation) -&gt; None:\ntarget = attestation.data.target\nbeacon_block_root = attestation.data.beacon_block_root\nnon_equivocating_attesting_indices = [i for i in attesting_indices if i not in store.equivocating_indices]\nfor i in non_equivocating_attesting_indices:\nif i not in store.latest_messages or target.epoch &gt; store.latest_messages[i].epoch:\nstore.latest_messages[i] = LatestMessage(epoch=target.epoch, root=beacon_block_root)\n</code></pre>"},{"location":"specs/phase0/fork-choice/#handlers","title":"Handlers","text":""},{"location":"specs/phase0/fork-choice/#on_tick","title":"<code>on_tick</code>","text":"<pre><code>def on_tick(store: Store, time: uint64) -&gt; None:\n# If the ``store.time`` falls behind, while loop catches up slot by slot\n# to ensure that every previous slot is processed with ``on_tick_per_slot``\ntick_slot = (time - store.genesis_time) // SECONDS_PER_SLOT\nwhile get_current_slot(store) &lt; tick_slot:\nprevious_time = store.genesis_time + (get_current_slot(store) + 1) * SECONDS_PER_SLOT\non_tick_per_slot(store, previous_time)\non_tick_per_slot(store, time)\n</code></pre>"},{"location":"specs/phase0/fork-choice/#on_block","title":"<code>on_block</code>","text":"<pre><code>def on_block(store: Store, signed_block: SignedBeaconBlock) -&gt; None:\nblock = signed_block.message\n# Parent block must be known\nassert block.parent_root in store.block_states\n# Make a copy of the state to avoid mutability issues\npre_state = copy(store.block_states[block.parent_root])\n# Blocks cannot be in the future. If they are, their consideration must be delayed until they are in the past.\nassert get_current_slot(store) &gt;= block.slot\n# Check that block is later than the finalized epoch slot (optimization to reduce calls to get_ancestor)\nfinalized_slot = compute_start_slot_at_epoch(store.finalized_checkpoint.epoch)\nassert block.slot &gt; finalized_slot\n# Check block is a descendant of the finalized block at the checkpoint finalized slot\nfinalized_checkpoint_block = get_checkpoint_block(\nstore,\nblock.parent_root,\nstore.finalized_checkpoint.epoch,\n)\nassert store.finalized_checkpoint.root == finalized_checkpoint_block\n# Check the block is valid and compute the post-state\nstate = pre_state.copy()\nblock_root = hash_tree_root(block)\nstate_transition(state, signed_block, True)\n# Add new block to the store\nstore.blocks[block_root] = block\n# Add new state for this block to the store\nstore.block_states[block_root] = state\n# Add block timeliness to the store\ntime_into_slot = (store.time - store.genesis_time) % SECONDS_PER_SLOT\nis_before_attesting_interval = time_into_slot &lt; SECONDS_PER_SLOT // INTERVALS_PER_SLOT\nis_timely = get_current_slot(store) == block.slot and is_before_attesting_interval\nstore.block_timeliness[hash_tree_root(block)] = is_timely\n# Add proposer score boost if the block is timely and not conflicting with an existing block\nis_first_block = store.proposer_boost_root == Root()\nif is_timely and is_first_block:\nstore.proposer_boost_root = hash_tree_root(block)\n# Update checkpoints in store if necessary\nupdate_checkpoints(store, state.current_justified_checkpoint, state.finalized_checkpoint)\n# Eagerly compute unrealized justification and finality\ncompute_pulled_up_tip(store, block_root)\n</code></pre>"},{"location":"specs/phase0/fork-choice/#on_attestation","title":"<code>on_attestation</code>","text":"<pre><code>def on_attestation(store: Store, attestation: Attestation, is_from_block: bool=False) -&gt; None:\n\"\"\"\n    Run ``on_attestation`` upon receiving a new ``attestation`` from either within a block or directly on the wire.\n    An ``attestation`` that is asserted as invalid may be valid at a later time,\n    consider scheduling it for later processing in such case.\n    \"\"\"\nvalidate_on_attestation(store, attestation, is_from_block)\nstore_target_checkpoint_state(store, attestation.data.target)\n# Get state at the `target` to fully validate attestation\ntarget_state = store.checkpoint_states[attestation.data.target]\nindexed_attestation = get_indexed_attestation(target_state, attestation)\nassert is_valid_indexed_attestation(target_state, indexed_attestation)\n# Update latest messages for attesting indices\nupdate_latest_messages(store, indexed_attestation.attesting_indices, attestation)\n</code></pre>"},{"location":"specs/phase0/fork-choice/#on_attester_slashing","title":"<code>on_attester_slashing</code>","text":"<p>Note: <code>on_attester_slashing</code> should be called while syncing and a client MUST maintain the equivocation set of <code>AttesterSlashing</code>s from at least the latest finalized checkpoint.</p> <pre><code>def on_attester_slashing(store: Store, attester_slashing: AttesterSlashing) -&gt; None:\n\"\"\"\n    Run ``on_attester_slashing`` immediately upon receiving a new ``AttesterSlashing``\n    from either within a block or directly on the wire.\n    \"\"\"\nattestation_1 = attester_slashing.attestation_1\nattestation_2 = attester_slashing.attestation_2\nassert is_slashable_attestation_data(attestation_1.data, attestation_2.data)\nstate = store.block_states[store.justified_checkpoint.root]\nassert is_valid_indexed_attestation(state, attestation_1)\nassert is_valid_indexed_attestation(state, attestation_2)\nindices = set(attestation_1.attesting_indices).intersection(attestation_2.attesting_indices)\nfor index in indices:\nstore.equivocating_indices.add(index)\n</code></pre>"},{"location":"specs/phase0/p2p-interface/","title":"Phase 0 -- Networking","text":"<p>This document contains the networking specification for Phase 0.</p> <p>It consists of four main sections:</p> <ol> <li>A specification of the network fundamentals.</li> <li>A specification of the three network interaction domains of the proof-of-stake consensus layer: (a) the gossip domain, (b) the discovery domain, and (c) the Req/Resp domain.</li> <li>The rationale and further explanation for the design choices made in the previous two sections.</li> <li>An analysis of the maturity/state of the libp2p features required by this spec across the languages in which clients are being developed.</li> </ol>"},{"location":"specs/phase0/p2p-interface/#table-of-contents","title":"Table of contents","text":"<ul> <li>Network fundamentals</li> <li>Transport</li> <li>Encryption and identification</li> <li>Protocol Negotiation</li> <li>Multiplexing</li> <li>Consensus-layer network interaction domains</li> <li>Custom types</li> <li>Constants</li> <li>Configuration</li> <li>MetaData</li> <li>The gossip domain: gossipsub<ul> <li>Topics and messages</li> <li>Global topics<ul> <li><code>beacon_block</code></li> <li><code>beacon_aggregate_and_proof</code></li> <li><code>voluntary_exit</code></li> <li><code>proposer_slashing</code></li> <li><code>attester_slashing</code></li> </ul> </li> <li>Attestation subnets<ul> <li><code>beacon_attestation_{subnet_id}</code></li> </ul> </li> <li>Attestations and Aggregation</li> <li>Encodings</li> </ul> </li> <li>The Req/Resp domain<ul> <li>Protocol identification</li> <li>Req/Resp interaction</li> <li>Requesting side</li> <li>Responding side</li> <li>Encoding strategies</li> <li>SSZ-snappy encoding strategy</li> <li>Messages</li> <li>Status</li> <li>Goodbye</li> <li>BeaconBlocksByRange</li> <li>BeaconBlocksByRoot</li> <li>Ping</li> <li>GetMetaData</li> </ul> </li> <li>The discovery domain: discv5<ul> <li>Integration into libp2p stacks</li> <li>ENR structure</li> <li>Attestation subnet bitfield</li> <li><code>eth2</code> field</li> </ul> </li> <li>Attestation subnet subscription</li> <li>Design decision rationale</li> <li>Transport<ul> <li>Why are we defining specific transports?</li> <li>Can clients support other transports/handshakes than the ones mandated by the spec?</li> <li>What are the advantages of using TCP/QUIC/Websockets?</li> <li>Why do we not just support a single transport?</li> <li>Why are we not using QUIC from the start?</li> </ul> </li> <li>Multiplexing<ul> <li>Why are we using mplex/yamux?</li> </ul> </li> <li>Protocol Negotiation<ul> <li>When is multiselect 2.0 due and why do we plan to migrate to it?</li> <li>What is the difference between connection-level and stream-level protocol negotiation?</li> </ul> </li> <li>Encryption<ul> <li>Why are we not supporting SecIO?</li> <li>Why are we using Noise?</li> <li>Why are we using encryption at all?</li> </ul> </li> <li>Gossipsub<ul> <li>Why are we using a pub/sub algorithm for block and attestation propagation?</li> <li>Why are we using topics to segregate encodings, yet only support one encoding?</li> <li>How do we upgrade gossip channels (e.g. changes in encoding, compression)?</li> <li>Why must all clients use the same gossip topic instead of one negotiated between each peer pair?</li> <li>Why are the topics strings and not hashes?</li> <li>Why are we using the <code>StrictNoSign</code> signature policy?</li> <li>Why are we overriding the default libp2p pubsub <code>message-id</code>?</li> <li>Why are these specific gossip parameters chosen?</li> <li>Why is there <code>MAXIMUM_GOSSIP_CLOCK_DISPARITY</code> when validating slot ranges of messages in gossip subnets?</li> <li>Why are there <code>ATTESTATION_SUBNET_COUNT</code> attestation subnets?</li> <li>Why are attestations limited to be broadcast on gossip channels within <code>SLOTS_PER_EPOCH</code> slots?</li> <li>Why are aggregate attestations broadcast to the global topic as <code>AggregateAndProof</code>s rather than just as <code>Attestation</code>s?</li> <li>Why are we sending entire objects in the pubsub and not just hashes?</li> <li>Should clients gossip blocks if they cannot validate the proposer signature due to not yet being synced, not knowing the head block, etc?</li> <li>How are we going to discover peers in a gossipsub topic?</li> <li>How should fork version be used in practice?</li> </ul> </li> <li>Req/Resp<ul> <li>Why segregate requests into dedicated protocol IDs?</li> <li>Why are messages length-prefixed with a protobuf varint in the SSZ-encoding?</li> <li>Why do we version protocol strings with ordinals instead of semver?</li> <li>Why is it called Req/Resp and not RPC?</li> <li>Why do we allow empty responses in block requests?</li> <li>Why does <code>BeaconBlocksByRange</code> let the server choose which branch to send blocks from?</li> <li>Why are <code>BlocksByRange</code> requests only required to be served for the latest <code>MIN_EPOCHS_FOR_BLOCK_REQUESTS</code> epochs?</li> <li>Why must the proposer signature be checked when backfilling blocks in the database?</li> <li>What's the effect of empty slots on the sync algorithm?</li> </ul> </li> <li>Discovery<ul> <li>Why are we using discv5 and not libp2p Kademlia DHT?</li> <li>What is the difference between an ENR and a multiaddr, and why are we using ENRs?</li> <li>Why do we not form ENRs and find peers until genesis block/state is known?</li> </ul> </li> <li>Compression/Encoding<ul> <li>Why are we using SSZ for encoding?</li> <li>Why are we compressing, and at which layers?</li> <li>Why are we using Snappy for compression?</li> <li>Can I get access to unencrypted bytes on the wire for debugging purposes?</li> <li>What are SSZ type size bounds?</li> </ul> </li> <li>libp2p implementations matrix</li> </ul>"},{"location":"specs/phase0/p2p-interface/#network-fundamentals","title":"Network fundamentals","text":"<p>This section outlines the specification for the networking stack in Ethereum consensus-layer clients.</p>"},{"location":"specs/phase0/p2p-interface/#transport","title":"Transport","text":"<p>Even though libp2p is a multi-transport stack (designed to listen on multiple simultaneous transports and endpoints transparently), we hereby define a profile for basic interoperability.</p> <p>All implementations MUST support the TCP libp2p transport, and it MUST be enabled for both dialing and listening (i.e. outbound and inbound connections). The libp2p TCP transport supports listening on IPv4 and IPv6 addresses (and on multiple simultaneously).</p> <p>Clients must support listening on at least one of IPv4 or IPv6. Clients that do not have support for listening on IPv4 SHOULD be cognizant of the potential disadvantages in terms of Internet-wide routability/support. Clients MAY choose to listen only on IPv6, but MUST be capable of dialing both IPv4 and IPv6 addresses.</p> <p>All listening endpoints must be publicly dialable, and thus not rely on libp2p circuit relay, AutoNAT, or AutoRelay facilities. (Usage of circuit relay, AutoNAT, or AutoRelay will be specifically re-examined soon.)</p> <p>Nodes operating behind a NAT, or otherwise undialable by default (e.g. container runtime, firewall, etc.), MUST have their infrastructure configured to enable inbound traffic on the announced public listening endpoint.</p>"},{"location":"specs/phase0/p2p-interface/#encryption-and-identification","title":"Encryption and identification","text":"<p>The Libp2p-noise secure channel handshake with <code>secp256k1</code> identities will be used for encryption.</p> <p>As specified in the libp2p specification, clients MUST support the <code>XX</code> handshake pattern.</p>"},{"location":"specs/phase0/p2p-interface/#protocol-negotiation","title":"Protocol Negotiation","text":"<p>Clients MUST use exact equality when negotiating protocol versions to use and MAY use the version to give priority to higher version numbers.</p> <p>Clients MUST support multistream-select 1.0 and MAY support multiselect 2.0 when the spec solidifies. Once all clients have implementations for multiselect 2.0, multistream-select 1.0 MAY be phased out.</p>"},{"location":"specs/phase0/p2p-interface/#multiplexing","title":"Multiplexing","text":"<p>During connection bootstrapping, libp2p dynamically negotiates a mutually supported multiplexing method to conduct parallel conversations. This applies to transports that are natively incapable of multiplexing (e.g. TCP, WebSockets, WebRTC), and is omitted for capable transports (e.g. QUIC).</p> <p>Two multiplexers are commonplace in libp2p implementations: mplex and yamux. Their protocol IDs are, respectively: <code>/mplex/6.7.0</code> and <code>/yamux/1.0.0</code>.</p> <p>Clients MUST support mplex and MAY support yamux. If both are supported by the client, yamux MUST take precedence during negotiation. See the Rationale section below for tradeoffs.</p>"},{"location":"specs/phase0/p2p-interface/#consensus-layer-network-interaction-domains","title":"Consensus-layer network interaction domains","text":""},{"location":"specs/phase0/p2p-interface/#custom-types","title":"Custom types","text":"<p>We define the following Python custom types for type hinting and readability:</p> Name SSZ equivalent Description <code>NodeID</code> <code>uint256</code> node identifier <code>SubnetID</code> <code>uint64</code> subnet identifier"},{"location":"specs/phase0/p2p-interface/#constants","title":"Constants","text":"Name Value Unit Duration <code>NODE_ID_BITS</code> <code>256</code> The bit length of uint256 is 256"},{"location":"specs/phase0/p2p-interface/#configuration","title":"Configuration","text":"<p>This section outlines configurations that are used in this spec.</p> Name Value Description <code>GOSSIP_MAX_SIZE</code> <code>10 * 2**20</code> (= 10485760, 10 MiB) The maximum allowed size of uncompressed gossip messages. <code>MAX_REQUEST_BLOCKS</code> <code>2**10</code> (= 1024) Maximum number of blocks in a single request <code>EPOCHS_PER_SUBNET_SUBSCRIPTION</code> <code>2**8</code> (= 256) Number of epochs on a subnet subscription (~27 hours) <code>MIN_EPOCHS_FOR_BLOCK_REQUESTS</code> <code>MIN_VALIDATOR_WITHDRAWABILITY_DELAY + CHURN_LIMIT_QUOTIENT // 2</code> (= 33024, ~5 months) The minimum epoch range over which a node must serve blocks <code>MAX_CHUNK_SIZE</code> <code>10 * 2**20</code> (=10485760, 10 MiB) The maximum allowed size of uncompressed req/resp chunked responses. <code>TTFB_TIMEOUT</code> <code>5</code> The maximum duration in seconds to wait for first byte of request response (time-to-first-byte). <code>RESP_TIMEOUT</code> <code>10</code> The maximum duration in seconds for complete response transfer. <code>ATTESTATION_PROPAGATION_SLOT_RANGE</code> <code>32</code> The maximum number of slots during which an attestation can be propagated. <code>MAXIMUM_GOSSIP_CLOCK_DISPARITY</code> <code>500</code> The maximum milliseconds of clock disparity assumed between honest nodes. <code>MESSAGE_DOMAIN_INVALID_SNAPPY</code> <code>DomainType('0x00000000')</code> 4-byte domain for gossip message-id isolation of invalid snappy messages <code>MESSAGE_DOMAIN_VALID_SNAPPY</code> <code>DomainType('0x01000000')</code> 4-byte domain for gossip message-id isolation of valid snappy messages <code>SUBNETS_PER_NODE</code> <code>2</code> The number of long-lived subnets a beacon node should be subscribed to. <code>ATTESTATION_SUBNET_COUNT</code> <code>2**6</code> (= 64) The number of attestation subnets used in the gossipsub protocol. <code>ATTESTATION_SUBNET_EXTRA_BITS</code> <code>0</code> The number of extra bits of a NodeId to use when mapping to a subscribed subnet <code>ATTESTATION_SUBNET_PREFIX_BITS</code> <code>int(ceillog2(ATTESTATION_SUBNET_COUNT) + ATTESTATION_SUBNET_EXTRA_BITS)</code>"},{"location":"specs/phase0/p2p-interface/#metadata","title":"MetaData","text":"<p>Clients MUST locally store the following <code>MetaData</code>:</p> <pre><code>(\n  seq_number: uint64\n  attnets: Bitvector[ATTESTATION_SUBNET_COUNT]\n)\n</code></pre> <p>Where</p> <ul> <li><code>seq_number</code> is a <code>uint64</code> starting at <code>0</code> used to version the node's metadata.   If any other field in the local <code>MetaData</code> changes, the node MUST increment <code>seq_number</code> by 1.</li> <li><code>attnets</code> is a <code>Bitvector</code> representing the node's persistent attestation subnet subscriptions.</li> </ul> <p>Note: <code>MetaData.seq_number</code> is used for versioning of the node's metadata, is entirely independent of the ENR sequence number, and will in most cases be out of sync with the ENR sequence number.</p>"},{"location":"specs/phase0/p2p-interface/#the-gossip-domain-gossipsub","title":"The gossip domain: gossipsub","text":"<p>Clients MUST support the gossipsub v1 libp2p Protocol including the gossipsub v1.1 extension.</p> <p>Protocol ID: <code>/meshsub/1.1.0</code></p> <p>Gossipsub Parameters</p> <p>The following gossipsub parameters will be used:</p> <ul> <li><code>D</code> (topic stable mesh target count): 8</li> <li><code>D_low</code> (topic stable mesh low watermark): 6</li> <li><code>D_high</code> (topic stable mesh high watermark): 12</li> <li><code>D_lazy</code> (gossip target): 6</li> <li><code>heartbeat_interval</code> (frequency of heartbeat, seconds): 0.7</li> <li><code>fanout_ttl</code> (ttl for fanout maps for topics we are not subscribed to but have published to, seconds): 60</li> <li><code>mcache_len</code> (number of windows to retain full messages in cache for <code>IWANT</code> responses): 6</li> <li><code>mcache_gossip</code> (number of windows to gossip about): 3</li> <li><code>seen_ttl</code> (expiry time for cache of seen message ids, seconds): SECONDS_PER_SLOT * SLOTS_PER_EPOCH * 2</li> </ul> <p>Note: Gossipsub v1.1 introduces a number of additional parameters for peer scoring and other attack mitigations. These are currently under investigation and will be spec'd and released to mainnet when they are ready.</p>"},{"location":"specs/phase0/p2p-interface/#topics-and-messages","title":"Topics and messages","text":"<p>Topics are plain UTF-8 strings and are encoded on the wire as determined by protobuf (gossipsub messages are enveloped in protobuf messages). Topic strings have form: <code>/eth2/ForkDigestValue/Name/Encoding</code>. This defines both the type of data being sent on the topic and how the data field of the message is encoded.</p> <ul> <li><code>ForkDigestValue</code> - the lowercase hex-encoded (no \"0x\" prefix) bytes of <code>compute_fork_digest(current_fork_version, genesis_validators_root)</code> where<ul> <li><code>current_fork_version</code> is the fork version of the epoch of the message to be sent on the topic</li> <li><code>genesis_validators_root</code> is the static <code>Root</code> found in <code>state.genesis_validators_root</code></li> </ul> </li> <li><code>Name</code> - see table below</li> <li><code>Encoding</code> - the encoding strategy describes a specific representation of bytes that will be transmitted over the wire.   See the Encodings section for further details.</li> </ul> <p>Note: <code>ForkDigestValue</code> is composed of values that are not known until the genesis block/state are available. Due to this, clients SHOULD NOT subscribe to gossipsub topics until these genesis values are known.</p> <p>Each gossipsub message has a maximum size of <code>GOSSIP_MAX_SIZE</code>. Clients MUST reject (fail validation) messages that are over this size limit. Likewise, clients MUST NOT emit or propagate messages larger than this limit.</p> <p>The optional <code>from</code> (1), <code>seqno</code> (3), <code>signature</code> (5) and <code>key</code> (6) protobuf fields are omitted from the message, since messages are identified by content, anonymous, and signed where necessary in the application layer. Starting from Gossipsub v1.1, clients MUST enforce this by applying the <code>StrictNoSign</code> signature policy.</p> <p>The <code>message-id</code> of a gossipsub message MUST be the following 20 byte value computed from the message data: * If <code>message.data</code> has a valid snappy decompression, set <code>message-id</code> to the first 20 bytes of the <code>SHA256</code> hash of   the concatenation of <code>MESSAGE_DOMAIN_VALID_SNAPPY</code> with the snappy decompressed message data,   i.e. <code>SHA256(MESSAGE_DOMAIN_VALID_SNAPPY + snappy_decompress(message.data))[:20]</code>. * Otherwise, set <code>message-id</code> to the first 20 bytes of the <code>SHA256</code> hash of   the concatenation of <code>MESSAGE_DOMAIN_INVALID_SNAPPY</code> with the raw message data,   i.e. <code>SHA256(MESSAGE_DOMAIN_INVALID_SNAPPY + message.data)[:20]</code>.</p> <p>Note: The above logic handles two exceptional cases: (1) multiple snappy <code>data</code> can decompress to the same value, and (2) some message <code>data</code> can fail to snappy decompress altogether.</p> <p>The payload is carried in the <code>data</code> field of a gossipsub message, and varies depending on the topic:</p> Name Message Type <code>beacon_block</code> <code>SignedBeaconBlock</code> <code>beacon_aggregate_and_proof</code> <code>SignedAggregateAndProof</code> <code>beacon_attestation_{subnet_id}</code> <code>Attestation</code> <code>voluntary_exit</code> <code>SignedVoluntaryExit</code> <code>proposer_slashing</code> <code>ProposerSlashing</code> <code>attester_slashing</code> <code>AttesterSlashing</code> <p>Clients MUST reject (fail validation) messages containing an incorrect type, or invalid payload.</p> <p>When processing incoming gossip, clients MAY descore or disconnect peers who fail to observe these constraints.</p> <p>For any optional queueing, clients SHOULD maintain maximum queue sizes to avoid DoS vectors.</p> <p>Gossipsub v1.1 introduces Extended Validators for the application to aid in the gossipsub peer-scoring scheme. We utilize <code>ACCEPT</code>, <code>REJECT</code>, and <code>IGNORE</code>. For each gossipsub topic, there are application specific validations. If all validations pass, return <code>ACCEPT</code>. If one or more validations fail while processing the items in order, return either <code>REJECT</code> or <code>IGNORE</code> as specified in the prefix of the particular condition.</p>"},{"location":"specs/phase0/p2p-interface/#global-topics","title":"Global topics","text":"<p>There are two primary global topics used to propagate beacon blocks (<code>beacon_block</code>) and aggregate attestations (<code>beacon_aggregate_and_proof</code>) to all nodes on the network.</p> <p>There are three additional global topics that are used to propagate lower frequency validator messages (<code>voluntary_exit</code>, <code>proposer_slashing</code>, and <code>attester_slashing</code>).</p>"},{"location":"specs/phase0/p2p-interface/#beacon_block","title":"<code>beacon_block</code>","text":"<p>The <code>beacon_block</code> topic is used solely for propagating new signed beacon blocks to all nodes on the networks. Signed blocks are sent in their entirety.</p> <p>The following validations MUST pass before forwarding the <code>signed_beacon_block</code> on the network. - [IGNORE] The block is not from a future slot (with a <code>MAXIMUM_GOSSIP_CLOCK_DISPARITY</code> allowance) --   i.e. validate that <code>signed_beacon_block.message.slot &lt;= current_slot</code>   (a client MAY queue future blocks for processing at the appropriate slot). - [IGNORE] The block is from a slot greater than the latest finalized slot --   i.e. validate that <code>signed_beacon_block.message.slot &gt; compute_start_slot_at_epoch(store.finalized_checkpoint.epoch)</code>   (a client MAY choose to validate and store such blocks for additional purposes -- e.g. slashing detection, archive nodes, etc). - [IGNORE] The block is the first block with valid signature received for the proposer for the slot, <code>signed_beacon_block.message.slot</code>. - [REJECT] The proposer signature, <code>signed_beacon_block.signature</code>, is valid with respect to the <code>proposer_index</code> pubkey. - [IGNORE] The block's parent (defined by <code>block.parent_root</code>) has been seen   (via both gossip and non-gossip sources)   (a client MAY queue blocks for processing once the parent block is retrieved). - [REJECT] The block's parent (defined by <code>block.parent_root</code>) passes validation. - [REJECT] The block is from a higher slot than its parent. - [REJECT] The current <code>finalized_checkpoint</code> is an ancestor of <code>block</code> -- i.e.   <code>get_checkpoint_block(store, block.parent_root, store.finalized_checkpoint.epoch)   == store.finalized_checkpoint.root</code> - [REJECT] The block is proposed by the expected <code>proposer_index</code> for the block's slot   in the context of the current shuffling (defined by <code>parent_root</code>/<code>slot</code>).   If the <code>proposer_index</code> cannot immediately be verified against the expected shuffling,   the block MAY be queued for later processing while proposers for the block's branch are calculated --   in such a case do not <code>REJECT</code>, instead <code>IGNORE</code> this message.</p>"},{"location":"specs/phase0/p2p-interface/#beacon_aggregate_and_proof","title":"<code>beacon_aggregate_and_proof</code>","text":"<p>The <code>beacon_aggregate_and_proof</code> topic is used to propagate aggregated attestations (as <code>SignedAggregateAndProof</code>s) to subscribing nodes (typically validators) to be included in future blocks.</p> <p>We define the following variables for convenience: - <code>aggregate_and_proof = signed_aggregate_and_proof.message</code> - <code>aggregate = aggregate_and_proof.aggregate</code> - <code>index = aggregate.index</code> - <code>aggregation_bits = attestation.aggregation_bits</code></p> <p>The following validations MUST pass before forwarding the <code>signed_aggregate_and_proof</code> on the network. - [REJECT] The committee index is within the expected range -- i.e. <code>index &lt; get_committee_count_per_slot(state, aggregate.data.target.epoch)</code>. - [IGNORE] <code>aggregate.data.slot</code> is within the last <code>ATTESTATION_PROPAGATION_SLOT_RANGE</code> slots (with a <code>MAXIMUM_GOSSIP_CLOCK_DISPARITY</code> allowance) --   i.e. <code>aggregate.data.slot + ATTESTATION_PROPAGATION_SLOT_RANGE &gt;= current_slot &gt;= aggregate.data.slot</code>   (a client MAY queue future aggregates for processing at the appropriate slot). - [REJECT] The aggregate attestation's epoch matches its target -- i.e. <code>aggregate.data.target.epoch ==   compute_epoch_at_slot(aggregate.data.slot)</code> - [REJECT] The number of aggregation bits matches the committee size -- i.e.   <code>len(aggregation_bits) == len(get_beacon_committee(state, aggregate.data.slot, index))</code>. - [REJECT] The aggregate attestation has participants --   that is, <code>len(get_attesting_indices(state, aggregate)) &gt;= 1</code>. - [IGNORE] A valid aggregate attestation defined by <code>hash_tree_root(aggregate.data)</code> whose <code>aggregation_bits</code> is a non-strict superset has not already been seen.   (via aggregate gossip, within a verified block, or through the creation of an equivalent aggregate locally). - [IGNORE] The <code>aggregate</code> is the first valid aggregate received for the aggregator   with index <code>aggregate_and_proof.aggregator_index</code> for the epoch <code>aggregate.data.target.epoch</code>. - [REJECT] The attestation has participants -- that is, <code>len(get_attesting_indices(state, aggregate)) &gt;= 1</code>. - [REJECT] <code>aggregate_and_proof.selection_proof</code> selects the validator as an aggregator for the slot --   i.e. <code>is_aggregator(state, aggregate.data.slot, index, aggregate_and_proof.selection_proof)</code> returns <code>True</code>. - [REJECT] The aggregator's validator index is within the committee --   i.e. <code>aggregate_and_proof.aggregator_index in get_beacon_committee(state, aggregate.data.slot, index)</code>. - [REJECT] The <code>aggregate_and_proof.selection_proof</code> is a valid signature   of the <code>aggregate.data.slot</code> by the validator with index <code>aggregate_and_proof.aggregator_index</code>. - [REJECT] The aggregator signature, <code>signed_aggregate_and_proof.signature</code>, is valid. - [REJECT] The signature of <code>aggregate</code> is valid. - [IGNORE] The block being voted for (<code>aggregate.data.beacon_block_root</code>) has been seen   (via both gossip and non-gossip sources)   (a client MAY queue aggregates for processing once block is retrieved). - [REJECT] The block being voted for (<code>aggregate.data.beacon_block_root</code>) passes validation. - [REJECT] The aggregate attestation's target block is an ancestor of the block named in the LMD vote -- i.e.   <code>get_checkpoint_block(store, aggregate.data.beacon_block_root, aggregate.data.target.epoch) == aggregate.data.target.root</code> - [IGNORE] The current <code>finalized_checkpoint</code> is an ancestor of the <code>block</code> defined by <code>aggregate.data.beacon_block_root</code> -- i.e.   <code>get_checkpoint_block(store, aggregate.data.beacon_block_root, finalized_checkpoint.epoch)   == store.finalized_checkpoint.root</code></p>"},{"location":"specs/phase0/p2p-interface/#voluntary_exit","title":"<code>voluntary_exit</code>","text":"<p>The <code>voluntary_exit</code> topic is used solely for propagating signed voluntary validator exits to proposers on the network. Signed voluntary exits are sent in their entirety.</p> <p>The following validations MUST pass before forwarding the <code>signed_voluntary_exit</code> on to the network. - [IGNORE] The voluntary exit is the first valid voluntary exit received   for the validator with index <code>signed_voluntary_exit.message.validator_index</code>. - [REJECT] All of the conditions within <code>process_voluntary_exit</code> pass validation.</p>"},{"location":"specs/phase0/p2p-interface/#proposer_slashing","title":"<code>proposer_slashing</code>","text":"<p>The <code>proposer_slashing</code> topic is used solely for propagating proposer slashings to proposers on the network. Proposer slashings are sent in their entirety.</p> <p>The following validations MUST pass before forwarding the <code>proposer_slashing</code> on to the network. - [IGNORE] The proposer slashing is the first valid proposer slashing received   for the proposer with index <code>proposer_slashing.signed_header_1.message.proposer_index</code>. - [REJECT] All of the conditions within <code>process_proposer_slashing</code> pass validation.</p>"},{"location":"specs/phase0/p2p-interface/#attester_slashing","title":"<code>attester_slashing</code>","text":"<p>The <code>attester_slashing</code> topic is used solely for propagating attester slashings to proposers on the network. Attester slashings are sent in their entirety.</p> <p>Clients who receive an attester slashing on this topic MUST validate the conditions within <code>process_attester_slashing</code> before forwarding it across the network. - [IGNORE] At least one index in the intersection of the attesting indices of each attestation   has not yet been seen in any prior <code>attester_slashing</code>   (i.e. <code>attester_slashed_indices = set(attestation_1.attesting_indices).intersection(attestation_2.attesting_indices)</code>,   verify if <code>any(attester_slashed_indices.difference(prior_seen_attester_slashed_indices))</code>). - [REJECT] All of the conditions within <code>process_attester_slashing</code> pass validation.</p>"},{"location":"specs/phase0/p2p-interface/#attestation-subnets","title":"Attestation subnets","text":"<p>Attestation subnets are used to propagate unaggregated attestations to subsections of the network.</p>"},{"location":"specs/phase0/p2p-interface/#beacon_attestation_subnet_id","title":"<code>beacon_attestation_{subnet_id}</code>","text":"<p>The <code>beacon_attestation_{subnet_id}</code> topics are used to propagate unaggregated attestations to the subnet <code>subnet_id</code> (typically beacon and persistent committees) to be aggregated before being gossiped to <code>beacon_aggregate_and_proof</code>.</p> <p>We define the following variables for convenience: - <code>index = attestation.index</code> - <code>aggregation_bits = attestation.aggregation_bits</code></p> <p>The following validations MUST pass before forwarding the <code>attestation</code> on the subnet. - [REJECT] The committee index is within the expected range -- i.e. <code>index &lt; get_committee_count_per_slot(state, attestation.data.target.epoch)</code>. - [REJECT] The attestation is for the correct subnet --   i.e. <code>compute_subnet_for_attestation(committees_per_slot, attestation.data.slot, index) == subnet_id</code>,   where <code>committees_per_slot = get_committee_count_per_slot(state, attestation.data.target.epoch)</code>,   which may be pre-computed along with the committee information for the signature check. - [IGNORE] <code>attestation.data.slot</code> is within the last <code>ATTESTATION_PROPAGATION_SLOT_RANGE</code> slots   (within a <code>MAXIMUM_GOSSIP_CLOCK_DISPARITY</code> allowance) --   i.e. <code>attestation.data.slot + ATTESTATION_PROPAGATION_SLOT_RANGE &gt;= current_slot &gt;= attestation.data.slot</code>   (a client MAY queue future attestations for processing at the appropriate slot). - [REJECT] The attestation's epoch matches its target -- i.e. <code>attestation.data.target.epoch ==   compute_epoch_at_slot(attestation.data.slot)</code> - [REJECT] The attestation is unaggregated --   that is, it has exactly one participating validator (<code>len([bit for bit in aggregation_bits if bit]) == 1</code>, i.e. exactly 1 bit is set). - [REJECT] The number of aggregation bits matches the committee size -- i.e.   <code>len(aggregation_bits) == len(get_beacon_committee(state, attestation.data.slot, index))</code>. - [IGNORE] There has been no other valid attestation seen on an attestation subnet   that has an identical <code>attestation.data.target.epoch</code> and participating validator index. - [REJECT] The signature of <code>attestation</code> is valid. - [IGNORE] The block being voted for (<code>attestation.data.beacon_block_root</code>) has been seen   (via both gossip and non-gossip sources)   (a client MAY queue attestations for processing once block is retrieved). - [REJECT] The block being voted for (<code>attestation.data.beacon_block_root</code>) passes validation. - [REJECT] The attestation's target block is an ancestor of the block named in the LMD vote -- i.e.   <code>get_checkpoint_block(store, attestation.data.beacon_block_root, attestation.data.target.epoch) == attestation.data.target.root</code> - [IGNORE] The current <code>finalized_checkpoint</code> is an ancestor of the <code>block</code> defined by <code>attestation.data.beacon_block_root</code> -- i.e.   <code>get_checkpoint_block(store, attestation.data.beacon_block_root, store.finalized_checkpoint.epoch)   == store.finalized_checkpoint.root</code></p>"},{"location":"specs/phase0/p2p-interface/#attestations-and-aggregation","title":"Attestations and Aggregation","text":"<p>Attestation broadcasting is grouped into subnets defined by a topic. The number of subnets is defined via <code>ATTESTATION_SUBNET_COUNT</code>. The correct subnet for an attestation can be calculated with <code>compute_subnet_for_attestation</code>. <code>beacon_attestation_{subnet_id}</code> topics, are rotated through throughout the epoch in a similar fashion to rotating through shards in committees (future beacon chain upgrade). The subnets are rotated through with <code>committees_per_slot = get_committee_count_per_slot(state, attestation.data.target.epoch)</code> subnets per slot.</p> <p>Unaggregated attestations are sent as <code>Attestation</code>s to the subnet topic, <code>beacon_attestation_{compute_subnet_for_attestation(committees_per_slot, attestation.data.slot, attestation.data.index)}</code> as <code>Attestation</code>s.</p> <p>Aggregated attestations are sent to the <code>beacon_aggregate_and_proof</code> topic as <code>AggregateAndProof</code>s.</p>"},{"location":"specs/phase0/p2p-interface/#encodings","title":"Encodings","text":"<p>Topics are post-fixed with an encoding. Encodings define how the payload of a gossipsub message is encoded.</p> <ul> <li><code>ssz_snappy</code> - All objects are SSZ-encoded and then compressed with Snappy block compression.   Example: The beacon aggregate attestation topic string is <code>/eth2/446a7232/beacon_aggregate_and_proof/ssz_snappy</code>,   the fork digest is <code>446a7232</code> and the data field of a gossipsub message is an <code>AggregateAndProof</code>   that has been SSZ-encoded and then compressed with Snappy.</li> </ul> <p>Snappy has two formats: \"block\" and \"frames\" (streaming). Gossip messages remain relatively small (100s of bytes to 100s of kilobytes) so basic snappy block compression is used to avoid the additional overhead associated with snappy frames.</p> <p>Implementations MUST use a single encoding for gossip. Changing an encoding will require coordination between participating implementations.</p>"},{"location":"specs/phase0/p2p-interface/#the-reqresp-domain","title":"The Req/Resp domain","text":""},{"location":"specs/phase0/p2p-interface/#protocol-identification","title":"Protocol identification","text":"<p>Each message type is segregated into its own libp2p protocol ID, which is a case-sensitive UTF-8 string of the form:</p> <pre><code>/ProtocolPrefix/MessageName/SchemaVersion/Encoding\n</code></pre> <p>With:</p> <ul> <li><code>ProtocolPrefix</code> - messages are grouped into families identified by a shared libp2p protocol name prefix.   In this case, we use <code>/eth2/beacon_chain/req</code>.</li> <li><code>MessageName</code> - each request is identified by a name consisting of English alphabet, digits and underscores (<code>_</code>).</li> <li><code>SchemaVersion</code> - an ordinal version number (e.g. 1, 2, 3\u2026).   Each schema is versioned to facilitate backward and forward-compatibility when possible.</li> <li><code>Encoding</code> - while the schema defines the data types in more abstract terms,   the encoding strategy describes a specific representation of bytes that will be transmitted over the wire.   See the Encodings section for further details.</li> </ul> <p>This protocol segregation allows libp2p <code>multistream-select 1.0</code> / <code>multiselect 2.0</code> to handle the request type, version, and encoding negotiation before establishing the underlying streams.</p>"},{"location":"specs/phase0/p2p-interface/#reqresp-interaction","title":"Req/Resp interaction","text":"<p>We use ONE stream PER request/response interaction. Streams are closed when the interaction finishes, whether in success or in error.</p> <p>Request/response messages MUST adhere to the encoding specified in the protocol name and follow this structure (relaxed BNF grammar):</p> <pre><code>request   ::= &lt;encoding-dependent-header&gt; | &lt;encoded-payload&gt;\nresponse  ::= &lt;response_chunk&gt;*\nresponse_chunk  ::= &lt;result&gt; | &lt;encoding-dependent-header&gt; | &lt;encoded-payload&gt;\nresult    ::= \u201c0\u201d | \u201c1\u201d | \u201c2\u201d | [\u201c128\u201d ... \u201d255\u201d]\n</code></pre> <p>The encoding-dependent header may carry metadata or assertions such as the encoded payload length, for integrity and attack proofing purposes. Because req/resp streams are single-use and stream closures implicitly delimit the boundaries, it is not strictly necessary to length-prefix payloads; however, certain encodings like SSZ do, for added security.</p> <p>A <code>response</code> is formed by zero or more <code>response_chunk</code>s. Responses that consist of a single SSZ-list (such as <code>BlocksByRange</code> and <code>BlocksByRoot</code>) send each list item as a <code>response_chunk</code>. All other response types (non-Lists) send a single <code>response_chunk</code>.</p> <p>For both <code>request</code>s and <code>response</code>s, the <code>encoding-dependent-header</code> MUST be valid, and the <code>encoded-payload</code> must be valid within the constraints of the <code>encoding-dependent-header</code>. This includes type-specific bounds on payload size for some encoding strategies. Regardless of these type specific bounds, a global maximum uncompressed byte size of <code>MAX_CHUNK_SIZE</code> MUST be applied to all method response chunks.</p> <p>Clients MUST ensure that lengths are within these bounds; if not, they SHOULD reset the stream immediately. Clients tracking peer reputation MAY decrement the score of the misbehaving peer under this circumstance.</p>"},{"location":"specs/phase0/p2p-interface/#requesting-side","title":"Requesting side","text":"<p>Once a new stream with the protocol ID for the request type has been negotiated, the full request message SHOULD be sent immediately. The request MUST be encoded according to the encoding strategy.</p> <p>The requester MUST close the write side of the stream once it finishes writing the request message. At this point, the stream will be half-closed.</p> <p>The requester MUST wait a maximum of <code>TTFB_TIMEOUT</code> for the first response byte to arrive (time to first byte\u2014or TTFB\u2014timeout). On that happening, the requester allows a further <code>RESP_TIMEOUT</code> for each subsequent <code>response_chunk</code> received.</p> <p>If any of these timeouts fire, the requester SHOULD reset the stream and deem the req/resp operation to have failed.</p> <p>A requester SHOULD read from the stream until either: 1. An error result is received in one of the chunks (the error payload MAY be read before stopping). 2. The responder closes the stream. 3. Any part of the <code>response_chunk</code> fails validation. 4. The maximum number of requested chunks are read.</p> <p>For requests consisting of a single valid <code>response_chunk</code>, the requester SHOULD read the chunk fully, as defined by the <code>encoding-dependent-header</code>, before closing the stream.</p>"},{"location":"specs/phase0/p2p-interface/#responding-side","title":"Responding side","text":"<p>Once a new stream with the protocol ID for the request type has been negotiated, the responder SHOULD process the incoming request and MUST validate it before processing it. Request processing and validation MUST be done according to the encoding strategy, until EOF (denoting stream half-closure by the requester).</p> <p>The responder MUST:</p> <ol> <li>Use the encoding strategy to read the optional header.</li> <li>If there are any length assertions for length <code>N</code>, it should read exactly <code>N</code> bytes from the stream, at which point an EOF should arise (no more bytes).   Should this not be the case, it should be treated as a failure.</li> <li>Deserialize the expected type, and process the request.</li> <li>Write the response which may consist of zero or more <code>response_chunk</code>s (result, optional header, payload).</li> <li>Close their write side of the stream. At this point, the stream will be fully closed.</li> </ol> <p>If steps (1), (2), or (3) fail due to invalid, malformed, or inconsistent data, the responder MUST respond in error. Clients tracking peer reputation MAY record such failures, as well as unexpected events, e.g. early stream resets.</p> <p>The entire request should be read in no more than <code>RESP_TIMEOUT</code>. Upon a timeout, the responder SHOULD reset the stream.</p> <p>The responder SHOULD send a <code>response_chunk</code> promptly. Chunks start with a single-byte response code which determines the contents of the <code>response_chunk</code> (<code>result</code> particle in the BNF grammar above). For multiple chunks, only the last chunk is allowed to have a non-zero error code (i.e. The chunk stream is terminated once an error occurs).</p> <p>The response code can have one of the following values, encoded as a single unsigned byte:</p> <ul> <li>0: Success -- a normal response follows, with contents matching the expected message schema and encoding specified in the request.</li> <li>1: InvalidRequest -- the contents of the request are semantically invalid, or the payload is malformed, or could not be understood.   The response payload adheres to the <code>ErrorMessage</code> schema (described below).</li> <li>2: ServerError -- the responder encountered an error while processing the request.   The response payload adheres to the <code>ErrorMessage</code> schema (described below).</li> <li>3: ResourceUnavailable -- the responder does not have requested resource.   The response payload adheres to the <code>ErrorMessage</code> schema (described below).   Note: This response code is only valid as a response where specified.</li> </ul> <p>Clients MAY use response codes above <code>128</code> to indicate alternative, erroneous request-specific responses.</p> <p>The range <code>[4, 127]</code> is RESERVED for future usages, and should be treated as error if not recognized expressly.</p> <p>The <code>ErrorMessage</code> schema is:</p> <pre><code>(\n  error_message: List[byte, 256]\n)\n</code></pre> <p>Note: By convention, the <code>error_message</code> is a sequence of bytes that MAY be interpreted as a UTF-8 string (for debugging purposes). Clients MUST treat as valid any byte sequences.</p>"},{"location":"specs/phase0/p2p-interface/#encoding-strategies","title":"Encoding strategies","text":"<p>The token of the negotiated protocol ID specifies the type of encoding to be used for the req/resp interaction. Only one value is possible at this time:</p> <ul> <li><code>ssz_snappy</code>: The contents are first SSZ-encoded   and then compressed with Snappy frames compression.   For objects containing a single field, only the field is SSZ-encoded not a container with a single field.   For example, the <code>BeaconBlocksByRoot</code> request is an SSZ-encoded list of <code>Root</code>'s.   This encoding type MUST be supported by all clients.</li> </ul>"},{"location":"specs/phase0/p2p-interface/#ssz-snappy-encoding-strategy","title":"SSZ-snappy encoding strategy","text":"<p>The SimpleSerialize (SSZ) specification outlines how objects are SSZ-encoded.</p> <p>To achieve snappy encoding on top of SSZ, we feed the serialized form of the object to the Snappy compressor on encoding. The inverse happens on decoding.</p> <p>Snappy has two formats: \"block\" and \"frames\" (streaming). To support large requests and response chunks, snappy-framing is used.</p> <p>Since snappy frame contents have a maximum size of <code>65536</code> bytes and frame headers are just <code>identifier (1) + checksum (4)</code> bytes, the expected buffering of a single frame is acceptable.</p> <p>Encoding-dependent header: Req/Resp protocols using the <code>ssz_snappy</code> encoding strategy MUST encode the length of the raw SSZ bytes, encoded as an unsigned protobuf varint.</p> <p>Writing: By first computing and writing the SSZ byte length, the SSZ encoder can then directly write the chunk contents to the stream. When Snappy is applied, it can be passed through a buffered Snappy writer to compress frame by frame.</p> <p>Reading: After reading the expected SSZ byte length, the SSZ decoder can directly read the contents from the stream. When snappy is applied, it can be passed through a buffered Snappy reader to decompress frame by frame.</p> <p>Before reading the payload, the header MUST be validated: - The unsigned protobuf varint used for the length-prefix MUST not be longer than 10 bytes, which is sufficient for any <code>uint64</code>. - The length-prefix is within the expected size bounds derived from the payload SSZ type.</p> <p>After reading a valid header, the payload MAY be read, while maintaining the size constraints from the header.</p> <p>A reader SHOULD NOT read more than <code>max_encoded_len(n)</code> bytes after reading the SSZ length-prefix <code>n</code> from the header. - For <code>ssz_snappy</code> this is: <code>32 + n + n // 6</code>.   This is considered the worst-case compression result by Snappy.</p> <p>A reader SHOULD consider the following cases as invalid input: - Any remaining bytes, after having read the <code>n</code> SSZ bytes. An EOF is expected if more bytes are read than required. - An early EOF, before fully reading the declared length-prefix worth of SSZ bytes.</p> <p>In case of an invalid input (header or payload), a reader MUST: - From requests: send back an error message, response code <code>InvalidRequest</code>. The request itself is ignored. - From responses: ignore the response, the response MUST be considered bad server behavior.</p> <p>All messages that contain only a single field MUST be encoded directly as the type of that field and MUST NOT be encoded as an SSZ container.</p> <p>Responses that are SSZ-lists (for example <code>List[SignedBeaconBlock, ...]</code>) send their constituents individually as <code>response_chunk</code>s. For example, the <code>List[SignedBeaconBlock, ...]</code> response type sends zero or more <code>response_chunk</code>s. Each successful <code>response_chunk</code> contains a single <code>SignedBeaconBlock</code> payload.</p>"},{"location":"specs/phase0/p2p-interface/#messages","title":"Messages","text":""},{"location":"specs/phase0/p2p-interface/#status","title":"Status","text":"<p>Protocol ID: <code>/eth2/beacon_chain/req/status/1/</code></p> <p>Request, Response Content: <pre><code>(\n  fork_digest: ForkDigest\n  finalized_root: Root\n  finalized_epoch: Epoch\n  head_root: Root\n  head_slot: Slot\n)\n</code></pre> The fields are, as seen by the client at the time of sending the message:</p> <ul> <li><code>fork_digest</code>: The node's <code>ForkDigest</code> (<code>compute_fork_digest(current_fork_version, genesis_validators_root)</code>) where<ul> <li><code>current_fork_version</code> is the fork version at the node's current epoch defined by the wall-clock time   (not necessarily the epoch to which the node is sync)</li> <li><code>genesis_validators_root</code> is the static <code>Root</code> found in <code>state.genesis_validators_root</code></li> </ul> </li> <li><code>finalized_root</code>: <code>store.finalized_checkpoint.root</code> according to fork choice.   (Note this defaults to <code>Root(b'\\x00' * 32)</code> for the genesis finalized checkpoint).</li> <li><code>finalized_epoch</code>: <code>store.finalized_checkpoint.epoch</code> according to fork choice.</li> <li><code>head_root</code>: The <code>hash_tree_root</code> root of the current head block (<code>BeaconBlock</code>).</li> <li><code>head_slot</code>: The slot of the block corresponding to the <code>head_root</code>.</li> </ul> <p>The dialing client MUST send a <code>Status</code> request upon connection.</p> <p>The request/response MUST be encoded as an SSZ-container.</p> <p>The response MUST consist of a single <code>response_chunk</code>.</p> <p>Clients SHOULD immediately disconnect from one another following the handshake above under the following conditions:</p> <ol> <li>If <code>fork_digest</code> does not match the node's local <code>fork_digest</code>, since the client\u2019s chain is on another fork.</li> <li>If the (<code>finalized_root</code>, <code>finalized_epoch</code>) shared by the peer is not in the client's chain at the expected epoch.   For example, if Peer 1 sends (root, epoch) of (A, 5) and Peer 2 sends (B, 3) but Peer 1 has root C at epoch 3,   then Peer 1 would disconnect because it knows that their chains are irreparably disjoint.</li> </ol> <p>Once the handshake completes, the client with the lower <code>finalized_epoch</code> or <code>head_slot</code> (if the clients have equal <code>finalized_epoch</code>s) SHOULD request beacon blocks from its counterparty via the <code>BeaconBlocksByRange</code> request.</p> <p>Note: Under abnormal network condition or after some rounds of <code>BeaconBlocksByRange</code> requests, the client might need to send <code>Status</code> request again to learn if the peer has a higher head. Implementers are free to implement such behavior in their own way.</p>"},{"location":"specs/phase0/p2p-interface/#goodbye","title":"Goodbye","text":"<p>Protocol ID: <code>/eth2/beacon_chain/req/goodbye/1/</code></p> <p>Request, Response Content: <pre><code>(\n  uint64\n)\n</code></pre> Client MAY send goodbye messages upon disconnection. The reason field MAY be one of the following values:</p> <ul> <li>1: Client shut down.</li> <li>2: Irrelevant network.</li> <li>3: Fault/error.</li> </ul> <p>Clients MAY use reason codes above <code>128</code> to indicate alternative, erroneous request-specific responses.</p> <p>The range <code>[4, 127]</code> is RESERVED for future usage.</p> <p>The request/response MUST be encoded as a single SSZ-field.</p> <p>The response MUST consist of a single <code>response_chunk</code>.</p>"},{"location":"specs/phase0/p2p-interface/#beaconblocksbyrange","title":"BeaconBlocksByRange","text":"<p>Protocol ID: <code>/eth2/beacon_chain/req/beacon_blocks_by_range/1/</code></p> <p>Request Content: <pre><code>(\n  start_slot: Slot\n  count: uint64\n  step: uint64 # Deprecated, must be set to 1\n)\n</code></pre></p> <p>Response Content: <pre><code>(\n  List[SignedBeaconBlock, MAX_REQUEST_BLOCKS]\n)\n</code></pre></p> <p>Requests beacon blocks in the slot range <code>[start_slot, start_slot + count)</code>, leading up to the current head block as selected by fork choice. For example, requesting blocks starting at <code>start_slot=2</code> and <code>count=4</code> would return the blocks at slots <code>[2, 3, 4, 5]</code>. In cases where a slot is empty for a given slot number, no block is returned. For example, if slot 4 were empty in the previous example, the returned array would contain <code>[2, 3, 5]</code>.</p> <p><code>step</code> is deprecated and must be set to 1. Clients may respond with a single block if a larger step is returned during the deprecation transition period.</p> <p><code>/eth2/beacon_chain/req/beacon_blocks_by_range/1/</code> is deprecated. Clients MAY respond with an empty list during the deprecation transition period.</p> <p><code>BeaconBlocksByRange</code> is primarily used to sync historical blocks.</p> <p>The request MUST be encoded as an SSZ-container.</p> <p>The response MUST consist of zero or more <code>response_chunk</code>. Each successful <code>response_chunk</code> MUST contain a single <code>SignedBeaconBlock</code> payload.</p> <p>Clients MUST keep a record of signed blocks seen on the epoch range <code>[max(GENESIS_EPOCH, current_epoch - MIN_EPOCHS_FOR_BLOCK_REQUESTS), current_epoch]</code> where <code>current_epoch</code> is defined by the current wall-clock time, and clients MUST support serving requests of blocks on this range.</p> <p>Peers that are unable to reply to block requests within the <code>MIN_EPOCHS_FOR_BLOCK_REQUESTS</code> epoch range SHOULD respond with error code <code>3: ResourceUnavailable</code>. Such peers that are unable to successfully reply to this range of requests MAY get descored or disconnected at any time.</p> <p>Note: The above requirement implies that nodes that start from a recent weak subjectivity checkpoint MUST backfill the local block database to at least epoch <code>current_epoch - MIN_EPOCHS_FOR_BLOCK_REQUESTS</code> to be fully compliant with <code>BlocksByRange</code> requests. To safely perform such a backfill of blocks to the recent state, the node MUST validate both (1) the proposer signatures and (2) that the blocks form a valid chain up to the most recent block referenced in the weak subjectivity state.</p> <p>Note: Although clients that bootstrap from a weak subjectivity checkpoint can begin participating in the networking immediately, other peers MAY disconnect and/or temporarily ban such an un-synced or semi-synced client.</p> <p>Clients MUST respond with at least the first block that exists in the range, if they have it, and no more than <code>MAX_REQUEST_BLOCKS</code> blocks.</p> <p>The following blocks, where they exist, MUST be sent in consecutive order.</p> <p>Clients MAY limit the number of blocks in the response.</p> <p>The response MUST contain no more than <code>count</code> blocks.</p> <p>Clients MUST respond with blocks from their view of the current fork choice -- that is, blocks from the single chain defined by the current head. Of note, blocks from slots before the finalization MUST lead to the finalized block reported in the <code>Status</code> handshake.</p> <p>Clients MUST respond with blocks that are consistent from a single chain within the context of the request. This applies to any <code>step</code> value. In particular when <code>step == 1</code>, each <code>parent_root</code> MUST match the <code>hash_tree_root</code> of the preceding block.</p> <p>After the initial block, clients MAY stop in the process of responding if their fork choice changes the view of the chain in the context of the request.</p>"},{"location":"specs/phase0/p2p-interface/#beaconblocksbyroot","title":"BeaconBlocksByRoot","text":"<p>Protocol ID: <code>/eth2/beacon_chain/req/beacon_blocks_by_root/1/</code></p> <p>Request Content:</p> <pre><code>(\n  List[Root, MAX_REQUEST_BLOCKS]\n)\n</code></pre> <p>Response Content:</p> <pre><code>(\n  List[SignedBeaconBlock, MAX_REQUEST_BLOCKS]\n)\n</code></pre> <p>Requests blocks by block root (= <code>hash_tree_root(SignedBeaconBlock.message)</code>). The response is a list of <code>SignedBeaconBlock</code> whose length is less than or equal to the number of requested blocks. It may be less in the case that the responding peer is missing blocks.</p> <p>No more than <code>MAX_REQUEST_BLOCKS</code> may be requested at a time.</p> <p><code>BeaconBlocksByRoot</code> is primarily used to recover recent blocks (e.g. when receiving a block or attestation whose parent is unknown).</p> <p>The request MUST be encoded as an SSZ-field.</p> <p>The response MUST consist of zero or more <code>response_chunk</code>. Each successful <code>response_chunk</code> MUST contain a single <code>SignedBeaconBlock</code> payload.</p> <p>Clients MUST support requesting blocks since the latest finalized epoch.</p> <p>Clients MUST respond with at least one block, if they have it. Clients MAY limit the number of blocks in the response.</p> <p>Clients MAY include a block in the response as soon as it passes the gossip validation rules. Clients SHOULD NOT respond with blocks that fail the beacon chain state transition.</p> <p><code>/eth2/beacon_chain/req/beacon_blocks_by_root/1/</code> is deprecated. Clients MAY respond with an empty list during the deprecation transition period.</p>"},{"location":"specs/phase0/p2p-interface/#ping","title":"Ping","text":"<p>Protocol ID: <code>/eth2/beacon_chain/req/ping/1/</code></p> <p>Request Content:</p> <pre><code>(\n  uint64\n)\n</code></pre> <p>Response Content:</p> <pre><code>(\n  uint64\n)\n</code></pre> <p>Sent intermittently, the <code>Ping</code> protocol checks liveness of connected peers. Peers request and respond with their local metadata sequence number (<code>MetaData.seq_number</code>).</p> <p>If the peer does not respond to the <code>Ping</code> request, the client MAY disconnect from the peer.</p> <p>A client can then determine if their local record of a peer's MetaData is up to date and MAY request an updated version via the <code>MetaData</code> RPC method if not.</p> <p>The request MUST be encoded as an SSZ-field.</p> <p>The response MUST consist of a single <code>response_chunk</code>.</p>"},{"location":"specs/phase0/p2p-interface/#getmetadata","title":"GetMetaData","text":"<p>Protocol ID: <code>/eth2/beacon_chain/req/metadata/1/</code></p> <p>No Request Content.</p> <p>Response Content:</p> <pre><code>(\n  MetaData\n)\n</code></pre> <p>Requests the MetaData of a peer. The request opens and negotiates the stream without sending any request content. Once established the receiving peer responds with it's local most up-to-date MetaData.</p> <p>The response MUST be encoded as an SSZ-container.</p> <p>The response MUST consist of a single <code>response_chunk</code>.</p>"},{"location":"specs/phase0/p2p-interface/#the-discovery-domain-discv5","title":"The discovery domain: discv5","text":"<p>Discovery Version 5 (discv5) (Protocol version v5.1) is used for peer discovery.</p> <p><code>discv5</code> is a standalone protocol, running on UDP on a dedicated port, meant for peer discovery only. <code>discv5</code> supports self-certified, flexible peer records (ENRs) and topic-based advertisement, both of which are (or will be) requirements in this context.</p>"},{"location":"specs/phase0/p2p-interface/#integration-into-libp2p-stacks","title":"Integration into libp2p stacks","text":"<p><code>discv5</code> SHOULD be integrated into the client\u2019s libp2p stack by implementing an adaptor to make it conform to the service discovery and peer routing abstractions and interfaces (go-libp2p links provided).</p> <p>Inputs to operations include peer IDs (when locating a specific peer) or capabilities (when searching for peers with a specific capability), and the outputs will be multiaddrs converted from the ENR records returned by the discv5 backend.</p> <p>This integration enables the libp2p stack to subsequently form connections and streams with discovered peers.</p>"},{"location":"specs/phase0/p2p-interface/#enr-structure","title":"ENR structure","text":"<p>The Ethereum Node Record (ENR) for an Ethereum consensus client MUST contain the following entries (exclusive of the sequence number and signature, which MUST be present in an ENR):</p> <ul> <li>The compressed secp256k1 publickey, 33 bytes (<code>secp256k1</code> field).</li> </ul> <p>The ENR MAY contain the following entries:</p> <ul> <li>An IPv4 address (<code>ip</code> field) and/or IPv6 address (<code>ip6</code> field).</li> <li>A TCP port (<code>tcp</code> field) representing the local libp2p listening port.</li> <li>A UDP port (<code>udp</code> field) representing the local discv5 listening port.</li> </ul> <p>Specifications of these parameters can be found in the ENR Specification.</p>"},{"location":"specs/phase0/p2p-interface/#attestation-subnet-bitfield","title":"Attestation subnet bitfield","text":"<p>The ENR <code>attnets</code> entry signifies the attestation subnet bitfield with the following form to more easily discover peers participating in particular attestation gossip subnets.</p> Key Value <code>attnets</code> SSZ <code>Bitvector[ATTESTATION_SUBNET_COUNT]</code> <p>If a node's <code>MetaData.attnets</code> has any non-zero bit, the ENR MUST include the <code>attnets</code> entry with the same value as <code>MetaData.attnets</code>.</p> <p>If a node's <code>MetaData.attnets</code> is composed of all zeros, the ENR MAY optionally include the <code>attnets</code> entry or leave it out entirely.</p>"},{"location":"specs/phase0/p2p-interface/#eth2-field","title":"<code>eth2</code> field","text":"<p>ENRs MUST carry a generic <code>eth2</code> key with an 16-byte value of the node's current fork digest, next fork version, and next fork epoch to ensure connections are made with peers on the intended Ethereum network.</p> Key Value <code>eth2</code> SSZ <code>ENRForkID</code> <p>Specifically, the value of the <code>eth2</code> key MUST be the following SSZ encoded object (<code>ENRForkID</code>)</p> <pre><code>(\n    fork_digest: ForkDigest\n    next_fork_version: Version\n    next_fork_epoch: Epoch\n)\n</code></pre> <p>where the fields of <code>ENRForkID</code> are defined as</p> <ul> <li><code>fork_digest</code> is <code>compute_fork_digest(current_fork_version, genesis_validators_root)</code> where<ul> <li><code>current_fork_version</code> is the fork version at the node's current epoch defined by the wall-clock time   (not necessarily the epoch to which the node is sync)</li> <li><code>genesis_validators_root</code> is the static <code>Root</code> found in <code>state.genesis_validators_root</code></li> </ul> </li> <li><code>next_fork_version</code> is the fork version corresponding to the next planned hard fork at a future epoch.   If no future fork is planned, set <code>next_fork_version = current_fork_version</code> to signal this fact</li> <li><code>next_fork_epoch</code> is the epoch at which the next fork is planned and the <code>current_fork_version</code> will be updated.   If no future fork is planned, set <code>next_fork_epoch = FAR_FUTURE_EPOCH</code> to signal this fact</li> </ul> <p>Note: <code>fork_digest</code> is composed of values that are not known until the genesis block/state are available. Due to this, clients SHOULD NOT form ENRs and begin peer discovery until genesis values are known. One notable exception to this rule is the distribution of bootnode ENRs prior to genesis. In this case, bootnode ENRs SHOULD be initially distributed with <code>eth2</code> field set as <code>ENRForkID(fork_digest=compute_fork_digest(GENESIS_FORK_VERSION, b'\\x00'*32), next_fork_version=GENESIS_FORK_VERSION, next_fork_epoch=FAR_FUTURE_EPOCH)</code>. After genesis values are known, the bootnodes SHOULD update ENRs to participate in normal discovery operations.</p> <p>Clients SHOULD connect to peers with <code>fork_digest</code>, <code>next_fork_version</code>, and <code>next_fork_epoch</code> that match local values.</p> <p>Clients MAY connect to peers with the same <code>fork_digest</code> but a different <code>next_fork_version</code>/<code>next_fork_epoch</code>. Unless <code>ENRForkID</code> is manually updated to matching prior to the earlier <code>next_fork_epoch</code> of the two clients, these connecting clients will be unable to successfully interact starting at the earlier <code>next_fork_epoch</code>.</p>"},{"location":"specs/phase0/p2p-interface/#attestation-subnet-subscription","title":"Attestation subnet subscription","text":"<p>Because Phase 0 does not have shards and thus does not have Shard Committees, there is no stable backbone to the attestation subnets (<code>beacon_attestation_{subnet_id}</code>). To provide this stability, each beacon node should:</p> <ul> <li>Remain subscribed to <code>SUBNETS_PER_NODE</code> for <code>EPOCHS_PER_SUBNET_SUBSCRIPTION</code> epochs.</li> <li>Maintain advertisement of the selected subnets in their node's ENR <code>attnets</code> entry by setting the selected <code>subnet_id</code> bits to <code>True</code> (e.g. <code>ENR[\"attnets\"][subnet_id] = True</code>) for all persistent attestation subnets.</li> <li>Select these subnets based on their node-id as specified by the following <code>compute_subscribed_subnets(node_id, epoch)</code> function.</li> </ul> <pre><code>def compute_subscribed_subnet(node_id: NodeID, epoch: Epoch, index: int) -&gt; SubnetID:\nnode_id_prefix = node_id &gt;&gt; (NODE_ID_BITS - ATTESTATION_SUBNET_PREFIX_BITS)\nnode_offset = node_id % EPOCHS_PER_SUBNET_SUBSCRIPTION\npermutation_seed = hash(uint_to_bytes(uint64((epoch + node_offset) // EPOCHS_PER_SUBNET_SUBSCRIPTION)))\npermutated_prefix = compute_shuffled_index(\nnode_id_prefix,\n1 &lt;&lt; ATTESTATION_SUBNET_PREFIX_BITS,\npermutation_seed,\n)\nreturn SubnetID((permutated_prefix + index) % ATTESTATION_SUBNET_COUNT)\n</code></pre> <pre><code>def compute_subscribed_subnets(node_id: NodeID, epoch: Epoch) -&gt; Sequence[SubnetID]:\nreturn [compute_subscribed_subnet(node_id, epoch, index) for index in range(SUBNETS_PER_NODE)]\n</code></pre> <p>Note: When preparing for a hard fork, a node must select and subscribe to subnets of the future fork versioning at least <code>EPOCHS_PER_SUBNET_SUBSCRIPTION</code> epochs in advance of the fork. These new subnets for the fork are maintained in addition to those for the current fork until the fork occurs. After the fork occurs, let the subnets from the previous fork reach the end of life with no replacements.</p>"},{"location":"specs/phase0/p2p-interface/#design-decision-rationale","title":"Design decision rationale","text":""},{"location":"specs/phase0/p2p-interface/#transport_1","title":"Transport","text":""},{"location":"specs/phase0/p2p-interface/#why-are-we-defining-specific-transports","title":"Why are we defining specific transports?","text":"<p>libp2p peers can listen on multiple transports concurrently, and these can change over time. Multiaddrs encode not only the address but also the transport to be used to dial.</p> <p>Due to this dynamic nature, agreeing on specific transports like TCP, QUIC, or WebSockets on paper becomes irrelevant.</p> <p>However, it is useful to define a minimum baseline for interoperability purposes.</p>"},{"location":"specs/phase0/p2p-interface/#can-clients-support-other-transportshandshakes-than-the-ones-mandated-by-the-spec","title":"Can clients support other transports/handshakes than the ones mandated by the spec?","text":"<p>Clients may support other transports such as libp2p QUIC, WebSockets, and WebRTC transports, if available in the language of choice. While interoperability shall not be harmed by lack of such support, the advantages are desirable:</p> <ul> <li>Better latency, performance, and other QoS characteristics (QUIC).</li> <li>Paving the way for interfacing with future light clients (WebSockets, WebRTC).</li> </ul> <p>The libp2p QUIC transport inherently relies on TLS 1.3 per requirement in section 7 of the QUIC protocol specification and the accompanying QUIC-TLS document.</p> <p>The usage of one handshake procedure or the other shall be transparent to the application layer, once the libp2p Host/Node object has been configured appropriately.</p>"},{"location":"specs/phase0/p2p-interface/#what-are-the-advantages-of-using-tcpquicwebsockets","title":"What are the advantages of using TCP/QUIC/Websockets?","text":"<p>TCP is a reliable, ordered, full-duplex, congestion-controlled network protocol that powers much of the Internet as we know it today. HTTP/1.1 and HTTP/2 run atop TCP.</p> <p>QUIC is a new protocol that\u2019s in the final stages of specification by the IETF QUIC WG. It emerged from Google\u2019s SPDY experiment. The QUIC transport is undoubtedly promising. It\u2019s UDP-based yet reliable, ordered, multiplexed, natively secure (TLS 1.3), reduces latency vs. TCP, and offers stream-level and connection-level congestion control (thus removing head-of-line blocking), 0-RTT connection establishment, and endpoint migration, amongst other features. UDP also has better NAT traversal properties than TCP\u2014something we desperately pursue in peer-to-peer networks.</p> <p>QUIC is being adopted as the underlying protocol for HTTP/3. This has the potential to award us censorship resistance via deep packet inspection for free. Provided that we use the same port numbers and encryption mechanisms as HTTP/3, our traffic may be indistinguishable from standard web traffic, and we may only become subject to standard IP-based firewall filtering\u2014something we can counteract via other mechanisms.</p> <p>WebSockets and/or WebRTC transports are necessary for interaction with browsers, and will become increasingly important as we incorporate browser-based light clients to the Ethereum network.</p>"},{"location":"specs/phase0/p2p-interface/#why-do-we-not-just-support-a-single-transport","title":"Why do we not just support a single transport?","text":"<p>Networks evolve. Hardcoding design decisions leads to ossification, preventing the evolution of networks alongside the state of the art. Introducing changes on an ossified protocol is very costly, and sometimes, downright impracticable without causing undesirable breakage.</p> <p>Modeling for upgradeability and dynamic transport selection from the get-go lays the foundation for a future-proof stack.</p> <p>Clients can adopt new transports without breaking old ones, and the multi-transport ability enables constrained and sandboxed environments (e.g. browsers, embedded devices) to interact with the network as first-class citizens via suitable/native transports (e.g. WSS), without the need for proxying or trust delegation to servers.</p>"},{"location":"specs/phase0/p2p-interface/#why-are-we-not-using-quic-from-the-start","title":"Why are we not using QUIC from the start?","text":"<p>The QUIC standard is still not finalized (at working draft 22 at the time of writing), and not all mainstream runtimes/languages have mature, standard, and/or fully-interoperable QUIC support. One remarkable example is node.js, where the QUIC implementation is in early development.</p> <p>Note: TLS 1.3 is a prerequisite of the QUIC transport, although an experiment exists to integrate Noise as the QUIC crypto layer: nQUIC.</p> <p>On the other hand, TLS 1.3 is the newest, simplified iteration of TLS. Old, insecure, obsolete ciphers and algorithms have been removed, adopting Ed25519 as the sole ECDH key agreement function. Handshakes are faster, 1-RTT data is supported, and session resumption is a reality, amongst other features.</p>"},{"location":"specs/phase0/p2p-interface/#multiplexing_1","title":"Multiplexing","text":""},{"location":"specs/phase0/p2p-interface/#why-are-we-using-mplexyamux","title":"Why are we using mplex/yamux?","text":"<p>Yamux is a multiplexer invented by Hashicorp that supports stream-level congestion control. Implementations exist in a limited set of languages, and it\u2019s not a trivial piece to develop.</p> <p>Conscious of that, the libp2p community conceptualized mplex as a simple, minimal multiplexer for usage with libp2p. It does not support stream-level congestion control and is subject to head-of-line blocking.</p> <p>Overlay multiplexers are not necessary with QUIC since the protocol provides native multiplexing, but they need to be layered atop TCP, WebSockets, and other transports that lack such support.</p>"},{"location":"specs/phase0/p2p-interface/#protocol-negotiation_1","title":"Protocol Negotiation","text":""},{"location":"specs/phase0/p2p-interface/#when-is-multiselect-20-due-and-why-do-we-plan-to-migrate-to-it","title":"When is multiselect 2.0 due and why do we plan to migrate to it?","text":"<p>multiselect 2.0 is currently being conceptualized. The debate started on this issue, but it got overloaded\u2014as it tends to happen with large conceptual OSS discussions that touch the heart and core of a system.</p> <p>At some point in 2020, we expect a renewed initiative to first define the requirements, constraints, assumptions, and features, in order to lock in basic consensus upfront and subsequently build on that consensus by submitting a specification for implementation.</p> <p>We plan to eventually migrate to multiselect 2.0 because it will:</p> <ol> <li>Reduce round trips during connection bootstrapping and stream protocol negotiation.</li> <li>Enable efficient one-stream-per-request interaction patterns.</li> <li>Leverage push data mechanisms of underlying protocols to expedite negotiation.</li> <li>Provide the building blocks for enhanced censorship resistance.</li> </ol>"},{"location":"specs/phase0/p2p-interface/#what-is-the-difference-between-connection-level-and-stream-level-protocol-negotiation","title":"What is the difference between connection-level and stream-level protocol negotiation?","text":"<p>All libp2p connections must be authenticated, encrypted, and multiplexed. Connections using network transports unsupportive of native authentication/encryption and multiplexing (e.g. TCP) need to undergo protocol negotiation to agree on a mutually supported:</p> <ol> <li>authentication/encryption mechanism (such as SecIO, TLS 1.3, Noise).</li> <li>overlay multiplexer (such as mplex, Yamux, spdystream).</li> </ol> <p>In this specification, we refer to these two as connection-level negotiations. Transports supporting those features natively (such as QUIC) omit those negotiations.</p> <p>After successfully selecting a multiplexer, all subsequent I/O happens over streams. When opening streams, peers pin a protocol to that stream, by conducting stream-level protocol negotiation.</p> <p>At present, multistream-select 1.0 is used for both types of negotiation, but multiselect 2.0 will use dedicated mechanisms for connection bootstrapping process and stream protocol negotiation.</p>"},{"location":"specs/phase0/p2p-interface/#encryption","title":"Encryption","text":""},{"location":"specs/phase0/p2p-interface/#why-are-we-not-supporting-secio","title":"Why are we not supporting SecIO?","text":"<p>SecIO has been the default encryption layer for libp2p for years. It is used in IPFS and Filecoin. And although it will be superseded shortly, it is proven to work at scale.</p> <p>Although SecIO has wide language support, we won\u2019t be using it for mainnet because, amongst other things, it requires several round trips to be sound, and doesn\u2019t support early data (0-RTT data), a mechanism that multiselect 2.0 will leverage to reduce round trips during connection bootstrapping.</p> <p>SecIO is not considered secure for the purposes of this spec.</p>"},{"location":"specs/phase0/p2p-interface/#why-are-we-using-noise","title":"Why are we using Noise?","text":"<p>Copied from the Noise Protocol Framework website:</p> <p>Noise is a framework for building crypto protocols. Noise protocols support mutual and optional authentication, identity hiding, forward secrecy, zero round-trip encryption, and other advanced features.</p> <p>Noise in itself does not specify a single handshake procedure, but provides a framework to build secure handshakes based on Diffie-Hellman key agreement with a variety of tradeoffs and guarantees.</p> <p>Noise handshakes are lightweight and simple to understand, and are used in major cryptographic-centric projects like WireGuard, I2P, and Lightning. Various studies have assessed the stated security goals of several Noise handshakes with positive results.</p>"},{"location":"specs/phase0/p2p-interface/#why-are-we-using-encryption-at-all","title":"Why are we using encryption at all?","text":"<p>Transport level encryption secures message exchange and provides properties that are useful for privacy, safety, and censorship resistance. These properties are derived from the following security guarantees that apply to the entire communication between two peers:</p> <ul> <li>Peer authentication: the peer I\u2019m talking to is really who they claim to be and who I expect them to be.</li> <li>Confidentiality: no observer can eavesdrop on the content of our messages.</li> <li>Integrity: the data has not been tampered with by a third-party while in transit.</li> <li>Non-repudiation: the originating peer cannot dispute that they sent the message.</li> <li>Depending on the chosen algorithms and mechanisms (e.g. continuous HMAC), we may obtain additional guarantees,   such as non-replayability (this byte could\u2019ve only been sent now; e.g. by using continuous HMACs),   or perfect forward secrecy (in the case that a peer key is compromised, the content of a past conversation will not be compromised).</li> </ul> <p>Note that transport-level encryption is not exclusive of application-level encryption or cryptography. Transport-level encryption secures the communication itself, while application-level cryptography is necessary for the application\u2019s use cases (e.g. signatures, randomness, etc.).</p>"},{"location":"specs/phase0/p2p-interface/#gossipsub","title":"Gossipsub","text":""},{"location":"specs/phase0/p2p-interface/#why-are-we-using-a-pubsub-algorithm-for-block-and-attestation-propagation","title":"Why are we using a pub/sub algorithm for block and attestation propagation?","text":"<p>Pubsub is a technique to broadcast/disseminate data across a network rapidly. Such data is packaged in fire-and-forget messages that do not require a response from every recipient. Peers subscribed to a topic participate in the propagation of messages in that topic.</p> <p>The alternative is to maintain a fully connected mesh (all peers connected to each other 1:1), which scales poorly (O(n^2)).</p>"},{"location":"specs/phase0/p2p-interface/#why-are-we-using-topics-to-segregate-encodings-yet-only-support-one-encoding","title":"Why are we using topics to segregate encodings, yet only support one encoding?","text":"<p>For future extensibility with almost zero overhead now (besides the extra bytes in the topic name).</p>"},{"location":"specs/phase0/p2p-interface/#how-do-we-upgrade-gossip-channels-eg-changes-in-encoding-compression","title":"How do we upgrade gossip channels (e.g. changes in encoding, compression)?","text":"<p>Changing gossipsub/broadcasts requires a coordinated upgrade where all clients start publishing to the new topic together, during a hard fork.</p> <p>When a node is preparing for upcoming tasks (e.g. validator duty lookahead) on a gossipsub topic, the node should join the topic of the future epoch in which the task is to occur in addition to listening to the topics for the current epoch.</p>"},{"location":"specs/phase0/p2p-interface/#why-must-all-clients-use-the-same-gossip-topic-instead-of-one-negotiated-between-each-peer-pair","title":"Why must all clients use the same gossip topic instead of one negotiated between each peer pair?","text":"<p>Supporting multiple topics/encodings would require the presence of relayers to translate between encodings and topics so as to avoid network fragmentation where participants have diverging views on the gossiped state, making the protocol more complicated and fragile.</p> <p>Gossip protocols typically remember what messages they've seen for a finite period of time-based on message identity -- if you publish the same message again after that time has passed, it will be re-broadcast\u2014adding a relay delay also makes this scenario more likely.</p> <p>One can imagine that in a complicated upgrade scenario, we might have peers publishing the same message on two topics/encodings, but the price here is pretty high in terms of overhead -- both computational and networking -- so we'd rather avoid that.</p> <p>It is permitted for clients to publish data on alternative topics as long as they also publish on the network-wide mandatory topic.</p>"},{"location":"specs/phase0/p2p-interface/#why-are-the-topics-strings-and-not-hashes","title":"Why are the topics strings and not hashes?","text":"<p>Topic names have a hierarchical structure. In the future, gossipsub may support wildcard subscriptions (e.g. subscribe to all children topics under a root prefix) by way of prefix matching. Enforcing hashes for topic names would preclude us from leveraging such features going forward.</p> <p>No security or privacy guarantees are lost as a result of choosing plaintext topic names, since the domain is finite anyway, and calculating a digest's preimage would be trivial.</p> <p>Furthermore, the topic names are shorter than their digest equivalents (assuming SHA-256 hash), so hashing topics would bloat messages unnecessarily.</p>"},{"location":"specs/phase0/p2p-interface/#why-are-we-using-the-strictnosign-signature-policy","title":"Why are we using the <code>StrictNoSign</code> signature policy?","text":"<p>The policy omits the <code>from</code> (1), <code>seqno</code> (3), <code>signature</code> (5) and <code>key</code> (6) fields. These fields would: - Expose origin of sender (<code>from</code>), type of sender (based on <code>seqno</code>) - Add extra unused data to the gossip, since message IDs are based on <code>data</code>, not on the <code>from</code> and <code>seqno</code>. - Introduce more message validation than necessary, e.g. no <code>signature</code>.</p>"},{"location":"specs/phase0/p2p-interface/#why-are-we-overriding-the-default-libp2p-pubsub-message-id","title":"Why are we overriding the default libp2p pubsub <code>message-id</code>?","text":"<p>For our current purposes, there is no need to address messages based on source peer, or track a message <code>seqno</code>. By overriding the default <code>message-id</code> to use content-addressing we can filter unnecessary duplicates before hitting the application layer.</p> <p>Some examples of where messages could be duplicated:</p> <ul> <li>A validator client connected to multiple beacon nodes publishing duplicate gossip messages</li> <li>Attestation aggregation strategies where clients partially aggregate attestations and propagate them.   Partial aggregates could be duplicated</li> <li>Clients re-publishing seen messages</li> </ul>"},{"location":"specs/phase0/p2p-interface/#why-are-these-specific-gossip-parameters-chosen","title":"Why are these specific gossip parameters chosen?","text":"<ul> <li><code>D</code>, <code>D_low</code>, <code>D_high</code>, <code>D_lazy</code>: recommended defaults.</li> <li><code>heartbeat_interval</code>: 0.7 seconds, recommended for the beacon chain in the GossipSub evaluation report by Protocol Labs.</li> <li><code>fanout_ttl</code>: 60 seconds, recommended default.   Fanout is primarily used by committees publishing attestations to subnets.   This happens once per epoch per validator and the subnet changes each epoch   so there is little to gain in having a <code>fanout_ttl</code> be increased from the recommended default.</li> <li><code>mcache_len</code>: 6, increase by one to ensure that mcache is around for long   enough for <code>IWANT</code>s to respond to <code>IHAVE</code>s in the context of the shorter   <code>heartbeat_interval</code>. If <code>mcache_gossip</code> is increased, this param should be   increased to be at least <code>3</code> (~2 seconds) more than <code>mcache_gossip</code>.</li> <li><code>mcache_gossip</code>: 3, recommended default. This can be increased to 5 or 6   (~4 seconds) if gossip times are longer than expected and the current window   does not provide enough responsiveness during adverse conditions.</li> <li><code>seen_ttl</code>: <code>SLOTS_PER_EPOCH * SECONDS_PER_SLOT / heartbeat_interval = approx. 550</code>.   Attestation gossip validity is bounded by an epoch, so this is the safe max bound.</li> </ul>"},{"location":"specs/phase0/p2p-interface/#why-is-there-maximum_gossip_clock_disparity-when-validating-slot-ranges-of-messages-in-gossip-subnets","title":"Why is there <code>MAXIMUM_GOSSIP_CLOCK_DISPARITY</code> when validating slot ranges of messages in gossip subnets?","text":"<p>For some gossip channels (e.g. those for Attestations and BeaconBlocks), there are designated ranges of slots during which particular messages can be sent, limiting messages gossiped to those that can be reasonably used in the consensus at the current time/slot. This is to reduce optionality in DoS attacks.</p> <p><code>MAXIMUM_GOSSIP_CLOCK_DISPARITY</code> provides some leeway in validating slot ranges to prevent the gossip network from becoming overly brittle with respect to clock disparity. For minimum and maximum allowable slot broadcast times, <code>MAXIMUM_GOSSIP_CLOCK_DISPARITY</code> MUST be subtracted and added respectively, marginally extending the valid range. Although messages can at times be eagerly gossiped to the network, the node's fork choice prevents integration of these messages into the actual consensus until the actual local start of the designated slot.</p>"},{"location":"specs/phase0/p2p-interface/#why-are-there-attestation_subnet_count-attestation-subnets","title":"Why are there <code>ATTESTATION_SUBNET_COUNT</code> attestation subnets?","text":"<p>Depending on the number of validators, it may be more efficient to group shard subnets and might provide better stability for the gossipsub channel. The exact grouping will be dependent on more involved network tests. This constant allows for more flexibility in setting up the network topology for attestation aggregation (as aggregation should happen on each subnet). The value is currently set to be equal to <code>MAX_COMMITTEES_PER_SLOT</code> if/until network tests indicate otherwise.</p>"},{"location":"specs/phase0/p2p-interface/#why-are-attestations-limited-to-be-broadcast-on-gossip-channels-within-slots_per_epoch-slots","title":"Why are attestations limited to be broadcast on gossip channels within <code>SLOTS_PER_EPOCH</code> slots?","text":"<p>Attestations can only be included on chain within an epoch's worth of slots so this is the natural cutoff. There is no utility to the chain to broadcast attestations older than one epoch, and because validators have a chance to make a new attestation each epoch, there is minimal utility to the fork choice to relay old attestations as a new latest message can soon be created by each validator.</p> <p>In addition to this, relaying attestations requires validating the attestation in the context of the <code>state</code> during which it was created. Thus, validating arbitrarily old attestations would put additional requirements on which states need to be readily available to the node. This would result in a higher resource burden and could serve as a DoS vector.</p>"},{"location":"specs/phase0/p2p-interface/#why-are-aggregate-attestations-broadcast-to-the-global-topic-as-aggregateandproofs-rather-than-just-as-attestations","title":"Why are aggregate attestations broadcast to the global topic as <code>AggregateAndProof</code>s rather than just as <code>Attestation</code>s?","text":"<p>The dominant strategy for an individual validator is to always broadcast an aggregate containing their own attestation to the global channel to ensure that proposers see their attestation for inclusion. Using a private selection criteria and providing this proof of selection alongside the gossiped aggregate ensures that this dominant strategy will not flood the global channel.</p> <p>Also, an attacker can create any number of honest-looking aggregates and broadcast them to the global pubsub channel. Thus without some sort of proof of selection as an aggregator, the global channel can trivially be spammed.</p>"},{"location":"specs/phase0/p2p-interface/#why-are-we-sending-entire-objects-in-the-pubsub-and-not-just-hashes","title":"Why are we sending entire objects in the pubsub and not just hashes?","text":"<p>Entire objects should be sent to get the greatest propagation speeds. If only hashes are sent, then block and attestation propagation is dependent on recursive requests from each peer. In a hash-only scenario, peers could receive hashes without knowing who to download the actual contents from. Sending entire objects ensures that they get propagated through the entire network.</p>"},{"location":"specs/phase0/p2p-interface/#should-clients-gossip-blocks-if-they-cannot-validate-the-proposer-signature-due-to-not-yet-being-synced-not-knowing-the-head-block-etc","title":"Should clients gossip blocks if they cannot validate the proposer signature due to not yet being synced, not knowing the head block, etc?","text":"<p>The prohibition of unverified-block-gossiping extends to nodes that cannot verify a signature due to not being fully synced to ensure that such (amplified) DOS attacks are not possible.</p>"},{"location":"specs/phase0/p2p-interface/#how-are-we-going-to-discover-peers-in-a-gossipsub-topic","title":"How are we going to discover peers in a gossipsub topic?","text":"<p>In Phase 0, peers for attestation subnets will be found using the <code>attnets</code> entry in the ENR.</p> <p>Although this method will be sufficient for early upgrade of the beacon chain, we aim to use the more appropriate discv5 topics for this and other similar tasks in the future. ENRs should ultimately not be used for this purpose. They are best suited to store identity, location, and capability information, rather than more volatile advertisements.</p>"},{"location":"specs/phase0/p2p-interface/#how-should-fork-version-be-used-in-practice","title":"How should fork version be used in practice?","text":"<p>Fork versions are to be manually updated (likely via incrementing) at each hard fork. This is to provide native domain separation for signatures as well as to aid in usefulness for identitying peers (via ENRs) and versioning network protocols (e.g. using fork version to naturally version gossipsub topics).</p> <p><code>BeaconState.genesis_validators_root</code> is mixed into signature and ENR fork domains (<code>ForkDigest</code>) to aid in the ease of domain separation between chains. This allows fork versions to safely be reused across chains except for the case of contentious forks using the same genesis. In these cases, extra care should be taken to isolate fork versions (e.g. flip a high order bit in all future versions of one of the chains).</p> <p>A node locally stores all previous and future planned fork versions along with the each fork epoch. This allows for handling sync and processing messages starting from past forks/epochs.</p>"},{"location":"specs/phase0/p2p-interface/#reqresp","title":"Req/Resp","text":""},{"location":"specs/phase0/p2p-interface/#why-segregate-requests-into-dedicated-protocol-ids","title":"Why segregate requests into dedicated protocol IDs?","text":"<p>Requests are segregated by protocol ID to:</p> <ol> <li>Leverage protocol routing in libp2p, such that the libp2p stack will route the incoming stream to the appropriate handler.   This allows the handler function for each request type to be self-contained.   For an analogy, think about how you attach HTTP handlers to a REST API server.</li> <li>Version requests independently.   In a coarser-grained umbrella protocol, the entire protocol would have to be versioned even if just one field in a single message changed.</li> <li>Enable clients to select the individual requests/versions they support.   It would no longer be a strict requirement to support all requests,   and clients, in principle, could support a subset of requests and variety of versions.</li> <li>Enable flexibility and agility for clients adopting spec changes that impact the request, by signalling to peers exactly which subset of new/old requests they support.</li> <li>Enable clients to explicitly choose backwards compatibility at the request granularity.   Without this, clients would be forced to support entire versions of the coarser request protocol.</li> <li>Parallelise RFCs (or EIPs).   By decoupling requests from one another, each RFC that affects the request protocol can be deployed/tested/debated independently   without relying on a synchronization point to version the general top-level protocol.</li> <li>This has the benefit that clients can explicitly choose which RFCs to deploy       without buying into all other RFCs that may be included in that top-level version.</li> <li>Affording this level of granularity with a top-level protocol would imply creating as many variants       (e.g. /protocol/43-{a,b,c,d,...}) as the cartesian product of RFCs in-flight, O(n^2).</li> <li>Allow us to simplify the payload of requests.   Request-id\u2019s and method-ids no longer need to be sent.   The encoding/request type and version can all be handled by the framework.</li> </ol> <p>Caveat: The protocol negotiation component in the current version of libp2p is called multistream-select 1.0. It is somewhat na\u00efve and introduces overhead on every request when negotiating streams, although implementation-specific optimizations are possible to save this cost. Multiselect 2.0 will eventually remove this overhead by memoizing previously selected protocols, and modeling shared protocol tables. Fortunately, this req/resp protocol is not the expected network bottleneck in the protocol so the additional overhead is not expected to significantly hinder this domain.</p>"},{"location":"specs/phase0/p2p-interface/#why-are-messages-length-prefixed-with-a-protobuf-varint-in-the-ssz-encoding","title":"Why are messages length-prefixed with a protobuf varint in the SSZ-encoding?","text":"<p>We are using single-use streams where each stream is closed at the end of the message. Thus, libp2p transparently handles message delimiting in the underlying stream. libp2p streams are full-duplex, and each party is responsible for closing their write side (like in TCP). We can therefore use stream closure to mark the end of the request and response independently.</p> <p>Nevertheless, in the case of <code>ssz_snappy</code>, messages are still length-prefixed with the length of the underlying data: * A basic reader can prepare a correctly sized buffer before reading the message * A more advanced reader can stream-decode SSZ given the length of the SSZ data. * Alignment with protocols like gRPC over HTTP/2 that prefix with length * Sanity checking of message length, and enabling much stricter message length limiting based on SSZ type information,   to provide even more DOS protection than the global message length already does.   E.g. a small <code>Status</code> message does not nearly require <code>MAX_CHUNK_SIZE</code> bytes.</p> <p>Protobuf varint is an efficient technique to encode variable-length (unsigned here) ints. Instead of reserving a fixed-size field of as many bytes as necessary to convey the maximum possible value, this field is elastic in exchange for 1-bit overhead per byte.</p>"},{"location":"specs/phase0/p2p-interface/#why-do-we-version-protocol-strings-with-ordinals-instead-of-semver","title":"Why do we version protocol strings with ordinals instead of semver?","text":"<p>Using semver for network protocols is confusing. It is never clear what a change in a field, even if backwards compatible on deserialization, actually implies. Network protocol agreement should be explicit. Imagine two peers:</p> <ul> <li>Peer A supporting v1.1.1 of protocol X.</li> <li>Peer B supporting v1.1.2 of protocol X.</li> </ul> <p>These two peers should never speak to each other because the results can be unpredictable. This is an oversimplification: imagine the same problem with a set of 10 possible versions. We now have 10^2 (100) possible outcomes that peers need to model for. The resulting complexity is unwieldy.</p> <p>For this reason, we rely on negotiation of explicit, verbatim protocols. In the above case, peer B would provide backwards compatibility by supporting and advertising both v1.1.1 and v1.1.2 of the protocol.</p> <p>Therefore, semver would be relegated to convey expectations at the human level, and it wouldn't do a good job there either, because it's unclear if \"backwards compatibility\" and \"breaking change\" apply only to wire schema level, to behavior, etc.</p> <p>For this reason, we remove and replace semver with ordinals that require explicit agreement and do not mandate a specific policy for changes.</p>"},{"location":"specs/phase0/p2p-interface/#why-is-it-called-reqresp-and-not-rpc","title":"Why is it called Req/Resp and not RPC?","text":"<p>Req/Resp is used to avoid confusion with JSON-RPC and similar user-client interaction mechanisms.</p>"},{"location":"specs/phase0/p2p-interface/#why-do-we-allow-empty-responses-in-block-requests","title":"Why do we allow empty responses in block requests?","text":"<p>When requesting blocks by range or root, it may happen that there are no blocks in the selected range or the responding node does not have the requested blocks.</p> <p>Thus, it may happen that we need to transmit an empty list - there are several ways to encode this:</p> <p>0) Close the stream without sending any data 1) Add a <code>null</code> option to the <code>success</code> response, for example by introducing an additional byte 2) Respond with an error result, using a specific error code for \"No data\"</p> <p>Semantically, it is not an error that a block is missing during a slot making option 2 unnatural.</p> <p>Option 1 allows the responder to signal \"no block\", but this information may be wrong - for example in the case of a malicious node.</p> <p>Under option 0, there is no way for a client to distinguish between a slot without a block and an incomplete response, but given that it already must contain logic to handle the uncertainty of a malicious peer, option 0 was chosen. Clients should mark any slots missing blocks as unknown until they can be verified as not containing a block by successive blocks.</p> <p>Assuming option 0 with no special <code>null</code> encoding, consider a request for slots <code>2, 3, 4</code> -- if there was no block produced at slot 4, the response would be <code>2, 3, EOF</code>. Now consider the same situation, but where only <code>4</code> is requested -- closing the stream with only <code>EOF</code> (without any <code>response_chunk</code>) is consistent.</p> <p>Failing to provide blocks that nodes \"should\" have is reason to trust a peer less -- for example, if a particular peer gossips a block, it should have access to its parent. If a request for the parent fails, it's indicative of poor peer quality since peers should validate blocks before gossiping them.</p>"},{"location":"specs/phase0/p2p-interface/#why-does-beaconblocksbyrange-let-the-server-choose-which-branch-to-send-blocks-from","title":"Why does <code>BeaconBlocksByRange</code> let the server choose which branch to send blocks from?","text":"<p>When connecting, the <code>Status</code> message gives an idea about the sync status of a particular peer, but this changes over time. By the time a subsequent <code>BeaconBlockByRange</code> request is processed, the information may be stale, and the responding side might have moved on to a new finalization point and pruned blocks around the previous head and finalized blocks.</p> <p>To avoid this race condition, we allow the responding side to choose which branch to send to the requesting client. The requesting client then goes on to validate the blocks and incorporate them in their own database -- because they follow the same rules, they should at this point arrive at the same canonical chain.</p>"},{"location":"specs/phase0/p2p-interface/#why-are-blocksbyrange-requests-only-required-to-be-served-for-the-latest-min_epochs_for_block_requests-epochs","title":"Why are <code>BlocksByRange</code> requests only required to be served for the latest <code>MIN_EPOCHS_FOR_BLOCK_REQUESTS</code> epochs?","text":"<p>Due to economic finality and weak subjectivity requirements of a proof-of-stake blockchain, for a new node to safely join the network the node must provide a recent checkpoint found out-of-band. This checkpoint can be in the form of a <code>root</code> &amp; <code>epoch</code> or it can be the entire beacon state and then a simple block sync from there to the head. We expect the latter to be the dominant UX strategy.</p> <p>These checkpoints in the worst case (i.e. very large validator set and maximal allowed safety decay) must be from the most recent <code>MIN_EPOCHS_FOR_BLOCK_REQUESTS</code> epochs, and thus a user must be able to block sync to the head from this starting point. Thus, this defines the epoch range outside which nodes may prune blocks, and the epoch range that a new node syncing from a checkpoint must backfill.</p> <p><code>MIN_EPOCHS_FOR_BLOCK_REQUESTS</code> is calculated using the arithmetic from <code>compute_weak_subjectivity_period</code> found in the weak subjectivity guide. Specifically to find this max epoch range, we use the worst case event of a very large validator size (<code>&gt;= MIN_PER_EPOCH_CHURN_LIMIT * CHURN_LIMIT_QUOTIENT</code>).</p> <pre><code>MIN_EPOCHS_FOR_BLOCK_REQUESTS = (\nMIN_VALIDATOR_WITHDRAWABILITY_DELAY\n+ MAX_SAFETY_DECAY * CHURN_LIMIT_QUOTIENT // (2 * 100)\n)\n</code></pre> <p>Where <code>MAX_SAFETY_DECAY = 100</code> and thus <code>MIN_EPOCHS_FOR_BLOCK_REQUESTS = 33024</code> (~5 months).</p>"},{"location":"specs/phase0/p2p-interface/#why-must-the-proposer-signature-be-checked-when-backfilling-blocks-in-the-database","title":"Why must the proposer signature be checked when backfilling blocks in the database?","text":"<p>When backfilling blocks in a database from a know safe block/state (e.g. when starting from a weak subjectivity state), the node not only must ensure the <code>BeaconBlock</code>s form a chain to the known safe block, but also must check that the proposer signature is valid in the <code>SignedBeaconBlock</code> wrapper.</p> <p>This is because the signature is not part of the <code>BeaconBlock</code> hash chain, and thus could be corrupted by an attacker serving valid <code>BeaconBlock</code>s but invalid signatures contained in <code>SignedBeaconBlock</code>.</p> <p>Although in this particular use case this does not represent a decay in safety (due to the assumptions of starting at a weak subjectivity checkpoint), it would represent invalid historic data and could be unwittingly transmitted to additional nodes.</p>"},{"location":"specs/phase0/p2p-interface/#whats-the-effect-of-empty-slots-on-the-sync-algorithm","title":"What's the effect of empty slots on the sync algorithm?","text":"<p>When syncing one can only tell that a slot has been skipped on a particular branch by examining subsequent blocks and analyzing the graph formed by the parent root. Because the server side may choose to omit blocks in the response for any reason, clients must validate the graph and be prepared to fill in gaps.</p> <p>For example, if a peer responds with blocks [2, 3] when asked for [2, 3, 4], clients may not assume that block 4 doesn't exist -- it merely means that the responding peer did not send it (they may not have it yet or may maliciously be trying to hide it) and successive blocks will be needed to determine if there exists a block at slot 4 in this particular branch.</p>"},{"location":"specs/phase0/p2p-interface/#discovery","title":"Discovery","text":""},{"location":"specs/phase0/p2p-interface/#why-are-we-using-discv5-and-not-libp2p-kademlia-dht","title":"Why are we using discv5 and not libp2p Kademlia DHT?","text":"<p>discv5 is a standalone protocol, running on UDP on a dedicated port, meant for peer and service discovery only. discv5 supports self-certified, flexible peer records (ENRs) and topic-based advertisement, both of which are, or will be, requirements in this context.</p> <p>On the other hand, libp2p Kademlia DHT is a fully-fledged DHT protocol/implementations with content routing and storage capabilities, both of which are irrelevant in this context.</p> <p>Ethereum execution-layer nodes will evolve to support discv5. By sharing the discovery network between Ethereum consensus-layer and execution-layer clients, we benefit from the additive effect on network size that enhances resilience and resistance against certain attacks, to which smaller networks are more vulnerable. It should also help light clients of both networks find nodes with specific capabilities.</p> <p>discv5 is in the process of being audited.</p>"},{"location":"specs/phase0/p2p-interface/#what-is-the-difference-between-an-enr-and-a-multiaddr-and-why-are-we-using-enrs","title":"What is the difference between an ENR and a multiaddr, and why are we using ENRs?","text":"<p>Ethereum Node Records are self-certified node records. Nodes craft and disseminate ENRs for themselves, proving authorship via a cryptographic signature. ENRs are sequentially indexed, enabling conflicts to be resolved.</p> <p>ENRs are key-value records with string-indexed ASCII keys. They can store arbitrary information, but EIP-778 specifies a pre-defined dictionary, including IPv4 and IPv6 addresses, secp256k1 public keys, etc.</p> <p>Comparing ENRs and multiaddrs is like comparing apples and oranges. ENRs are self-certified containers of identity, addresses, and metadata about a node. Multiaddrs are address strings with the peculiarity that they\u2019re self-describing, composable and future-proof. An ENR can contain multiaddrs, and multiaddrs can be derived securely from the fields of an authenticated ENR.</p> <p>discv5 uses ENRs and we will presumably need to:</p> <ol> <li>Add <code>multiaddr</code> to the dictionary, so that nodes can advertise their multiaddr under a reserved namespace in ENRs. \u2013 and/or \u2013</li> <li>Define a bi-directional conversion function between multiaddrs and the corresponding denormalized fields in an ENR   (ip, ip6, tcp, tcp6, etc.), for compatibility with nodes that do not support multiaddr natively (e.g. Ethereum execution-layer nodes).</li> </ol>"},{"location":"specs/phase0/p2p-interface/#why-do-we-not-form-enrs-and-find-peers-until-genesis-blockstate-is-known","title":"Why do we not form ENRs and find peers until genesis block/state is known?","text":"<p>Although client software might very well be running locally prior to the solidification of the beacon chain genesis state and block, clients cannot form valid ENRs prior to this point. ENRs contain <code>fork_digest</code> which utilizes the <code>genesis_validators_root</code> for a cleaner separation between chains so prior to knowing genesis, we cannot use <code>fork_digest</code> to cleanly find peers on our intended chain. Once genesis data is known, we can then form ENRs and safely find peers.</p> <p>When using a proof-of-work deposit contract for deposits, <code>fork_digest</code> will be known <code>GENESIS_DELAY</code> (7 days in mainnet configuration) before <code>genesis_time</code>, providing ample time to find peers and form initial connections and gossip subnets prior to genesis.</p>"},{"location":"specs/phase0/p2p-interface/#compressionencoding","title":"Compression/Encoding","text":""},{"location":"specs/phase0/p2p-interface/#why-are-we-using-ssz-for-encoding","title":"Why are we using SSZ for encoding?","text":"<p>SSZ is used at the consensus layer, and all implementations should have support for SSZ-encoding/decoding, requiring no further dependencies to be added to client implementations. This is a natural choice for serializing objects to be sent across the wire. The actual data in most protocols will be further compressed for efficiency.</p> <p>SSZ has well-defined schemas for consensus objects (typically sent across the wire) reducing any serialization schema data that needs to be sent. It also has defined all required types that are required for this network specification.</p>"},{"location":"specs/phase0/p2p-interface/#why-are-we-compressing-and-at-which-layers","title":"Why are we compressing, and at which layers?","text":"<p>We compress on the wire to achieve smaller payloads per-message, which, in aggregate, result in higher efficiency, better utilization of available bandwidth, and overall reduction in network-wide traffic overhead.</p> <p>At this time, libp2p does not have an out-of-the-box compression feature that can be dynamically negotiated and layered atop connections and streams, but it is being considered.</p> <p>This is a non-trivial feature because the behavior of network IO loops, kernel buffers, chunking, and packet fragmentation, amongst others, need to be taken into account. libp2p streams are unbounded streams, whereas compression algorithms work best on bounded byte streams of which we have some prior knowledge.</p> <p>Compression tends not to be a one-size-fits-all problem. A lot of variables need careful evaluation, and generic approaches/choices lead to poor size shavings, which may even be counterproductive when factoring in the CPU and memory tradeoff.</p> <p>For all these reasons, generically negotiating compression algorithms may be treated as a research problem at the libp2p community, one we\u2019re happy to tackle in the medium-term.</p> <p>At this stage, the wisest choice is to consider libp2p a messenger of bytes, and to make application layer participate in compressing those bytes. This looks different depending on the interaction layer:</p> <ul> <li>Gossip domain: since gossipsub has a framing protocol and exposes an API, we compress the payload   (when dictated by the encoding token in the topic name) prior to publishing the message via the API.   No length-prefixing is necessary because protobuf takes care of bounding the field in the serialized form.</li> <li>Req/Resp domain: since we define custom protocols that operate on byte streams,   implementers are encouraged to encapsulate the encoding and compression logic behind   MessageReader and MessageWriter components/strategies that can be layered on top of the raw byte streams.</li> </ul>"},{"location":"specs/phase0/p2p-interface/#why-are-we-using-snappy-for-compression","title":"Why are we using Snappy for compression?","text":"<p>Snappy is used in Ethereum 1.0. It is well maintained by Google, has good benchmarks, and can calculate the size of the uncompressed object without inflating it in memory. This prevents DOS vectors where large uncompressed data is sent.</p>"},{"location":"specs/phase0/p2p-interface/#can-i-get-access-to-unencrypted-bytes-on-the-wire-for-debugging-purposes","title":"Can I get access to unencrypted bytes on the wire for debugging purposes?","text":"<p>Yes, you can add loggers in your libp2p protocol handlers to log incoming and outgoing messages. It is recommended to use programming design patterns to encapsulate the logging logic cleanly.</p> <p>If your libp2p library relies on frameworks/runtimes such as Netty (jvm) or Node.js (javascript), you can use logging facilities in those frameworks/runtimes to enable message tracing.</p> <p>For specific ad-hoc testing scenarios, you can use the plaintext/2.0.0 secure channel (which is essentially no-op encryption or message authentication), in combination with tcpdump or Wireshark to inspect the wire.</p>"},{"location":"specs/phase0/p2p-interface/#what-are-ssz-type-size-bounds","title":"What are SSZ type size bounds?","text":"<p>The SSZ encoding outputs of each type have size bounds: each dynamic type, such as a list, has a \"limit\", which can be used to compute the maximum valid output size. Note that for some more complex dynamic-length objects, element offsets (4 bytes each) may need to be included. Other types are static, they have a fixed size: no dynamic-length content is involved, and the minimum and maximum bounds are the same.</p> <p>For reference, the type bounds can be computed ahead of time, as per this example. It is advisable to derive these lengths from the SSZ type definitions in use, to ensure that version changes do not cause out-of-sync type bounds.</p>"},{"location":"specs/phase0/p2p-interface/#libp2p-implementations-matrix","title":"libp2p implementations matrix","text":"<p>This section will soon contain a matrix showing the maturity/state of the libp2p features required by this spec across the languages in which clients are being developed.</p>"},{"location":"specs/phase0/validator/","title":"Phase 0 -- Honest Validator","text":"<p>This is an accompanying document to Phase 0 -- The Beacon Chain, which describes the expected actions of a \"validator\" participating in the Ethereum proof-of-stake protocol.</p>"},{"location":"specs/phase0/validator/#table-of-contents","title":"Table of contents","text":"<ul> <li>Introduction</li> <li>Prerequisites</li> <li>Constants</li> <li>Misc</li> <li>Containers</li> <li><code>Eth1Block</code></li> <li><code>AggregateAndProof</code></li> <li><code>SignedAggregateAndProof</code></li> <li>Becoming a validator</li> <li>Initialization<ul> <li>BLS public key</li> <li>Withdrawal credentials</li> <li><code>BLS_WITHDRAWAL_PREFIX</code></li> <li><code>ETH1_ADDRESS_WITHDRAWAL_PREFIX</code></li> </ul> </li> <li>Submit deposit</li> <li>Process deposit</li> <li>Validator index</li> <li>Activation</li> <li>Validator assignments</li> <li>Lookahead</li> <li>Beacon chain responsibilities</li> <li>Block proposal<ul> <li>Preparing for a <code>BeaconBlock</code></li> <li>Slot</li> <li>Proposer index</li> <li>Parent root</li> <li>Constructing the <code>BeaconBlockBody</code></li> <li>Randao reveal</li> <li>Eth1 Data<ul> <li><code>get_eth1_data</code></li> </ul> </li> <li>Proposer slashings</li> <li>Attester slashings</li> <li>Attestations</li> <li>Deposits</li> <li>Voluntary exits</li> <li>Packaging into a <code>SignedBeaconBlock</code></li> <li>State root</li> <li>Signature</li> </ul> </li> <li>Attesting<ul> <li>Attestation data</li> <li>General</li> <li>LMD GHOST vote</li> <li>FFG vote</li> <li>Construct attestation</li> <li>Data</li> <li>Aggregation bits</li> <li>Aggregate signature</li> <li>Broadcast attestation</li> </ul> </li> <li>Attestation aggregation<ul> <li>Aggregation selection</li> <li>Construct aggregate</li> <li>Data</li> <li>Aggregation bits</li> <li>Aggregate signature</li> <li>Broadcast aggregate</li> </ul> </li> <li>How to avoid slashing</li> <li>Proposer slashing</li> <li>Attester slashing</li> <li>Protection best practices</li> </ul>"},{"location":"specs/phase0/validator/#introduction","title":"Introduction","text":"<p>This document represents the expected behavior of an \"honest validator\" with respect to Phase 0 of the Ethereum proof-of-stake protocol. This document does not distinguish between a \"node\" (i.e. the functionality of following and reading the beacon chain) and a \"validator client\" (i.e. the functionality of actively participating in consensus). The separation of concerns between these (potentially) two pieces of software is left as a design decision that is out of scope.</p> <p>A validator is an entity that participates in the consensus of the Ethereum proof-of-stake protocol. This is an optional role for users in which they can post ETH as collateral and verify and attest to the validity of blocks to seek financial returns in exchange for building and securing the protocol. This is similar to proof-of-work networks in which miners provide collateral in the form of hardware/hash-power to seek returns in exchange for building and securing the protocol.</p>"},{"location":"specs/phase0/validator/#prerequisites","title":"Prerequisites","text":"<p>All terminology, constants, functions, and protocol mechanics defined in the Phase 0 -- The Beacon Chain and Phase 0 -- Deposit Contract doc are requisite for this document and used throughout. Please see the Phase 0 doc before continuing and use as a reference throughout.</p>"},{"location":"specs/phase0/validator/#constants","title":"Constants","text":""},{"location":"specs/phase0/validator/#misc","title":"Misc","text":"Name Value Unit Duration <code>TARGET_AGGREGATORS_PER_COMMITTEE</code> <code>2**4</code> (= 16) validators"},{"location":"specs/phase0/validator/#containers","title":"Containers","text":""},{"location":"specs/phase0/validator/#eth1block","title":"<code>Eth1Block</code>","text":"<pre><code>class Eth1Block(Container):\ntimestamp: uint64\ndeposit_root: Root\ndeposit_count: uint64\n# All other eth1 block fields\n</code></pre>"},{"location":"specs/phase0/validator/#aggregateandproof","title":"<code>AggregateAndProof</code>","text":"<pre><code>class AggregateAndProof(Container):\naggregator_index: ValidatorIndex\naggregate: Attestation\nselection_proof: BLSSignature\n</code></pre>"},{"location":"specs/phase0/validator/#signedaggregateandproof","title":"<code>SignedAggregateAndProof</code>","text":"<pre><code>class SignedAggregateAndProof(Container):\nmessage: AggregateAndProof\nsignature: BLSSignature\n</code></pre>"},{"location":"specs/phase0/validator/#becoming-a-validator","title":"Becoming a validator","text":""},{"location":"specs/phase0/validator/#initialization","title":"Initialization","text":"<p>A validator must initialize many parameters locally before submitting a deposit and joining the validator registry.</p>"},{"location":"specs/phase0/validator/#bls-public-key","title":"BLS public key","text":"<p>Validator public keys are G1 points on the BLS12-381 curve. A private key, <code>privkey</code>, must be securely generated along with the resultant <code>pubkey</code>. This <code>privkey</code> must be \"hot\", that is, constantly available to sign data throughout the lifetime of the validator.</p>"},{"location":"specs/phase0/validator/#withdrawal-credentials","title":"Withdrawal credentials","text":"<p>The <code>withdrawal_credentials</code> field constrains validator withdrawals. The first byte of this 32-byte field is a withdrawal prefix which defines the semantics of the remaining 31 bytes.</p> <p>The following withdrawal prefixes are currently supported.</p>"},{"location":"specs/phase0/validator/#bls_withdrawal_prefix","title":"<code>BLS_WITHDRAWAL_PREFIX</code>","text":"<p>Withdrawal credentials with the BLS withdrawal prefix allow a BLS key pair <code>(bls_withdrawal_privkey, bls_withdrawal_pubkey)</code> to trigger withdrawals. The <code>withdrawal_credentials</code> field must be such that:</p> <ul> <li><code>withdrawal_credentials[:1] == BLS_WITHDRAWAL_PREFIX</code></li> <li><code>withdrawal_credentials[1:] == hash(bls_withdrawal_pubkey)[1:]</code></li> </ul> <p>Note: The <code>bls_withdrawal_privkey</code> is not required for validating and can be kept in cold storage.</p>"},{"location":"specs/phase0/validator/#eth1_address_withdrawal_prefix","title":"<code>ETH1_ADDRESS_WITHDRAWAL_PREFIX</code>","text":"<p>Withdrawal credentials with the Eth1 address withdrawal prefix specify a 20-byte Eth1 address <code>eth1_withdrawal_address</code> as the recipient for all withdrawals. The <code>eth1_withdrawal_address</code> can be the address of either an externally owned account or of a contract.</p> <p>The <code>withdrawal_credentials</code> field must be such that:</p> <ul> <li><code>withdrawal_credentials[:1] == ETH1_ADDRESS_WITHDRAWAL_PREFIX</code></li> <li><code>withdrawal_credentials[1:12] == b'\\x00' * 11</code></li> <li><code>withdrawal_credentials[12:] == eth1_withdrawal_address</code></li> </ul> <p>After the merge of the current Ethereum execution layer into the Beacon Chain, withdrawals to <code>eth1_withdrawal_address</code> will simply be increases to the account's ETH balance that do NOT trigger any EVM execution.</p>"},{"location":"specs/phase0/validator/#submit-deposit","title":"Submit deposit","text":"<p>In Phase 0, all incoming validator deposits originate from the Ethereum proof-of-work chain defined by <code>DEPOSIT_CHAIN_ID</code> and <code>DEPOSIT_NETWORK_ID</code>. Deposits are made to the deposit contract located at <code>DEPOSIT_CONTRACT_ADDRESS</code>.</p> <p>To submit a deposit:</p> <ul> <li>Pack the validator's initialization parameters into <code>deposit_data</code>, a <code>DepositData</code> SSZ object.</li> <li>Let <code>amount</code> be the amount in Gwei to be deposited by the validator where <code>amount &gt;= MIN_DEPOSIT_AMOUNT</code>.</li> <li>Set <code>deposit_data.pubkey</code> to validator's <code>pubkey</code>.</li> <li>Set <code>deposit_data.withdrawal_credentials</code> to <code>withdrawal_credentials</code>.</li> <li>Set <code>deposit_data.amount</code> to <code>amount</code>.</li> <li>Let <code>deposit_message</code> be a <code>DepositMessage</code> with all the <code>DepositData</code> contents except the <code>signature</code>.</li> <li>Let <code>signature</code> be the result of <code>bls.Sign</code> of the <code>compute_signing_root(deposit_message, domain)</code> with <code>domain=compute_domain(DOMAIN_DEPOSIT)</code>. (Warning: Deposits must be signed with <code>GENESIS_FORK_VERSION</code>, calling <code>compute_domain</code> without a second argument defaults to the correct version).</li> <li>Let <code>deposit_data_root</code> be <code>hash_tree_root(deposit_data)</code>.</li> <li>Send a transaction on the Ethereum proof-of-work chain to <code>DEPOSIT_CONTRACT_ADDRESS</code> executing <code>def deposit(pubkey: bytes[48], withdrawal_credentials: bytes[32], signature: bytes[96], deposit_data_root: bytes32)</code> along with a deposit of <code>amount</code> Gwei.</li> </ul> <p>Note: Deposits made for the same <code>pubkey</code> are treated as for the same validator. A singular <code>Validator</code> will be added to <code>state.validators</code> with each additional deposit amount added to the validator's balance. A validator can only be activated when total deposits for the validator pubkey meet or exceed <code>MAX_EFFECTIVE_BALANCE</code>.</p>"},{"location":"specs/phase0/validator/#process-deposit","title":"Process deposit","text":"<p>Deposits cannot be processed into the beacon chain until the proof-of-work block in which they were deposited or any of its descendants is added to the beacon chain <code>state.eth1_data</code>. This takes a minimum of <code>ETH1_FOLLOW_DISTANCE</code> Eth1 blocks (~8 hours) plus <code>EPOCHS_PER_ETH1_VOTING_PERIOD</code> epochs (~6.8 hours). Once the requisite proof-of-work block data is added, the deposit will normally be added to a beacon chain block and processed into the <code>state.validators</code> within an epoch or two. The validator is then in a queue to be activated.</p>"},{"location":"specs/phase0/validator/#validator-index","title":"Validator index","text":"<p>Once a validator has been processed and added to the beacon state's <code>validators</code>, the validator's <code>validator_index</code> is defined by the index into the registry at which the <code>ValidatorRecord</code> contains the <code>pubkey</code> specified in the validator's deposit. A validator's <code>validator_index</code> is guaranteed to not change from the time of initial deposit until the validator exits and fully withdraws. This <code>validator_index</code> is used throughout the specification to dictate validator roles and responsibilities at any point and should be stored locally.</p>"},{"location":"specs/phase0/validator/#activation","title":"Activation","text":"<p>In normal operation, the validator is quickly activated, at which point the validator is added to the shuffling and begins validation after an additional <code>MAX_SEED_LOOKAHEAD</code> epochs (25.6 minutes).</p> <p>The function <code>is_active_validator</code> can be used to check if a validator is active during a given epoch. Usage is as follows:</p> <pre><code>def check_if_validator_active(state: BeaconState, validator_index: ValidatorIndex) -&gt; bool:\nvalidator = state.validators[validator_index]\nreturn is_active_validator(validator, get_current_epoch(state))\n</code></pre> <p>Once a validator is activated, the validator is assigned responsibilities until exited.</p> <p>Note: There is a maximum validator churn per finalized epoch, so the delay until activation is variable depending upon finality, total active validator balance, and the number of validators in the queue to be activated.</p>"},{"location":"specs/phase0/validator/#validator-assignments","title":"Validator assignments","text":"<p>A validator can get committee assignments for a given epoch using the following helper via <code>get_committee_assignment(state, epoch, validator_index)</code> where <code>epoch &lt;= next_epoch</code>.</p> <pre><code>def get_committee_assignment(state: BeaconState,\nepoch: Epoch,\nvalidator_index: ValidatorIndex\n) -&gt; Optional[Tuple[Sequence[ValidatorIndex], CommitteeIndex, Slot]]:\n\"\"\"\n    Return the committee assignment in the ``epoch`` for ``validator_index``.\n    ``assignment`` returned is a tuple of the following form:\n        * ``assignment[0]`` is the list of validators in the committee\n        * ``assignment[1]`` is the index to which the committee is assigned\n        * ``assignment[2]`` is the slot at which the committee is assigned\n    Return None if no assignment.\n    \"\"\"\nnext_epoch = Epoch(get_current_epoch(state) + 1)\nassert epoch &lt;= next_epoch\nstart_slot = compute_start_slot_at_epoch(epoch)\ncommittee_count_per_slot = get_committee_count_per_slot(state, epoch)\nfor slot in range(start_slot, start_slot + SLOTS_PER_EPOCH):\nfor index in range(committee_count_per_slot):\ncommittee = get_beacon_committee(state, Slot(slot), CommitteeIndex(index))\nif validator_index in committee:\nreturn committee, CommitteeIndex(index), Slot(slot)\nreturn None\n</code></pre> <p>A validator can use the following function to see if they are supposed to propose during a slot. This function can only be run with a <code>state</code> of the slot in question. Proposer selection is only stable within the context of the current epoch.</p> <pre><code>def is_proposer(state: BeaconState, validator_index: ValidatorIndex) -&gt; bool:\nreturn get_beacon_proposer_index(state) == validator_index\n</code></pre> <p>Note: To see if a validator is assigned to propose during the slot, the beacon state must be in the epoch in question. At the epoch boundaries, the validator must run an epoch transition into the epoch to successfully check the proposal assignment of the first slot.</p> <p>Note: <code>BeaconBlock</code> proposal is distinct from beacon committee assignment, and in a given epoch each responsibility might occur at a different slot.</p>"},{"location":"specs/phase0/validator/#lookahead","title":"Lookahead","text":"<p>The beacon chain shufflings are designed to provide a minimum of 1 epoch lookahead on the validator's upcoming committee assignments for attesting dictated by the shuffling and slot. Note that this lookahead does not apply to proposing, which must be checked during the epoch in question.</p> <p><code>get_committee_assignment</code> should be called at the start of each epoch to get the assignment for the next epoch (<code>current_epoch + 1</code>). A validator should plan for future assignments by noting their assigned attestation slot and joining the committee index attestation subnet related to their committee assignment.</p> <p>Specifically a validator should: * Call <code>_, committee_index, _ = get_committee_assignment(state, next_epoch, validator_index)</code> when checking for next epoch assignments. * Calculate the committees per slot for the next epoch: <code>committees_per_slot = get_committee_count_per_slot(state, next_epoch)</code> * Calculate the subnet index: <code>subnet_id = compute_subnet_for_attestation(committees_per_slot, slot, committee_index)</code> * Find peers of the pubsub topic <code>beacon_attestation_{subnet_id}</code>.     * If an insufficient number of current peers are subscribed to the topic, the validator must discover new peers on this topic. Via the discovery protocol, find peers with an ENR containing the <code>attnets</code> entry such that <code>ENR[\"attnets\"][subnet_id] == True</code>. Then validate that the peers are still persisted on the desired topic by requesting <code>GetMetaData</code> and checking the resulting <code>attnets</code> field.     * If the validator is assigned to be an aggregator for the slot (see <code>is_aggregator()</code>), then subscribe to the topic.</p> <p>Note: If the validator is not assigned to be an aggregator, the validator only needs sufficient number of peers on the topic to be able to publish messages. The validator does not need to subscribe and listen to all messages on the topic.</p>"},{"location":"specs/phase0/validator/#beacon-chain-responsibilities","title":"Beacon chain responsibilities","text":"<p>A validator has two primary responsibilities to the beacon chain: proposing blocks and creating attestations. Proposals happen infrequently, whereas attestations should be created once per epoch.</p>"},{"location":"specs/phase0/validator/#block-proposal","title":"Block proposal","text":"<p>A validator is expected to propose a <code>SignedBeaconBlock</code> at the beginning of any <code>slot</code> during which <code>is_proposer(state, validator_index)</code> returns <code>True</code>.</p> <p>To propose, the validator selects a <code>BeaconBlock</code>, <code>parent</code> using this process:</p> <ol> <li>Compute fork choice's view of the head at the start of <code>slot</code>, after running    <code>on_tick</code> and applying any queued attestations from <code>slot - 1</code>.    Set <code>head_root = get_head(store)</code>.</li> <li>Compute the proposer head, which is the head upon which the proposer SHOULD build in order to    incentivise timely block propagation by other validators.    Set <code>parent_root = get_proposer_head(store, head_root, slot)</code>.    A proposer may set <code>parent_root == head_root</code> if proposer re-orgs are not implemented or have    been disabled.</li> <li>Let <code>parent</code> be the block with <code>parent_root</code>.</li> </ol> <p>The validator creates, signs, and broadcasts a <code>block</code> that is a child of <code>parent</code> and satisfies a valid beacon chain state transition. Note that the parent's slot must be strictly less than the slot of the block about to be proposed, i.e. <code>parent.slot &lt; slot</code>.</p> <p>There is one proposer per slot, so if there are N active validators any individual validator will on average be assigned to propose once per N slots (e.g. at 312,500 validators = 10 million ETH, that's once per ~6 weeks).</p> <p>Note: In this section, <code>state</code> is the state of the slot for the block proposal without the block yet applied. That is, <code>state</code> is the <code>previous_state</code> processed through any empty slots up to the assigned slot using <code>process_slots(previous_state, slot)</code>.</p>"},{"location":"specs/phase0/validator/#preparing-for-a-beaconblock","title":"Preparing for a <code>BeaconBlock</code>","text":"<p>To construct a <code>BeaconBlockBody</code>, a <code>block</code> (<code>BeaconBlock</code>) is defined with the necessary context for a block proposal:</p>"},{"location":"specs/phase0/validator/#slot","title":"Slot","text":"<p>Set <code>block.slot = slot</code> where <code>slot</code> is the current slot at which the validator has been selected to propose. The <code>parent</code> selected must satisfy that <code>parent.slot &lt; block.slot</code>.</p> <p>Note: There might be \"skipped\" slots between the <code>parent</code> and <code>block</code>. These skipped slots are processed in the state transition function without per-block processing.</p>"},{"location":"specs/phase0/validator/#proposer-index","title":"Proposer index","text":"<p>Set <code>block.proposer_index = validator_index</code> where <code>validator_index</code> is the validator chosen to propose at this slot. The private key mapping to <code>state.validators[validator_index].pubkey</code> is used to sign the block.</p>"},{"location":"specs/phase0/validator/#parent-root","title":"Parent root","text":"<p>Set <code>block.parent_root = hash_tree_root(parent)</code>.</p>"},{"location":"specs/phase0/validator/#constructing-the-beaconblockbody","title":"Constructing the <code>BeaconBlockBody</code>","text":""},{"location":"specs/phase0/validator/#randao-reveal","title":"Randao reveal","text":"<p>Set <code>block.body.randao_reveal = epoch_signature</code> where <code>epoch_signature</code> is obtained from:</p> <pre><code>def get_epoch_signature(state: BeaconState, block: BeaconBlock, privkey: int) -&gt; BLSSignature:\ndomain = get_domain(state, DOMAIN_RANDAO, compute_epoch_at_slot(block.slot))\nsigning_root = compute_signing_root(compute_epoch_at_slot(block.slot), domain)\nreturn bls.Sign(privkey, signing_root)\n</code></pre>"},{"location":"specs/phase0/validator/#eth1-data","title":"Eth1 Data","text":"<p>The <code>block.body.eth1_data</code> field is for block proposers to vote on recent Eth1 data. This recent data contains an Eth1 block hash as well as the associated deposit root (as calculated by the <code>get_deposit_root()</code> method of the deposit contract) and deposit count after execution of the corresponding Eth1 block. If over half of the block proposers in the current Eth1 voting period vote for the same <code>eth1_data</code> then <code>state.eth1_data</code> updates immediately allowing new deposits to be processed. Each deposit in <code>block.body.deposits</code> must verify against <code>state.eth1_data.eth1_deposit_root</code>.</p>"},{"location":"specs/phase0/validator/#get_eth1_data","title":"<code>get_eth1_data</code>","text":"<p>Let <code>Eth1Block</code> be an abstract object representing Eth1 blocks with the <code>timestamp</code> and deposit contract data available.</p> <p>Let <code>get_eth1_data(block: Eth1Block) -&gt; Eth1Data</code> be the function that returns the Eth1 data for a given Eth1 block.</p> <p>An honest block proposer sets <code>block.body.eth1_data = get_eth1_vote(state, eth1_chain)</code> where:</p> <pre><code>def compute_time_at_slot(state: BeaconState, slot: Slot) -&gt; uint64:\nreturn uint64(state.genesis_time + slot * SECONDS_PER_SLOT)\n</code></pre> <pre><code>def voting_period_start_time(state: BeaconState) -&gt; uint64:\neth1_voting_period_start_slot = Slot(state.slot - state.slot % (EPOCHS_PER_ETH1_VOTING_PERIOD * SLOTS_PER_EPOCH))\nreturn compute_time_at_slot(state, eth1_voting_period_start_slot)\n</code></pre> <pre><code>def is_candidate_block(block: Eth1Block, period_start: uint64) -&gt; bool:\nreturn (\nblock.timestamp + SECONDS_PER_ETH1_BLOCK * ETH1_FOLLOW_DISTANCE &lt;= period_start\nand block.timestamp + SECONDS_PER_ETH1_BLOCK * ETH1_FOLLOW_DISTANCE * 2 &gt;= period_start\n)\n</code></pre> <pre><code>def get_eth1_vote(state: BeaconState, eth1_chain: Sequence[Eth1Block]) -&gt; Eth1Data:\nperiod_start = voting_period_start_time(state)\n# `eth1_chain` abstractly represents all blocks in the eth1 chain sorted by ascending block height\nvotes_to_consider = [\nget_eth1_data(block) for block in eth1_chain\nif (\nis_candidate_block(block, period_start)\n# Ensure cannot move back to earlier deposit contract states\nand get_eth1_data(block).deposit_count &gt;= state.eth1_data.deposit_count\n)\n]\n# Valid votes already cast during this period\nvalid_votes = [vote for vote in state.eth1_data_votes if vote in votes_to_consider]\n# Default vote on latest eth1 block data in the period range unless eth1 chain is not live\n# Non-substantive casting for linter\nstate_eth1_data: Eth1Data = state.eth1_data\ndefault_vote = votes_to_consider[len(votes_to_consider) - 1] if any(votes_to_consider) else state_eth1_data\nreturn max(\nvalid_votes,\nkey=lambda v: (valid_votes.count(v), -valid_votes.index(v)),  # Tiebreak by smallest distance\ndefault=default_vote\n)\n</code></pre>"},{"location":"specs/phase0/validator/#proposer-slashings","title":"Proposer slashings","text":"<p>Up to <code>MAX_PROPOSER_SLASHINGS</code>, <code>ProposerSlashing</code> objects can be included in the <code>block</code>. The proposer slashings must satisfy the verification conditions found in proposer slashings processing. The validator receives a small \"whistleblower\" reward for each proposer slashing found and included.</p>"},{"location":"specs/phase0/validator/#attester-slashings","title":"Attester slashings","text":"<p>Up to <code>MAX_ATTESTER_SLASHINGS</code>, <code>AttesterSlashing</code> objects can be included in the <code>block</code>. The attester slashings must satisfy the verification conditions found in attester slashings processing. The validator receives a small \"whistleblower\" reward for each attester slashing found and included.</p>"},{"location":"specs/phase0/validator/#attestations","title":"Attestations","text":"<p>Up to <code>MAX_ATTESTATIONS</code>, aggregate attestations can be included in the <code>block</code>. The attestations added must satisfy the verification conditions found in attestation processing. To maximize profit, the validator should attempt to gather aggregate attestations that include singular attestations from the largest number of validators whose signatures from the same epoch have not previously been added on chain.</p>"},{"location":"specs/phase0/validator/#deposits","title":"Deposits","text":"<p>If there are any unprocessed deposits for the existing <code>state.eth1_data</code> (i.e. <code>state.eth1_data.deposit_count &gt; state.eth1_deposit_index</code>), then pending deposits must be added to the block. The expected number of deposits is exactly <code>min(MAX_DEPOSITS, eth1_data.deposit_count - state.eth1_deposit_index)</code>.  These <code>deposits</code> are constructed from the <code>Deposit</code> logs from the deposit contract and must be processed in sequential order. The deposits included in the <code>block</code> must satisfy the verification conditions found in deposits processing.</p> <p>The <code>proof</code> for each deposit must be constructed against the deposit root contained in <code>state.eth1_data</code> rather than the deposit root at the time the deposit was initially logged from the proof-of-work chain. This entails storing a full deposit merkle tree locally and computing updated proofs against the <code>eth1_data.deposit_root</code> as needed. See <code>minimal_merkle.py</code> for a sample implementation.</p>"},{"location":"specs/phase0/validator/#voluntary-exits","title":"Voluntary exits","text":"<p>Up to <code>MAX_VOLUNTARY_EXITS</code>, <code>VoluntaryExit</code> objects can be included in the <code>block</code>. The exits must satisfy the verification conditions found in exits processing.</p> <p>Note: If a slashing for a validator is included in the same block as a voluntary exit, the voluntary exit will fail and cause the block to be invalid due to the slashing being processed first. Implementers must take heed of this operation interaction when packing blocks.</p>"},{"location":"specs/phase0/validator/#packaging-into-a-signedbeaconblock","title":"Packaging into a <code>SignedBeaconBlock</code>","text":""},{"location":"specs/phase0/validator/#state-root","title":"State root","text":"<p>Set <code>block.state_root = hash_tree_root(state)</code> of the resulting <code>state</code> of the <code>parent -&gt; block</code> state transition.</p> <p>Note: To calculate <code>state_root</code>, the validator should first run the state transition function on an unsigned <code>block</code> containing a stub for the <code>state_root</code>. It is useful to be able to run a state transition function (working on a copy of the state) that does not validate signatures or state root for this purpose:</p> <pre><code>def compute_new_state_root(state: BeaconState, block: BeaconBlock) -&gt; Root:\ntemp_state: BeaconState = state.copy()\nsigned_block = SignedBeaconBlock(message=block)\nstate_transition(temp_state, signed_block, validate_result=False)\nreturn hash_tree_root(temp_state)\n</code></pre>"},{"location":"specs/phase0/validator/#signature","title":"Signature","text":"<p><code>signed_block = SignedBeaconBlock(message=block, signature=block_signature)</code>, where <code>block_signature</code> is obtained from:</p> <pre><code>def get_block_signature(state: BeaconState, block: BeaconBlock, privkey: int) -&gt; BLSSignature:\ndomain = get_domain(state, DOMAIN_BEACON_PROPOSER, compute_epoch_at_slot(block.slot))\nsigning_root = compute_signing_root(block, domain)\nreturn bls.Sign(privkey, signing_root)\n</code></pre>"},{"location":"specs/phase0/validator/#attesting","title":"Attesting","text":"<p>A validator is expected to create, sign, and broadcast an attestation during each epoch. The <code>committee</code>, assigned <code>index</code>, and assigned <code>slot</code> for which the validator performs this role during an epoch are defined by <code>get_committee_assignment(state, epoch, validator_index)</code>.</p> <p>A validator should create and broadcast the <code>attestation</code> to the associated attestation subnet when either (a) the validator has received a valid block from the expected block proposer for the assigned <code>slot</code> or (b) <code>1 / INTERVALS_PER_SLOT</code> of the <code>slot</code> has transpired (<code>SECONDS_PER_SLOT / INTERVALS_PER_SLOT</code> seconds after the start of <code>slot</code>) -- whichever comes first.</p> <p>Note: Although attestations during <code>GENESIS_EPOCH</code> do not count toward FFG finality, these initial attestations do give weight to the fork choice, are rewarded, and should be made.</p>"},{"location":"specs/phase0/validator/#attestation-data","title":"Attestation data","text":"<p>First, the validator should construct <code>attestation_data</code>, an <code>AttestationData</code> object based upon the state at the assigned slot.</p> <ul> <li>Let <code>head_block</code> be the result of running the fork choice during the assigned slot.</li> <li>Let <code>head_state</code> be the state of <code>head_block</code> processed through any empty slots up to the assigned slot using <code>process_slots(state, slot)</code>.</li> </ul>"},{"location":"specs/phase0/validator/#general","title":"General","text":"<ul> <li>Set <code>attestation_data.slot = slot</code> where <code>slot</code> is the assigned slot.</li> <li>Set <code>attestation_data.index = index</code> where <code>index</code> is the index associated with the validator's committee.</li> </ul>"},{"location":"specs/phase0/validator/#lmd-ghost-vote","title":"LMD GHOST vote","text":"<p>Set <code>attestation_data.beacon_block_root = hash_tree_root(head_block)</code>.</p>"},{"location":"specs/phase0/validator/#ffg-vote","title":"FFG vote","text":"<ul> <li>Set <code>attestation_data.source = head_state.current_justified_checkpoint</code>.</li> <li>Set <code>attestation_data.target = Checkpoint(epoch=get_current_epoch(head_state), root=epoch_boundary_block_root)</code> where <code>epoch_boundary_block_root</code> is the root of block at the most recent epoch boundary.</li> </ul> <p>Note: <code>epoch_boundary_block_root</code> can be looked up in the state using:</p> <ul> <li>Let <code>start_slot = compute_start_slot_at_epoch(get_current_epoch(head_state))</code>.</li> <li>Let <code>epoch_boundary_block_root = hash_tree_root(head_block) if start_slot == head_state.slot else get_block_root(state, get_current_epoch(head_state))</code>.</li> </ul>"},{"location":"specs/phase0/validator/#construct-attestation","title":"Construct attestation","text":"<p>Next, the validator creates <code>attestation</code>, an <code>Attestation</code> object.</p>"},{"location":"specs/phase0/validator/#data","title":"Data","text":"<p>Set <code>attestation.data = attestation_data</code> where <code>attestation_data</code> is the <code>AttestationData</code> object defined in the previous section, attestation data.</p>"},{"location":"specs/phase0/validator/#aggregation-bits","title":"Aggregation bits","text":"<ul> <li>Let <code>attestation.aggregation_bits</code> be a <code>Bitlist[MAX_VALIDATORS_PER_COMMITTEE]</code> of length <code>len(committee)</code>, where the bit of the index of the validator in the <code>committee</code> is set to <code>0b1</code>.</li> </ul> <p>Note: Calling <code>get_attesting_indices(state, attestation)</code> should return a list of length equal to 1, containing <code>validator_index</code>.</p>"},{"location":"specs/phase0/validator/#aggregate-signature","title":"Aggregate signature","text":"<p>Set <code>attestation.signature = attestation_signature</code> where <code>attestation_signature</code> is obtained from:</p> <pre><code>def get_attestation_signature(state: BeaconState, attestation_data: AttestationData, privkey: int) -&gt; BLSSignature:\ndomain = get_domain(state, DOMAIN_BEACON_ATTESTER, attestation_data.target.epoch)\nsigning_root = compute_signing_root(attestation_data, domain)\nreturn bls.Sign(privkey, signing_root)\n</code></pre>"},{"location":"specs/phase0/validator/#broadcast-attestation","title":"Broadcast attestation","text":"<p>Finally, the validator broadcasts <code>attestation</code> to the associated attestation subnet, the <code>beacon_attestation_{subnet_id}</code> pubsub topic.</p> <p>The <code>subnet_id</code> for the <code>attestation</code> is calculated with: - Let <code>committees_per_slot = get_committee_count_per_slot(state, attestation.data.target.epoch)</code>. - Let <code>subnet_id = compute_subnet_for_attestation(committees_per_slot, attestation.data.slot, attestation.data.index)</code>.</p> <pre><code>def compute_subnet_for_attestation(committees_per_slot: uint64,\nslot: Slot,\ncommittee_index: CommitteeIndex) -&gt; SubnetID:\n\"\"\"\n    Compute the correct subnet for an attestation for Phase 0.\n    Note, this mimics expected future behavior where attestations will be mapped to their shard subnet.\n    \"\"\"\nslots_since_epoch_start = uint64(slot % SLOTS_PER_EPOCH)\ncommittees_since_epoch_start = committees_per_slot * slots_since_epoch_start\nreturn SubnetID((committees_since_epoch_start + committee_index) % ATTESTATION_SUBNET_COUNT)\n</code></pre>"},{"location":"specs/phase0/validator/#attestation-aggregation","title":"Attestation aggregation","text":"<p>Some validators are selected to locally aggregate attestations with a similar <code>attestation_data</code> to their constructed <code>attestation</code> for the assigned <code>slot</code>.</p>"},{"location":"specs/phase0/validator/#aggregation-selection","title":"Aggregation selection","text":"<p>A validator is selected to aggregate based upon the return value of <code>is_aggregator()</code>.</p> <pre><code>def get_slot_signature(state: BeaconState, slot: Slot, privkey: int) -&gt; BLSSignature:\ndomain = get_domain(state, DOMAIN_SELECTION_PROOF, compute_epoch_at_slot(slot))\nsigning_root = compute_signing_root(slot, domain)\nreturn bls.Sign(privkey, signing_root)\n</code></pre> <pre><code>def is_aggregator(state: BeaconState, slot: Slot, index: CommitteeIndex, slot_signature: BLSSignature) -&gt; bool:\ncommittee = get_beacon_committee(state, slot, index)\nmodulo = max(1, len(committee) // TARGET_AGGREGATORS_PER_COMMITTEE)\nreturn bytes_to_uint64(hash(slot_signature)[0:8]) % modulo == 0\n</code></pre>"},{"location":"specs/phase0/validator/#construct-aggregate","title":"Construct aggregate","text":"<p>If the validator is selected to aggregate (<code>is_aggregator()</code>), they construct an aggregate attestation via the following.</p> <p>Collect <code>attestations</code> seen via gossip during the <code>slot</code> that have an equivalent <code>attestation_data</code> to that constructed by the validator. If <code>len(attestations) &gt; 0</code>, create an <code>aggregate_attestation: Attestation</code> with the following fields.</p>"},{"location":"specs/phase0/validator/#data_1","title":"Data","text":"<p>Set <code>aggregate_attestation.data = attestation_data</code> where <code>attestation_data</code> is the <code>AttestationData</code> object that is the same for each individual attestation being aggregated.</p>"},{"location":"specs/phase0/validator/#aggregation-bits_1","title":"Aggregation bits","text":"<p>Let <code>aggregate_attestation.aggregation_bits</code> be a <code>Bitlist[MAX_VALIDATORS_PER_COMMITTEE]</code> of length <code>len(committee)</code>, where each bit set from each individual attestation is set to <code>0b1</code>.</p>"},{"location":"specs/phase0/validator/#aggregate-signature_1","title":"Aggregate signature","text":"<p>Set <code>aggregate_attestation.signature = aggregate_signature</code> where <code>aggregate_signature</code> is obtained from:</p> <pre><code>def get_aggregate_signature(attestations: Sequence[Attestation]) -&gt; BLSSignature:\nsignatures = [attestation.signature for attestation in attestations]\nreturn bls.Aggregate(signatures)\n</code></pre>"},{"location":"specs/phase0/validator/#broadcast-aggregate","title":"Broadcast aggregate","text":"<p>If the validator is selected to aggregate (<code>is_aggregator</code>), then they broadcast their best aggregate as a <code>SignedAggregateAndProof</code> to the global aggregate channel (<code>beacon_aggregate_and_proof</code>) <code>2 / INTERVALS_PER_SLOT</code> of the way through the <code>slot</code>-that is, <code>SECONDS_PER_SLOT * 2 / INTERVALS_PER_SLOT</code> seconds after the start of <code>slot</code>.</p> <p>Selection proofs are provided in <code>AggregateAndProof</code> to prove to the gossip channel that the validator has been selected as an aggregator.</p> <p><code>AggregateAndProof</code> messages are signed by the aggregator and broadcast inside of <code>SignedAggregateAndProof</code> objects to prevent a class of DoS attacks and message forgeries.</p> <p>First, <code>aggregate_and_proof = get_aggregate_and_proof(state, validator_index, aggregate_attestation, privkey)</code> is constructed.</p> <pre><code>def get_aggregate_and_proof(state: BeaconState,\naggregator_index: ValidatorIndex,\naggregate: Attestation,\nprivkey: int) -&gt; AggregateAndProof:\nreturn AggregateAndProof(\naggregator_index=aggregator_index,\naggregate=aggregate,\nselection_proof=get_slot_signature(state, aggregate.data.slot, privkey),\n)\n</code></pre> <p>Then <code>signed_aggregate_and_proof = SignedAggregateAndProof(message=aggregate_and_proof, signature=signature)</code> is constructed and broadcast. Where <code>signature</code> is obtained from:</p> <pre><code>def get_aggregate_and_proof_signature(state: BeaconState,\naggregate_and_proof: AggregateAndProof,\nprivkey: int) -&gt; BLSSignature:\naggregate = aggregate_and_proof.aggregate\ndomain = get_domain(state, DOMAIN_AGGREGATE_AND_PROOF, compute_epoch_at_slot(aggregate.data.slot))\nsigning_root = compute_signing_root(aggregate_and_proof, domain)\nreturn bls.Sign(privkey, signing_root)\n</code></pre>"},{"location":"specs/phase0/validator/#how-to-avoid-slashing","title":"How to avoid slashing","text":"<p>\"Slashing\" is the burning of some amount of validator funds and immediate ejection from the active validator set. In Phase 0, there are two ways in which funds can be slashed: proposer slashing and attester slashing. Although being slashed has serious repercussions, it is simple enough to avoid being slashed all together by remaining consistent with respect to the messages a validator has previously signed.</p> <p>Note: Signed data must be within a sequential <code>Fork</code> context to conflict. Messages cannot be slashed across diverging forks. If the previous fork version is 1 and the chain splits into fork 2 and 102, messages from 1 can be slashable against messages in forks 1, 2, and 102. Messages in 2 cannot be slashable against messages in 102, and vice versa.</p>"},{"location":"specs/phase0/validator/#proposer-slashing","title":"Proposer slashing","text":"<p>To avoid \"proposer slashings\", a validator must not sign two conflicting <code>BeaconBlock</code> where conflicting is defined as two distinct blocks within the same slot.</p> <p>In Phase 0, as long as the validator does not sign two different beacon blocks for the same slot, the validator is safe against proposer slashings.</p> <p>Specifically, when signing a <code>BeaconBlock</code>, a validator should perform the following steps in the following order:</p> <ol> <li>Save a record to hard disk that a beacon block has been signed for the <code>slot=block.slot</code>.</li> <li>Generate and broadcast the block.</li> </ol> <p>If the software crashes at some point within this routine, then when the validator comes back online, the hard disk has the record of the potentially signed/broadcast block and can effectively avoid slashing.</p>"},{"location":"specs/phase0/validator/#attester-slashing","title":"Attester slashing","text":"<p>To avoid \"attester slashings\", a validator must not sign two conflicting <code>AttestationData</code> objects, i.e. two attestations that satisfy <code>is_slashable_attestation_data</code>.</p> <p>Specifically, when signing an <code>Attestation</code>, a validator should perform the following steps in the following order:</p> <ol> <li>Save a record to hard disk that an attestation has been signed for source (i.e. <code>attestation_data.source.epoch</code>) and target (i.e. <code>attestation_data.target.epoch</code>).</li> <li>Generate and broadcast attestation.</li> </ol> <p>If the software crashes at some point within this routine, then when the validator comes back online, the hard disk has the record of the potentially signed/broadcast attestation and can effectively avoid slashing.</p>"},{"location":"specs/phase0/validator/#protection-best-practices","title":"Protection best practices","text":"<p>A validator client should be considered standalone and should consider the beacon node as untrusted. This means that the validator client should protect:</p> <p>1) Private keys -- private keys should be protected from being exported accidentally or by an attacker. 2) Slashing -- before a validator client signs a message it should validate the data, check it against a local slashing database (do not sign a slashable attestation or block) and update its internal slashing database with the newly signed object. 3) Recovered validator -- Recovering a validator from a private key will result in an empty local slashing db. Best practice is to import (from a trusted source) that validator's attestation history. See EIP 3076 for a standard slashing interchange format. 4) Far future signing requests -- A validator client can be requested to sign a far into the future attestation, resulting in a valid non-slashable request. If the validator client signs this message, it will result in it blocking itself from attesting any other attestation until the beacon-chain reaches that far into the future epoch. This will result in an inactivity penalty and potential ejection due to low balance. A validator client should prevent itself from signing such requests by: a) keeping a local time clock if possible and following best practices to stop time server attacks and b) refusing to sign, by default, any message that has a large (&gt;6h) gap from the current slashing protection database indicated a time \"jump\" or a long offline event. The administrator can manually override this protection to restart the validator after a genuine long offline event.</p>"},{"location":"specs/phase0/weak-subjectivity/","title":"Phase 0 -- Weak Subjectivity Guide","text":""},{"location":"specs/phase0/weak-subjectivity/#table-of-contents","title":"Table of contents","text":"<ul> <li>Introduction</li> <li>Prerequisites</li> <li>Custom Types</li> <li>Constants</li> <li>Configuration</li> <li>Weak Subjectivity Checkpoint</li> <li>Weak Subjectivity Period</li> <li>Calculating the Weak Subjectivity Period<ul> <li><code>compute_weak_subjectivity_period</code></li> </ul> </li> <li>Weak Subjectivity Sync</li> <li>Weak Subjectivity Sync Procedure</li> <li>Checking for Stale Weak Subjectivity Checkpoint<ul> <li><code>is_within_weak_subjectivity_period</code></li> </ul> </li> <li>Distributing Weak Subjectivity Checkpoints</li> </ul>"},{"location":"specs/phase0/weak-subjectivity/#introduction","title":"Introduction","text":"<p>This document is a guide for implementing the Weak Subjectivity protections in Phase 0. This document is still a work-in-progress, and is subject to large changes. For more information about weak subjectivity and why it is required, please refer to:</p> <ul> <li>Weak Subjectivity in Ethereum Proof-of-Stake</li> <li>Proof of Stake: How I Learned to Love Weak Subjectivity</li> </ul>"},{"location":"specs/phase0/weak-subjectivity/#prerequisites","title":"Prerequisites","text":"<p>This document uses data structures, constants, functions, and terminology from Phase 0 -- The Beacon Chain and Phase 0 -- Beacon Chain Fork Choice.</p>"},{"location":"specs/phase0/weak-subjectivity/#custom-types","title":"Custom Types","text":"Name SSZ Equivalent Description <code>Ether</code> <code>uint64</code> an amount in Ether"},{"location":"specs/phase0/weak-subjectivity/#constants","title":"Constants","text":"Name Value <code>ETH_TO_GWEI</code> <code>uint64(10**9)</code>"},{"location":"specs/phase0/weak-subjectivity/#configuration","title":"Configuration","text":"Name Value <code>SAFETY_DECAY</code> <code>uint64(10)</code>"},{"location":"specs/phase0/weak-subjectivity/#weak-subjectivity-checkpoint","title":"Weak Subjectivity Checkpoint","text":"<p>Any <code>Checkpoint</code> object can be used as a Weak Subjectivity Checkpoint. These Weak Subjectivity Checkpoints are distributed by providers, downloaded by users and/or distributed as a part of clients, and used as input while syncing a client.</p>"},{"location":"specs/phase0/weak-subjectivity/#weak-subjectivity-period","title":"Weak Subjectivity Period","text":"<p>The Weak Subjectivity Period is the number of recent epochs within which there must be a Weak Subjectivity Checkpoint to ensure that an attacker who takes control of the validator set at the beginning of the period is slashed at least a minimum threshold in the event that a conflicting <code>Checkpoint</code> is finalized.</p> <p><code>SAFETY_DECAY</code> is defined as the maximum percentage tolerable loss in the one-third safety margin of FFG finality. Thus, any attack exploiting the Weak Subjectivity Period has a safety margin of at least <code>1/3 - SAFETY_DECAY/100</code>.</p>"},{"location":"specs/phase0/weak-subjectivity/#calculating-the-weak-subjectivity-period","title":"Calculating the Weak Subjectivity Period","text":"<p>A detailed analysis of the calculation of the weak subjectivity period is made in this report.</p> <p>Note: The expressions in the report use fractions, whereas the consensus-specs only use <code>uint64</code> arithmetic. The expressions have been simplified to avoid computing fractions, and more details can be found here.</p> <p>Note: The calculations here use <code>Ether</code> instead of <code>Gwei</code>, because the large magnitude of balances in <code>Gwei</code> can cause an overflow while computing using <code>uint64</code> arithmetic operations. Using <code>Ether</code> reduces the magnitude of the multiplicative factors by an order of <code>ETH_TO_GWEI</code> (<code>= 10**9</code>) and avoid the scope for overflows in <code>uint64</code>.</p>"},{"location":"specs/phase0/weak-subjectivity/#compute_weak_subjectivity_period","title":"<code>compute_weak_subjectivity_period</code>","text":"<pre><code>def compute_weak_subjectivity_period(state: BeaconState) -&gt; uint64:\n\"\"\"\n    Returns the weak subjectivity period for the current ``state``. \n    This computation takes into account the effect of:\n        - validator set churn (bounded by ``get_validator_churn_limit()`` per epoch), and \n        - validator balance top-ups (bounded by ``MAX_DEPOSITS * SLOTS_PER_EPOCH`` per epoch).\n    A detailed calculation can be found at:\n    https://github.com/runtimeverification/beacon-chain-verification/blob/master/weak-subjectivity/weak-subjectivity-analysis.pdf\n    \"\"\"\nws_period = MIN_VALIDATOR_WITHDRAWABILITY_DELAY\nN = len(get_active_validator_indices(state, get_current_epoch(state)))\nt = get_total_active_balance(state) // N // ETH_TO_GWEI\nT = MAX_EFFECTIVE_BALANCE // ETH_TO_GWEI\ndelta = get_validator_churn_limit(state)\nDelta = MAX_DEPOSITS * SLOTS_PER_EPOCH\nD = SAFETY_DECAY\nif T * (200 + 3 * D) &lt; t * (200 + 12 * D):\nepochs_for_validator_set_churn = (\nN * (t * (200 + 12 * D) - T * (200 + 3 * D)) // (600 * delta * (2 * t + T))\n)\nepochs_for_balance_top_ups = (\nN * (200 + 3 * D) // (600 * Delta)\n)\nws_period += max(epochs_for_validator_set_churn, epochs_for_balance_top_ups)\nelse:\nws_period += (\n3 * N * D * t // (200 * Delta * (T - t))\n)\nreturn ws_period\n</code></pre> <p>A brief reference for what these values look like in practice (reference script):</p> Safety Decay Avg. Val. Balance (ETH) Val. Count Weak Sub. Period (Epochs) 10 28 32768 504 10 28 65536 752 10 28 131072 1248 10 28 262144 2241 10 28 524288 2241 10 28 1048576 2241 10 32 32768 665 10 32 65536 1075 10 32 131072 1894 10 32 262144 3532 10 32 524288 3532 10 32 1048576 3532"},{"location":"specs/phase0/weak-subjectivity/#weak-subjectivity-sync","title":"Weak Subjectivity Sync","text":"<p>Clients should allow users to input a Weak Subjectivity Checkpoint at startup, and guarantee that any successful sync leads to the given Weak Subjectivity Checkpoint along the canonical chain. If such a sync is not possible, the client should treat this as a critical and irrecoverable failure.</p>"},{"location":"specs/phase0/weak-subjectivity/#weak-subjectivity-sync-procedure","title":"Weak Subjectivity Sync Procedure","text":"<ol> <li>Input a Weak Subjectivity Checkpoint as a CLI parameter in <code>block_root:epoch_number</code> format,    where <code>block_root</code> (an \"0x\" prefixed 32-byte hex string) and <code>epoch_number</code> (an integer) represent a valid <code>Checkpoint</code>.    Example of the format:</li> </ol> <pre><code>0x8584188b86a9296932785cc2827b925f9deebacce6d72ad8d53171fa046b43d9:9544\n</code></pre> <ol> <li>Check the weak subjectivity requirements:<ul> <li>IF <code>epoch_number &gt; store.finalized_checkpoint.epoch</code>,       then ASSERT during block sync that block with root <code>block_root</code> is in the sync path at epoch <code>epoch_number</code>.       Emit descriptive critical error if this assert fails, then exit client process.</li> <li>IF <code>epoch_number &lt;= store.finalized_checkpoint.epoch</code>,       then ASSERT that the block in the canonical chain at epoch <code>epoch_number</code> has root <code>block_root</code>.       Emit descriptive critical error if this assert fails, then exit client process.</li> </ul> </li> </ol>"},{"location":"specs/phase0/weak-subjectivity/#checking-for-stale-weak-subjectivity-checkpoint","title":"Checking for Stale Weak Subjectivity Checkpoint","text":"<p>Clients may choose to validate that the input Weak Subjectivity Checkpoint is not stale at the time of startup. To support this mechanism, the client needs to take the state at the Weak Subjectivity Checkpoint as a CLI parameter input (or fetch the state associated with the input Weak Subjectivity Checkpoint from some source). The check can be implemented in the following way:</p>"},{"location":"specs/phase0/weak-subjectivity/#is_within_weak_subjectivity_period","title":"<code>is_within_weak_subjectivity_period</code>","text":"<pre><code>def is_within_weak_subjectivity_period(store: Store, ws_state: BeaconState, ws_checkpoint: Checkpoint) -&gt; bool:\n# Clients may choose to validate the input state against the input Weak Subjectivity Checkpoint\nassert ws_state.latest_block_header.state_root == ws_checkpoint.root\nassert compute_epoch_at_slot(ws_state.slot) == ws_checkpoint.epoch\nws_period = compute_weak_subjectivity_period(ws_state)\nws_state_epoch = compute_epoch_at_slot(ws_state.slot)\ncurrent_epoch = compute_epoch_at_slot(get_current_slot(store))\nreturn current_epoch &lt;= ws_state_epoch + ws_period\n</code></pre>"},{"location":"specs/phase0/weak-subjectivity/#distributing-weak-subjectivity-checkpoints","title":"Distributing Weak Subjectivity Checkpoints","text":"<p>This section will be updated soon.</p>"},{"location":"ssz/merkle-proofs/","title":"Merkle proof formats","text":"<p>Notice: This document is a work-in-progress for researchers and implementers.</p>"},{"location":"ssz/merkle-proofs/#table-of-contents","title":"Table of contents","text":"<ul> <li>Helper functions</li> <li>Generalized Merkle tree index</li> <li>SSZ object to index</li> <li>Helpers for generalized indices<ul> <li><code>concat_generalized_indices</code></li> <li><code>get_generalized_index_length</code></li> <li><code>get_generalized_index_bit</code></li> <li><code>generalized_index_sibling</code></li> <li><code>generalized_index_child</code></li> <li><code>generalized_index_parent</code></li> </ul> </li> <li>Merkle multiproofs</li> </ul>"},{"location":"ssz/merkle-proofs/#helper-functions","title":"Helper functions","text":"<pre><code>def get_power_of_two_ceil(x: int) -&gt; int:\n\"\"\"\n    Get the power of 2 for given input, or the closest higher power of 2 if the input is not a power of 2.\n    Commonly used for \"how many nodes do I need for a bottom tree layer fitting x elements?\"\n    Example: 0-&gt;1, 1-&gt;1, 2-&gt;2, 3-&gt;4, 4-&gt;4, 5-&gt;8, 6-&gt;8, 7-&gt;8, 8-&gt;8, 9-&gt;16.\n    \"\"\"\nif x &lt;= 1:\nreturn 1\nelif x == 2:\nreturn 2\nelse:\nreturn 2 * get_power_of_two_ceil((x + 1) // 2)\n</code></pre> <pre><code>def get_power_of_two_floor(x: int) -&gt; int:\n\"\"\"\n    Get the power of 2 for given input, or the closest lower power of 2 if the input is not a power of 2.\n    The zero case is a placeholder and not used for math with generalized indices.\n    Commonly used for \"what power of two makes up the root bit of the generalized index?\"\n    Example: 0-&gt;1, 1-&gt;1, 2-&gt;2, 3-&gt;2, 4-&gt;4, 5-&gt;4, 6-&gt;4, 7-&gt;4, 8-&gt;8, 9-&gt;8\n    \"\"\"\nif x &lt;= 1:\nreturn 1\nif x == 2:\nreturn x\nelse:\nreturn 2 * get_power_of_two_floor(x // 2)\n</code></pre>"},{"location":"ssz/merkle-proofs/#generalized-merkle-tree-index","title":"Generalized Merkle tree index","text":"<p>In a binary Merkle tree, we define a \"generalized index\" of a node as <code>2**depth + index</code>. Visually, this looks as follows:</p> <pre><code>    1\n 2     3\n4 5   6 7\n   ...\n</code></pre> <p>Note that the generalized index has the convenient property that the two children of node <code>k</code> are <code>2k</code> and <code>2k+1</code>, and also that it equals the position of a node in the linear representation of the Merkle tree that's computed by this function:</p> <pre><code>def merkle_tree(leaves: Sequence[Bytes32]) -&gt; Sequence[Bytes32]:\n\"\"\"\n    Return an array representing the tree nodes by generalized index: \n    [0, 1, 2, 3, 4, 5, 6, 7], where each layer is a power of 2. The 0 index is ignored. The 1 index is the root.\n    The result will be twice the size as the padded bottom layer for the input leaves.\n    \"\"\"\nbottom_length = get_power_of_two_ceil(len(leaves))\no = [Bytes32()] * bottom_length + list(leaves) + [Bytes32()] * (bottom_length - len(leaves))\nfor i in range(bottom_length - 1, 0, -1):\no[i] = hash(o[i * 2] + o[i * 2 + 1])\nreturn o\n</code></pre> <p>We define a custom type <code>GeneralizedIndex</code> as a Python integer type in this document. It can be represented as a Bitvector/Bitlist object as well.</p> <p>We will define Merkle proofs in terms of generalized indices.</p>"},{"location":"ssz/merkle-proofs/#ssz-object-to-index","title":"SSZ object to index","text":"<p>We can describe the hash tree of any SSZ object, rooted in <code>hash_tree_root(object)</code>, as a binary Merkle tree whose depth may vary. For example, an object <code>{x: bytes32, y: List[uint64]}</code> would look as follows:</p> <pre><code>     root\n    /    \\\n   x    y_root\n        /    \\\ny_data_root  len(y)\n    / \\\n   /\\ /\\\n  .......\n</code></pre> <p>We can now define a concept of a \"path\", a way of describing a function that takes as input an SSZ object and outputs some specific (possibly deeply nested) member. For example, <code>foo -&gt; foo.x</code> is a path, as are <code>foo -&gt; len(foo.y)</code> and <code>foo -&gt; foo.y[5].w</code>. We'll describe paths as lists, which can have two representations. In \"human-readable form\", they are <code>[\"x\"]</code>, <code>[\"y\", \"__len__\"]</code> and <code>[\"y\", 5, \"w\"]</code> respectively. In \"encoded form\", they are lists of <code>uint64</code> values, in these cases (assuming the fields of <code>foo</code> in order are <code>x</code> then <code>y</code>, and <code>w</code> is the first field of <code>y[i]</code>) <code>[0]</code>, <code>[1, 2**64-1]</code>, <code>[1, 5, 0]</code>. We define <code>SSZVariableName</code> as the member variable name string, i.e., a path is presented as a sequence of integers and <code>SSZVariableName</code>.</p> <pre><code>def item_length(typ: SSZType) -&gt; int:\n\"\"\"\n    Return the number of bytes in a basic type, or 32 (a full hash) for compound types.\n    \"\"\"\nif issubclass(typ, BasicValue):\nreturn typ.byte_len\nelse:\nreturn 32\n</code></pre> <pre><code>def get_elem_type(typ: Union[BaseBytes, BaseList, Container],\nindex_or_variable_name: Union[int, SSZVariableName]) -&gt; SSZType:\n\"\"\"\n    Return the type of the element of an object of the given type with the given index\n    or member variable name (eg. `7` for `x[7]`, `\"foo\"` for `x.foo`)\n    \"\"\"\nreturn typ.get_fields()[index_or_variable_name] if issubclass(typ, Container) else typ.elem_type\n</code></pre> <pre><code>def chunk_count(typ: SSZType) -&gt; int:\n\"\"\"\n    Return the number of hashes needed to represent the top-level elements in the given type\n    (eg. `x.foo` or `x[7]` but not `x[7].bar` or `x.foo.baz`). In all cases except lists/vectors\n    of basic types, this is simply the number of top-level elements, as each element gets one\n    hash. For lists/vectors of basic types, it is often fewer because multiple basic elements\n    can be packed into one 32-byte chunk.\n    \"\"\"\n# typ.length describes the limit for list types, or the length for vector types.\nif issubclass(typ, BasicValue):\nreturn 1\nelif issubclass(typ, Bits):\nreturn (typ.length + 255) // 256\nelif issubclass(typ, Elements):\nreturn (typ.length * item_length(typ.elem_type) + 31) // 32\nelif issubclass(typ, Container):\nreturn len(typ.get_fields())\nelse:\nraise Exception(f\"Type not supported: {typ}\")\n</code></pre> <pre><code>def get_item_position(typ: SSZType, index_or_variable_name: Union[int, SSZVariableName]) -&gt; Tuple[int, int, int]:\n\"\"\"\n    Return three variables:\n        (i) the index of the chunk in which the given element of the item is represented;\n        (ii) the starting byte position within the chunk;\n        (iii) the ending byte position within the chunk.\n    For example: for a 6-item list of uint64 values, index=2 will return (0, 16, 24), index=5 will return (1, 8, 16)\n    \"\"\"\nif issubclass(typ, Elements):\nindex = int(index_or_variable_name)\nstart = index * item_length(typ.elem_type)\nreturn start // 32, start % 32, start % 32 + item_length(typ.elem_type)\nelif issubclass(typ, Container):\nvariable_name = index_or_variable_name\nreturn typ.get_field_names().index(variable_name), 0, item_length(get_elem_type(typ, variable_name))\nelse:\nraise Exception(\"Only lists/vectors/containers supported\")\n</code></pre> <pre><code>def get_generalized_index(typ: SSZType, *path: PyUnion[int, SSZVariableName]) -&gt; GeneralizedIndex:\n\"\"\"\n    Converts a path (eg. `[7, \"foo\", 3]` for `x[7].foo[3]`, `[12, \"bar\", \"__len__\"]` for\n    `len(x[12].bar)`) into the generalized index representing its position in the Merkle tree.\n    \"\"\"\nroot = GeneralizedIndex(1)\nfor p in path:\nassert not issubclass(typ, BasicValue)  # If we descend to a basic type, the path cannot continue further\nif p == '__len__':\ntyp = uint64\nassert issubclass(typ, (List, ByteList))\nroot = GeneralizedIndex(root * 2 + 1)\nelse:\npos, _, _ = get_item_position(typ, p)\nbase_index = (GeneralizedIndex(2) if issubclass(typ, (List, ByteList)) else GeneralizedIndex(1))\nroot = GeneralizedIndex(root * base_index * get_power_of_two_ceil(chunk_count(typ)) + pos)\ntyp = get_elem_type(typ, p)\nreturn root\n</code></pre>"},{"location":"ssz/merkle-proofs/#helpers-for-generalized-indices","title":"Helpers for generalized indices","text":"<p>Usage note: functions outside this section should manipulate generalized indices using only functions inside this section. This is to make it easier for developers to implement generalized indices with underlying representations other than bigints.</p>"},{"location":"ssz/merkle-proofs/#concat_generalized_indices","title":"<code>concat_generalized_indices</code>","text":"<pre><code>def concat_generalized_indices(*indices: GeneralizedIndex) -&gt; GeneralizedIndex:\n\"\"\"\n    Given generalized indices i1 for A -&gt; B, i2 for B -&gt; C .... i_n for Y -&gt; Z, returns\n    the generalized index for A -&gt; Z.\n    \"\"\"\no = GeneralizedIndex(1)\nfor i in indices:\no = GeneralizedIndex(o * get_power_of_two_floor(i) + (i - get_power_of_two_floor(i)))\nreturn o\n</code></pre>"},{"location":"ssz/merkle-proofs/#get_generalized_index_length","title":"<code>get_generalized_index_length</code>","text":"<pre><code>def get_generalized_index_length(index: GeneralizedIndex) -&gt; int:\n\"\"\"\n    Return the length of a path represented by a generalized index.\n    \"\"\"\nreturn int(log2(index))\n</code></pre>"},{"location":"ssz/merkle-proofs/#get_generalized_index_bit","title":"<code>get_generalized_index_bit</code>","text":"<pre><code>def get_generalized_index_bit(index: GeneralizedIndex, position: int) -&gt; bool:\n\"\"\"\n    Return the given bit of a generalized index.\n    \"\"\"\nreturn (index &amp; (1 &lt;&lt; position)) &gt; 0\n</code></pre>"},{"location":"ssz/merkle-proofs/#generalized_index_sibling","title":"<code>generalized_index_sibling</code>","text":"<pre><code>def generalized_index_sibling(index: GeneralizedIndex) -&gt; GeneralizedIndex:\nreturn GeneralizedIndex(index ^ 1)\n</code></pre>"},{"location":"ssz/merkle-proofs/#generalized_index_child","title":"<code>generalized_index_child</code>","text":"<pre><code>def generalized_index_child(index: GeneralizedIndex, right_side: bool) -&gt; GeneralizedIndex:\nreturn GeneralizedIndex(index * 2 + right_side)\n</code></pre>"},{"location":"ssz/merkle-proofs/#generalized_index_parent","title":"<code>generalized_index_parent</code>","text":"<pre><code>def generalized_index_parent(index: GeneralizedIndex) -&gt; GeneralizedIndex:\nreturn GeneralizedIndex(index // 2)\n</code></pre>"},{"location":"ssz/merkle-proofs/#merkle-multiproofs","title":"Merkle multiproofs","text":"<p>We define a Merkle multiproof as a minimal subset of nodes in a Merkle tree needed to fully authenticate that a set of nodes actually are part of a Merkle tree with some specified root, at a particular set of generalized indices. For example, here is the Merkle multiproof for positions 0, 1, 6 in an 8-node Merkle tree (i.e. generalized indices 8, 9, 14):</p> <pre><code>       .\n   .       .\n .   *   *   .\nx x . . . . x *\n</code></pre> <p>. are unused nodes, * are used nodes, x are the values we are trying to prove. Notice how despite being a multiproof for 3 values, it requires only 3 auxiliary nodes, only one node more than would be required to prove a single value. Normally the efficiency gains are not quite that extreme, but the savings relative to individual Merkle proofs are still significant. As a rule of thumb, a multiproof for k nodes at the same level of an n-node tree has size <code>k * (n/k + log(n/k))</code>.</p> <p>First, we provide a method for computing the generalized indices of the auxiliary tree nodes that a proof of a given set of generalized indices will require:</p> <pre><code>def get_branch_indices(tree_index: GeneralizedIndex) -&gt; Sequence[GeneralizedIndex]:\n\"\"\"\n    Get the generalized indices of the sister chunks along the path from the chunk with the\n    given tree index to the root.\n    \"\"\"\no = [generalized_index_sibling(tree_index)]\nwhile o[-1] &gt; 1:\no.append(generalized_index_sibling(generalized_index_parent(o[-1])))\nreturn o[:-1]\n</code></pre> <pre><code>def get_path_indices(tree_index: GeneralizedIndex) -&gt; Sequence[GeneralizedIndex]:\n\"\"\"\n    Get the generalized indices of the chunks along the path from the chunk with the\n    given tree index to the root.\n    \"\"\"\no = [tree_index]\nwhile o[-1] &gt; 1:\no.append(generalized_index_parent(o[-1]))\nreturn o[:-1]\n</code></pre> <pre><code>def get_helper_indices(indices: Sequence[GeneralizedIndex]) -&gt; Sequence[GeneralizedIndex]:\n\"\"\"\n    Get the generalized indices of all \"extra\" chunks in the tree needed to prove the chunks with the given\n    generalized indices. Note that the decreasing order is chosen deliberately to ensure equivalence to the\n    order of hashes in a regular single-item Merkle proof in the single-item case.\n    \"\"\"\nall_helper_indices: Set[GeneralizedIndex] = set()\nall_path_indices: Set[GeneralizedIndex] = set()\nfor index in indices:\nall_helper_indices = all_helper_indices.union(set(get_branch_indices(index)))\nall_path_indices = all_path_indices.union(set(get_path_indices(index)))\nreturn sorted(all_helper_indices.difference(all_path_indices), reverse=True)\n</code></pre> <p>Now we provide the Merkle proof verification functions. First, for single item proofs:</p> <pre><code>def calculate_merkle_root(leaf: Bytes32, proof: Sequence[Bytes32], index: GeneralizedIndex) -&gt; Root:\nassert len(proof) == get_generalized_index_length(index)\nfor i, h in enumerate(proof):\nif get_generalized_index_bit(index, i):\nleaf = hash(h + leaf)\nelse:\nleaf = hash(leaf + h)\nreturn leaf\n</code></pre> <pre><code>def verify_merkle_proof(leaf: Bytes32, proof: Sequence[Bytes32], index: GeneralizedIndex, root: Root) -&gt; bool:\nreturn calculate_merkle_root(leaf, proof, index) == root\n</code></pre> <p>Now for multi-item proofs:</p> <pre><code>def calculate_multi_merkle_root(leaves: Sequence[Bytes32],\nproof: Sequence[Bytes32],\nindices: Sequence[GeneralizedIndex]) -&gt; Root:\nassert len(leaves) == len(indices)\nhelper_indices = get_helper_indices(indices)\nassert len(proof) == len(helper_indices)\nobjects = {\n**{index: node for index, node in zip(indices, leaves)},\n**{index: node for index, node in zip(helper_indices, proof)}\n}\nkeys = sorted(objects.keys(), reverse=True)\npos = 0\nwhile pos &lt; len(keys):\nk = keys[pos]\nif k in objects and k ^ 1 in objects and k // 2 not in objects:\nobjects[GeneralizedIndex(k // 2)] = hash(\nobjects[GeneralizedIndex((k | 1) ^ 1)] +\nobjects[GeneralizedIndex(k | 1)]\n)\nkeys.append(GeneralizedIndex(k // 2))\npos += 1\nreturn objects[GeneralizedIndex(1)]\n</code></pre> <pre><code>def verify_merkle_multiproof(leaves: Sequence[Bytes32],\nproof: Sequence[Bytes32],\nindices: Sequence[GeneralizedIndex],\nroot: Root) -&gt; bool:\nreturn calculate_multi_merkle_root(leaves, proof, indices) == root\n</code></pre> <p>Note that the single-item proof is a special case of a multi-item proof; a valid single-item proof verifies correctly when put into the multi-item verification function (making the natural trivial changes to input arguments, <code>index -&gt; [index]</code> and <code>leaf -&gt; [leaf]</code>). Note also that <code>calculate_merkle_root</code> and <code>calculate_multi_merkle_root</code> can be used independently to compute the new Merkle root of a proof with leaves updated.</p>"},{"location":"ssz/simple-serialize/","title":"SimpleSerialize (SSZ)","text":""},{"location":"ssz/simple-serialize/#table-of-contents","title":"Table of contents","text":"<ul> <li>Constants</li> <li>Typing</li> <li>Basic types</li> <li>Composite types</li> <li>Variable-size and fixed-size</li> <li>Byte</li> <li>Aliases</li> <li>Default values<ul> <li><code>is_zero</code></li> </ul> </li> <li>Illegal types</li> <li>Serialization</li> <li><code>uintN</code></li> <li><code>boolean</code></li> <li><code>Bitvector[N]</code></li> <li><code>Bitlist[N]</code></li> <li>Vectors, containers, lists</li> <li>Union</li> <li>Deserialization</li> <li>Merkleization</li> <li>Summaries and expansions</li> <li>Implementations</li> <li>JSON mapping</li> </ul>"},{"location":"ssz/simple-serialize/#constants","title":"Constants","text":"Name Value Description <code>BYTES_PER_CHUNK</code> <code>32</code> Number of bytes per chunk. <code>BYTES_PER_LENGTH_OFFSET</code> <code>4</code> Number of bytes per serialized length offset. <code>BITS_PER_BYTE</code> <code>8</code> Number of bits per byte."},{"location":"ssz/simple-serialize/#typing","title":"Typing","text":""},{"location":"ssz/simple-serialize/#basic-types","title":"Basic types","text":"<ul> <li><code>uintN</code>: <code>N</code>-bit unsigned integer (where <code>N in [8, 16, 32, 64, 128, 256]</code>)</li> <li><code>byte</code>: 8-bit opaque data container, equivalent in serialization and hashing to <code>uint8</code></li> <li><code>boolean</code>: <code>True</code> or <code>False</code></li> </ul>"},{"location":"ssz/simple-serialize/#composite-types","title":"Composite types","text":"<ul> <li>container: ordered heterogeneous collection of values<ul> <li>python dataclass notation with key-type pairs, e.g. <pre><code>class ContainerExample(Container):\nfoo: uint64\nbar: boolean\n</code></pre></li> </ul> </li> <li>vector: ordered fixed-length homogeneous collection, with <code>N</code> values<ul> <li>notation <code>Vector[type, N]</code>, e.g. <code>Vector[uint64, N]</code></li> </ul> </li> <li>list: ordered variable-length homogeneous collection, limited to <code>N</code> values<ul> <li>notation <code>List[type, N]</code>, e.g. <code>List[uint64, N]</code></li> </ul> </li> <li>bitvector: ordered fixed-length collection of <code>boolean</code> values, with <code>N</code> bits<ul> <li>notation <code>Bitvector[N]</code></li> </ul> </li> <li>bitlist: ordered variable-length collection of <code>boolean</code> values, limited to <code>N</code> bits<ul> <li>notation <code>Bitlist[N]</code></li> </ul> </li> <li>union: union type containing one of the given subtypes<ul> <li>notation <code>Union[type_0, type_1, ...]</code>, e.g. <code>union[None, uint64, uint32]</code></li> </ul> </li> </ul> <p>Note: Both <code>Vector[boolean, N]</code> and <code>Bitvector[N]</code> are valid, yet distinct due to their different serialization requirements. Similarly, both <code>List[boolean, N]</code> and <code>Bitlist[N]</code> are valid, yet distinct. Generally <code>Bitvector[N]</code>/<code>Bitlist[N]</code> are preferred because of their serialization efficiencies.</p>"},{"location":"ssz/simple-serialize/#variable-size-and-fixed-size","title":"Variable-size and fixed-size","text":"<p>We recursively define \"variable-size\" types to be lists, unions, <code>Bitlist</code> and all types that contain a variable-size type. All other types are said to be \"fixed-size\".</p>"},{"location":"ssz/simple-serialize/#byte","title":"Byte","text":"<p>Although the SSZ serialization of <code>byte</code> is equivalent to that of <code>uint8</code>, the former is used for opaque data while the latter is intended as a number.</p>"},{"location":"ssz/simple-serialize/#aliases","title":"Aliases","text":"<p>For convenience we alias:</p> <ul> <li><code>bit</code> to <code>boolean</code></li> <li><code>BytesN</code> and <code>ByteVector[N]</code> to <code>Vector[byte, N]</code> (this is not a basic type)</li> <li><code>ByteList[N]</code> to <code>List[byte, N]</code></li> </ul> <p>Aliases are semantically equivalent to their underlying type and therefore share canonical representations both in SSZ and in related formats.</p>"},{"location":"ssz/simple-serialize/#default-values","title":"Default values","text":"<p>Assuming a helper function <code>default(type)</code> which returns the default value for <code>type</code>, we can recursively define the default value for all types.</p> Type Default Value <code>uintN</code> <code>0</code> <code>boolean</code> <code>False</code> <code>Container</code> <code>[default(type) for type in container]</code> <code>Vector[type, N]</code> <code>[default(type)] * N</code> <code>Bitvector[N]</code> <code>[False] * N</code> <code>List[type, N]</code> <code>[]</code> <code>Bitlist[N]</code> <code>[]</code> <code>Union[type_0, type_1, ...]</code> <code>default(type_0)</code>"},{"location":"ssz/simple-serialize/#is_zero","title":"<code>is_zero</code>","text":"<p>An SSZ object is called zeroed (and thus, <code>is_zero(object)</code> returns true) if it is equal to the default value for that type.</p>"},{"location":"ssz/simple-serialize/#illegal-types","title":"Illegal types","text":"<ul> <li>Empty vector types (<code>Vector[type, 0]</code>, <code>Bitvector[0]</code>) are illegal.</li> <li>Containers with no fields are illegal.</li> <li>The <code>None</code> type option in a <code>Union</code> type is only legal as the first option (i.e. with index zero).</li> </ul>"},{"location":"ssz/simple-serialize/#serialization","title":"Serialization","text":"<p>We recursively define the <code>serialize</code> function which consumes an object <code>value</code> (of the type specified) and returns a bytestring of type <code>bytes</code>.</p> <p>Note: In the function definitions below (<code>serialize</code>, <code>hash_tree_root</code>, <code>is_variable_size</code>, etc.) objects implicitly carry their type.</p>"},{"location":"ssz/simple-serialize/#uintn","title":"<code>uintN</code>","text":"<pre><code>assert N in [8, 16, 32, 64, 128, 256]\nreturn value.to_bytes(N // BITS_PER_BYTE, \"little\")\n</code></pre>"},{"location":"ssz/simple-serialize/#boolean","title":"<code>boolean</code>","text":"<pre><code>assert value in (True, False)\nreturn b\"\\x01\" if value is True else b\"\\x00\"\n</code></pre>"},{"location":"ssz/simple-serialize/#bitvectorn","title":"<code>Bitvector[N]</code>","text":"<pre><code>array = [0] * ((N + 7) // 8)\nfor i in range(N):\narray[i // 8] |= value[i] &lt;&lt; (i % 8)\nreturn bytes(array)\n</code></pre>"},{"location":"ssz/simple-serialize/#bitlistn","title":"<code>Bitlist[N]</code>","text":"<p>Note that from the offset coding, the length (in bytes) of the bitlist is known. An additional <code>1</code> bit is added to the end, at index <code>e</code> where <code>e</code> is the length of the bitlist (not the limit), so that the length in bits will also be known.</p> <pre><code>array = [0] * ((len(value) // 8) + 1)\nfor i in range(len(value)):\narray[i // 8] |= value[i] &lt;&lt; (i % 8)\narray[len(value) // 8] |= 1 &lt;&lt; (len(value) % 8)\nreturn bytes(array)\n</code></pre>"},{"location":"ssz/simple-serialize/#vectors-containers-lists","title":"Vectors, containers, lists","text":"<pre><code># Recursively serialize\nfixed_parts = [serialize(element) if not is_variable_size(element) else None for element in value]\nvariable_parts = [serialize(element) if is_variable_size(element) else b\"\" for element in value]\n# Compute and check lengths\nfixed_lengths = [len(part) if part != None else BYTES_PER_LENGTH_OFFSET for part in fixed_parts]\nvariable_lengths = [len(part) for part in variable_parts]\nassert sum(fixed_lengths + variable_lengths) &lt; 2**(BYTES_PER_LENGTH_OFFSET * BITS_PER_BYTE)\n# Interleave offsets of variable-size parts with fixed-size parts\nvariable_offsets = [serialize(uint32(sum(fixed_lengths + variable_lengths[:i]))) for i in range(len(value))]\nfixed_parts = [part if part != None else variable_offsets[i] for i, part in enumerate(fixed_parts)]\n# Return the concatenation of the fixed-size parts (offsets interleaved) with the variable-size parts\nreturn b\"\".join(fixed_parts + variable_parts)\n</code></pre>"},{"location":"ssz/simple-serialize/#union","title":"Union","text":"<p>A <code>value</code> as <code>Union[T...]</code> type has properties <code>value.value</code> with the contained value, and <code>value.selector</code> which indexes the selected <code>Union</code> type option <code>T</code>.</p> <p>A <code>Union</code>: - May have multiple selectors with the same type. - Should not use selectors above 127 (i.e. highest bit is set), these are reserved for backwards compatible extensions. - Must have at least 1 type option. - May have <code>None</code> as first type option, i.e. <code>selector == 0</code> - Must have at least 2 type options if the first is <code>None</code> - Is always considered a variable-length type, even if all type options have an equal fixed-length.</p> <pre><code>if value.value is None:\nassert value.selector == 0\nreturn b\"\\x00\"\nelse:\nserialized_bytes = serialize(value.value)\nserialized_selector_index = value.selector.to_bytes(1, \"little\")\nreturn serialized_selector_index + serialized_bytes\n</code></pre>"},{"location":"ssz/simple-serialize/#deserialization","title":"Deserialization","text":"<p>Because serialization is an injective function (i.e. two distinct objects of the same type will serialize to different values) any bytestring has at most one object it could deserialize to.</p> <p>Deserialization can be implemented using a recursive algorithm. The deserialization of basic objects is easy, and from there we can find a simple recursive algorithm for all fixed-size objects. For variable-size objects we have to do one of the following depending on what kind of object it is:</p> <ul> <li>Vector/list of a variable-size object: The serialized data will start with offsets of all the serialized objects (<code>BYTES_PER_LENGTH_OFFSET</code> bytes each).</li> <li>Using the first offset, we can compute the length of the list (divide by <code>BYTES_PER_LENGTH_OFFSET</code>), as it gives us the total number of bytes in the offset data.</li> <li>The size of each object in the vector/list can be inferred from the difference of two offsets. To get the size of the last object, the total number of bytes has to be known (it is not generally possible to deserialize an SSZ object of unknown length)</li> <li>Containers follow the same principles as vectors, with the difference that there may be fixed-size objects in a container as well. This means the <code>fixed_parts</code> data will contain offsets as well as fixed-size objects.</li> <li>In the case of bitlists, the length in bits cannot be uniquely inferred from the number of bytes in the object. Because of this, they have a bit at the end that is always set. This bit has to be used to infer the size of the bitlist in bits.</li> <li>In the case of unions, the first byte of the deserialization scope is deserialized as type selector, the remainder of the scope is deserialized as the selected type.</li> </ul> <p>Note that deserialization requires hardening against invalid inputs. A non-exhaustive list:</p> <ul> <li>Offsets: out of order, out of range, mismatching minimum element size.</li> <li>Scope: Extra unused bytes, not aligned with element size.</li> <li>More elements than a list limit allows. Part of enforcing consensus.</li> <li>An out-of-bounds selected index in an <code>Union</code></li> </ul> <p>Efficient algorithms for computing this object can be found in the implementations.</p>"},{"location":"ssz/simple-serialize/#merkleization","title":"Merkleization","text":"<p>We first define helper functions:</p> <ul> <li><code>size_of(B)</code>, where <code>B</code> is a basic type: the length, in bytes, of the serialized form of the basic type.</li> <li><code>chunk_count(type)</code>: calculate the amount of leafs for merkleization of the type.</li> <li>all basic types: <code>1</code></li> <li><code>Bitlist[N]</code> and <code>Bitvector[N]</code>: <code>(N + 255) // 256</code> (dividing by chunk size, rounding up)</li> <li><code>List[B, N]</code> and <code>Vector[B, N]</code>, where <code>B</code> is a basic type: <code>(N * size_of(B) + 31) // 32</code> (dividing by chunk size, rounding up)</li> <li><code>List[C, N]</code> and <code>Vector[C, N]</code>, where <code>C</code> is a composite type: <code>N</code></li> <li>containers: <code>len(fields)</code></li> <li><code>pack(values)</code>: Given ordered objects of the same basic type:    1. Serialize <code>values</code> into bytes.    2. If not aligned to a multiple of <code>BYTES_PER_CHUNK</code> bytes, right-pad with zeroes to the next multiple.    3. Partition the bytes into <code>BYTES_PER_CHUNK</code>-byte chunks.    4. Return the chunks.</li> <li><code>pack_bits(bits)</code>: Given the bits of bitlist or bitvector, get <code>bitfield_bytes</code> by packing them in bytes and aligning to the start. The length-delimiting bit for bitlists is excluded. Then return <code>pack(bitfield_bytes)</code>.</li> <li><code>next_pow_of_two(i)</code>: get the next power of 2 of <code>i</code>, if not already a power of 2, with 0 mapping to 1. Examples: <code>0-&gt;1, 1-&gt;1, 2-&gt;2, 3-&gt;4, 4-&gt;4, 6-&gt;8, 9-&gt;16</code></li> <li><code>merkleize(chunks, limit=None)</code>: Given ordered <code>BYTES_PER_CHUNK</code>-byte chunks, merkleize the chunks, and return the root:<ul> <li>The merkleization depends on the effective input, which must be padded/limited:<ul> <li>if no limit: pad the <code>chunks</code> with zeroed chunks to <code>next_pow_of_two(len(chunks))</code> (virtually for memory efficiency).</li> <li>if <code>limit &gt;= len(chunks)</code>, pad the <code>chunks</code> with zeroed chunks to <code>next_pow_of_two(limit)</code> (virtually for memory efficiency).</li> <li>if <code>limit &lt; len(chunks)</code>: do not merkleize, input exceeds limit. Raise an error instead.</li> </ul> </li> <li>Then, merkleize the chunks (empty input is padded to 1 zero chunk):<ul> <li>If <code>1</code> chunk: the root is the chunk itself.</li> <li>If <code>&gt; 1</code> chunks: merkleize as binary tree.</li> </ul> </li> </ul> </li> <li><code>mix_in_length</code>: Given a Merkle root <code>root</code> and a length <code>length</code> (<code>\"uint256\"</code> little-endian serialization) return <code>hash(root + length)</code>.</li> <li><code>mix_in_selector</code>: Given a Merkle root <code>root</code> and a type selector <code>selector</code> (<code>\"uint256\"</code> little-endian serialization) return <code>hash(root + selector)</code>.</li> </ul> <p>We now define Merkleization <code>hash_tree_root(value)</code> of an object <code>value</code> recursively:</p> <ul> <li><code>merkleize(pack(value))</code> if <code>value</code> is a basic object or a vector of basic objects.</li> <li><code>merkleize(pack_bits(value), limit=chunk_count(type))</code> if <code>value</code> is a bitvector.</li> <li><code>mix_in_length(merkleize(pack(value), limit=chunk_count(type)), len(value))</code> if <code>value</code> is a list of basic objects.</li> <li><code>mix_in_length(merkleize(pack_bits(value), limit=chunk_count(type)), len(value))</code> if <code>value</code> is a bitlist.</li> <li><code>merkleize([hash_tree_root(element) for element in value])</code> if <code>value</code> is a vector of composite objects or a container.</li> <li><code>mix_in_length(merkleize([hash_tree_root(element) for element in value], limit=chunk_count(type)), len(value))</code> if <code>value</code> is a list of composite objects.</li> <li><code>mix_in_selector(hash_tree_root(value.value), value.selector)</code> if <code>value</code> is of union type, and <code>value.value</code> is not <code>None</code></li> <li><code>mix_in_selector(Bytes32(), 0)</code> if <code>value</code> is of union type, and <code>value.value</code> is <code>None</code></li> </ul>"},{"location":"ssz/simple-serialize/#summaries-and-expansions","title":"Summaries and expansions","text":"<p>Let <code>A</code> be an object derived from another object <code>B</code> by replacing some of the (possibly nested) values of <code>B</code> by their <code>hash_tree_root</code>. We say <code>A</code> is a \"summary\" of <code>B</code>, and that <code>B</code> is an \"expansion\" of <code>A</code>. Notice <code>hash_tree_root(A) == hash_tree_root(B)</code>.</p> <p>We similarly define \"summary types\" and \"expansion types\". For example, <code>BeaconBlock</code> is an expansion type of <code>BeaconBlockHeader</code>. Notice that objects expand to at most one object of a given expansion type. For example, <code>BeaconBlockHeader</code> objects uniquely expand to <code>BeaconBlock</code> objects.</p>"},{"location":"ssz/simple-serialize/#implementations","title":"Implementations","text":"<p>See https://github.com/ethereum/eth2.0-specs/issues/2138 for a list of current known implementations.</p>"},{"location":"ssz/simple-serialize/#json-mapping","title":"JSON mapping","text":"<p>The canonical JSON mapping assigns to each SSZ type a corresponding JSON encoding, enabling an SSZ schema to also define the JSON encoding.</p> <p>When decoding JSON data, all fields in the SSZ schema must be present with a value. Parsers may ignore additional JSON fields.</p> SSZ JSON Example <code>uintN</code> string <code>\"0\"</code> <code>byte</code> hex-byte-string <code>\"0x00\"</code> <code>boolean</code> bool <code>false</code> <code>Container</code> object <code>{ \"field\": ... }</code> <code>Vector[type, N]</code> array <code>[element, ...]</code> <code>Vector[byte, N]</code> hex-byte-string <code>\"0x1122\"</code> <code>Bitvector[N]</code> hex-byte-string <code>\"0x1122\"</code> <code>List[type, N]</code> array <code>[element, ...]</code> <code>List[byte, N]</code> hex-byte-string <code>\"0x1122\"</code> <code>Bitlist[N]</code> hex-byte-string <code>\"0x1122\"</code> <code>Union[type_0, type_1, ...]</code> selector-object <code>{ \"selector\": number, \"data\": type_N }</code> <p>Integers are encoded as strings to avoid loss of precision in 64-bit values.</p> <p>Aliases are encoded as their underlying type.</p> <p><code>hex-byte-string</code> is a <code>0x</code>-prefixed hex encoding of byte data, as it would appear in an SSZ stream.</p> <p><code>List</code> and <code>Vector</code> of <code>byte</code> (and aliases thereof) are encoded as <code>hex-byte-string</code>. <code>Bitlist</code> and <code>Bitvector</code> similarly map their SSZ-byte encodings to a <code>hex-byte-string</code>.</p> <p><code>Union</code> is encoded as an object with a <code>selector</code> and <code>data</code> field, where the contents of <code>data</code> change according to the selector.</p>"},{"location":"sync/optimistic/","title":"Optimistic Sync","text":""},{"location":"sync/optimistic/#table-of-contents","title":"Table of contents","text":"<ul> <li>Introduction</li> <li>Constants</li> <li>Helpers</li> <li>Mechanisms</li> <li>When to optimistically import blocks</li> <li>How to optimistically import blocks</li> <li>How to apply <code>latestValidHash</code> when payload status is <code>INVALID</code></li> <li>Execution Engine Errors</li> <li>Assumptions about Execution Engine Behaviour</li> <li>Re-Orgs</li> <li>Fork Choice</li> <li>Fork Choice Poisoning</li> <li>Checkpoint Sync (Weak Subjectivity Sync)</li> <li>Validator assignments</li> <li>Block Production</li> <li>Attesting</li> <li>Participating in Sync Committees</li> <li>Ethereum Beacon APIs</li> <li>Design Decision Rationale</li> <li>Why sync optimistically?</li> <li>Why <code>SAFE_SLOTS_TO_IMPORT_OPTIMISTICALLY</code>?</li> <li>Transitioning from VALID -&gt; INVALIDATED or INVALIDATED -&gt; VALID</li> <li>What about Light Clients?</li> <li>What if <code>TERMINAL_BLOCK_HASH</code> is used?</li> </ul>"},{"location":"sync/optimistic/#introduction","title":"Introduction","text":"<p>In order to provide a syncing execution engine with a partial view of the head of the chain, it may be desirable for a consensus engine to import beacon blocks without verifying the execution payloads. This partial sync is called an optimistic sync.</p> <p>Optimistic sync is designed to be opt-in and backwards compatible (i.e., non-optimistic nodes can tolerate optimistic nodes on the network and vice versa). Optimistic sync is not a fundamental requirement for consensus nodes. Rather, it's a stop-gap measure to allow execution nodes to sync via established methods until future Ethereum roadmap items are implemented (e.g., statelessness).</p>"},{"location":"sync/optimistic/#constants","title":"Constants","text":"Name Value Unit <code>SAFE_SLOTS_TO_IMPORT_OPTIMISTICALLY</code> <code>128</code> slots <p>Note: the <code>SAFE_SLOTS_TO_IMPORT_OPTIMISTICALLY</code> must be user-configurable. See Fork Choice Poisoning.</p>"},{"location":"sync/optimistic/#helpers","title":"Helpers","text":"<p>For brevity, we define two aliases for values of the <code>status</code> field on <code>PayloadStatusV1</code>:</p> <ul> <li>Alias <code>NOT_VALIDATED</code> to:<ul> <li><code>SYNCING</code></li> <li><code>ACCEPTED</code></li> </ul> </li> <li>Alias <code>INVALIDATED</code> to:<ul> <li><code>INVALID</code></li> <li><code>INVALID_BLOCK_HASH</code></li> </ul> </li> </ul> <p>Let <code>head: BeaconBlock</code> be the result of calling of the fork choice algorithm at the time of block production. Let <code>head_block_root: Root</code> be the root of that block.</p> <p>Let <code>blocks: Dict[Root, BeaconBlock]</code> and <code>block_states: Dict[Root, BeaconState]</code> be the blocks (and accompanying states) that have been verified either completely or optimistically.</p> <p>Let <code>optimistic_roots: Set[Root]</code> be the set of <code>hash_tree_root(block)</code> for all optimistically imported blocks which have only received a <code>NOT_VALIDATED</code> designation from an execution engine (i.e., they are not known to be <code>INVALIDATED</code> or <code>VALID</code>).</p> <p>Let <code>current_slot: Slot</code> be <code>(time - genesis_time) // SECONDS_PER_SLOT</code> where <code>time</code> is the UNIX time according to the local system clock.</p> <pre><code>@dataclass\nclass OptimisticStore(object):\noptimistic_roots: Set[Root]\nhead_block_root: Root\nblocks: Dict[Root, BeaconBlock] = field(default_factory=dict)\nblock_states: Dict[Root, BeaconState] = field(default_factory=dict)\n</code></pre> <pre><code>def is_optimistic(opt_store: OptimisticStore, block: BeaconBlock) -&gt; bool:\nreturn hash_tree_root(block) in opt_store.optimistic_roots\n</code></pre> <pre><code>def latest_verified_ancestor(opt_store: OptimisticStore, block: BeaconBlock) -&gt; BeaconBlock:\n# It is assumed that the `block` parameter is never an INVALIDATED block.\nwhile True:\nif not is_optimistic(opt_store, block) or block.parent_root == Root():\nreturn block\nblock = opt_store.blocks[block.parent_root]\n</code></pre> <pre><code>def is_execution_block(block: BeaconBlock) -&gt; bool:\nreturn block.body.execution_payload != ExecutionPayload()\n</code></pre> <pre><code>def is_optimistic_candidate_block(opt_store: OptimisticStore, current_slot: Slot, block: BeaconBlock) -&gt; bool:\nif is_execution_block(opt_store.blocks[block.parent_root]):\nreturn True\nif block.slot + SAFE_SLOTS_TO_IMPORT_OPTIMISTICALLY &lt;= current_slot:\nreturn True\nreturn False\n</code></pre> <p>Let a node be an optimistic node if its fork choice is in one of the following states: 1. <code>is_optimistic(opt_store, head) is True</code> 2. Blocks from every viable (with respect to FFG) branch have transitioned from <code>NOT_VALIDATED</code> to <code>INVALIDATED</code> leaving the block tree without viable branches</p> <p>Let only a validator on an optimistic node be an optimistic validator.</p> <p>When this specification only defines behaviour for an optimistic node/validator, but not for the non-optimistic case, assume default behaviours without regard for optimistic sync.</p>"},{"location":"sync/optimistic/#mechanisms","title":"Mechanisms","text":""},{"location":"sync/optimistic/#when-to-optimistically-import-blocks","title":"When to optimistically import blocks","text":"<p>A block MAY be optimistically imported when <code>is_optimistic_candidate_block(opt_store, current_slot, block)</code> returns <code>True</code>. This ensures that blocks are only optimistically imported if one or more of the following are true:</p> <ol> <li>The parent of the block has execution enabled.</li> <li>The current slot (as per the system clock) is at least    <code>SAFE_SLOTS_TO_IMPORT_OPTIMISTICALLY</code> ahead of the slot of the block being    imported.</li> </ol> <p>In effect, there are restrictions on when a merge block can be optimistically imported. The merge block is the first block in any chain where <code>is_execution_block(block) == True</code>. Any descendant of a merge block may be imported optimistically at any time.</p> <p>See Fork Choice Poisoning for the motivations behind these conditions.</p>"},{"location":"sync/optimistic/#how-to-optimistically-import-blocks","title":"How to optimistically import blocks","text":"<p>To optimistically import a block:</p> <ul> <li>The <code>verify_and_notify_new_payload</code> function MUST return <code>True</code> if the execution   engine returns <code>NOT_VALIDATED</code> or <code>VALID</code>. An <code>INVALIDATED</code> response MUST return <code>False</code>.</li> <li>The <code>validate_merge_block</code>  function MUST NOT raise an assertion if both the <code>pow_block</code> and <code>pow_parent</code> are unknown to the execution engine.</li> <li>All other assertions in <code>validate_merge_block</code>    (e.g., <code>TERMINAL_BLOCK_HASH</code>) MUST prevent an optimistic import.</li> <li>The parent of the block MUST NOT have an <code>INVALIDATED</code> execution payload.</li> </ul> <p>In addition to this change in validation, the consensus engine MUST track which blocks returned <code>NOT_VALIDATED</code> and which returned <code>VALID</code> for subsequent processing.</p> <p>Optimistically imported blocks MUST pass all verifications included in <code>process_block</code> (withstanding the modifications to <code>verify_and_notify_new_payload</code>).</p> <p>A consensus engine MUST be able to retrospectively (i.e., after import) modify the status of <code>NOT_VALIDATED</code> blocks to be either <code>VALID</code> or <code>INVALIDATED</code> based upon responses from an execution engine. I.e., perform the following transitions:</p> <ul> <li><code>NOT_VALIDATED</code> -&gt; <code>VALID</code></li> <li><code>NOT_VALIDATED</code> -&gt; <code>INVALIDATED</code></li> </ul> <p>When a block transitions from <code>NOT_VALIDATED</code> -&gt; <code>VALID</code>, all ancestors of the block MUST also transition from <code>NOT_VALIDATED</code> -&gt; <code>VALID</code>. Such a block and any previously <code>NOT_VALIDATED</code> ancestors are no longer considered \"optimistically imported\".</p> <p>When a block transitions from <code>NOT_VALIDATED</code> -&gt; <code>INVALIDATED</code>, all descendants of the block MUST also transition from <code>NOT_VALIDATED</code> -&gt; <code>INVALIDATED</code>.</p> <p>When a block transitions from the <code>NOT_VALIDATED</code> state, it is removed from the set of <code>opt_store.optimistic_roots</code>.</p> <p>When a \"merge block\" (i.e. the first block which enables execution in a chain) is declared to be <code>VALID</code> by an execution engine (either directly or indirectly), the full <code>validate_merge_block</code> MUST be run against the merge block. If the block fails <code>validate_merge_block</code>, the merge block MUST be treated the same as an <code>INVALIDATED</code> block (i.e., it and all its descendants are invalidated and removed from the block tree).</p>"},{"location":"sync/optimistic/#how-to-apply-latestvalidhash-when-payload-status-is-invalid","title":"How to apply <code>latestValidHash</code> when payload status is <code>INVALID</code>","text":"<p>Processing an <code>INVALID</code> payload status depends on the <code>latestValidHash</code> parameter. The general approach is as follows: 1. Consensus engine MUST identify <code>invalidBlock</code> as per definition in the table below. 2. <code>invalidBlock</code> and all of its descendants MUST be transitioned from <code>NOT_VALIDATED</code> to <code>INVALIDATED</code>.</p> <code>latestValidHash</code> <code>invalidBlock</code> Execution block hash The child of a block with <code>body.execution_payload.block_hash == latestValidHash</code> in the chain containing the block with payload in question <code>0x00..00</code> (all zeroes) The first block with <code>body.execution_payload != ExecutionPayload()</code> in the chain containing a block with payload in question <code>null</code> Block with payload in question <p>When <code>latestValidHash</code> is a meaningful execution block hash but consensus engine cannot find a block satisfying <code>body.execution_payload.block_hash == latestValidHash</code>, consensus engine SHOULD behave the same as if <code>latestValidHash</code> was <code>null</code>.</p>"},{"location":"sync/optimistic/#execution-engine-errors","title":"Execution Engine Errors","text":"<p>When an execution engine returns an error or fails to respond to a payload validity request for some block, a consensus engine:</p> <ul> <li>MUST NOT optimistically import the block.</li> <li>MUST NOT apply the block to the fork choice store.</li> <li>MAY queue the block for later processing.</li> </ul>"},{"location":"sync/optimistic/#assumptions-about-execution-engine-behaviour","title":"Assumptions about Execution Engine Behaviour","text":"<p>This specification assumes execution engines will only return <code>NOT_VALIDATED</code> when there is insufficient information available to make a <code>VALID</code> or <code>INVALIDATED</code> determination on the given <code>ExecutionPayload</code> (e.g., the parent payload is unknown). Specifically, <code>NOT_VALIDATED</code> responses should be fork-specific, in that the search for a block on one chain MUST NOT trigger a <code>NOT_VALIDATED</code> response for another chain.</p>"},{"location":"sync/optimistic/#re-orgs","title":"Re-Orgs","text":"<p>The consensus engine MUST support any chain reorganisation which does not affect the justified checkpoint.</p> <p>If the justified checkpoint transitions from <code>NOT_VALIDATED</code> -&gt; <code>INVALIDATED</code>, a consensus engine MAY choose to alert the user and force the application to exit.</p>"},{"location":"sync/optimistic/#fork-choice","title":"Fork Choice","text":"<p>Consensus engines MUST support removing blocks from fork choice that transition from <code>NOT_VALIDATED</code> to <code>INVALIDATED</code>. Specifically, a block deemed <code>INVALIDATED</code> at any point MUST NOT be included in the canonical chain and the weights from those <code>INVALIDATED</code> blocks MUST NOT be applied to any <code>VALID</code> or <code>NOT_VALIDATED</code> ancestors.</p>"},{"location":"sync/optimistic/#fork-choice-poisoning","title":"Fork Choice Poisoning","text":"<p>During the merge transition it is possible for an attacker to craft a <code>BeaconBlock</code> with an execution payload that references an eternally-unavailable <code>body.execution_payload.parent_hash</code> (i.e., the parent hash is random bytes). In rare circumstances, it is possible that an attacker can build atop such a block to trigger justification. If an optimistic node imports this malicious chain, that node will have a \"poisoned\" fork choice store, such that the node is unable to produce a block that descends from the head (due to the invalid chain of payloads) and the node is unable to produce a block that forks around the head (due to the justification of the malicious chain).</p> <p>If an honest chain exists which justifies a higher epoch than the malicious chain, that chain will take precedence and revive any poisoned store. Such a chain, if imported before the malicious chain, will prevent the store from being poisoned. Therefore, the poisoning attack is temporary if &gt;= 2/3rds of the network is honest and non-faulty.</p> <p>The <code>SAFE_SLOTS_TO_IMPORT_OPTIMISTICALLY</code> parameter assumes that the network will justify a honest chain within some number of slots. With this assumption, it is acceptable to optimistically import transition blocks during the sync process. Since there is an assumption that an honest chain with a higher justified checkpoint exists, any fork choice poisoning will be short-lived and resolved before that node is required to produce a block.</p> <p>However, the assumption that the honest, canonical chain will always justify within <code>SAFE_SLOTS_TO_IMPORT_OPTIMISTICALLY</code> slots is dubious. Therefore, clients MUST provide the following command line flag to assist with manual disaster recovery:</p> <ul> <li><code>--safe-slots-to-import-optimistically</code>: modifies the     <code>SAFE_SLOTS_TO_IMPORT_OPTIMISTICALLY</code>.</li> </ul>"},{"location":"sync/optimistic/#checkpoint-sync-weak-subjectivity-sync","title":"Checkpoint Sync (Weak Subjectivity Sync)","text":"<p>A consensus engine MAY assume that the <code>ExecutionPayload</code> of a block used as an anchor for checkpoint sync is <code>VALID</code> without necessarily providing that payload to an execution engine.</p>"},{"location":"sync/optimistic/#validator-assignments","title":"Validator assignments","text":"<p>An optimistic node is not a full node. It is unable to produce blocks, since an execution engine cannot produce a payload upon an unknown parent. It cannot faithfully attest to the head block of the chain, since it has not fully verified that block.</p>"},{"location":"sync/optimistic/#block-production","title":"Block Production","text":"<p>An optimistic validator MUST NOT produce a block (i.e., sign across the <code>DOMAIN_BEACON_PROPOSER</code> domain).</p>"},{"location":"sync/optimistic/#attesting","title":"Attesting","text":"<p>An optimistic validator MUST NOT participate in attestation (i.e., sign across the <code>DOMAIN_BEACON_ATTESTER</code>, <code>DOMAIN_SELECTION_PROOF</code> or <code>DOMAIN_AGGREGATE_AND_PROOF</code> domains).</p>"},{"location":"sync/optimistic/#participating-in-sync-committees","title":"Participating in Sync Committees","text":"<p>An optimistic validator MUST NOT participate in sync committees (i.e., sign across the <code>DOMAIN_SYNC_COMMITTEE</code>, <code>DOMAIN_SYNC_COMMITTEE_SELECTION_PROOF</code> or <code>DOMAIN_CONTRIBUTION_AND_PROOF</code> domains).</p>"},{"location":"sync/optimistic/#ethereum-beacon-apis","title":"Ethereum Beacon APIs","text":"<p>Consensus engines which provide an implementation of the Ethereum Beacon APIs must take care to ensure the <code>execution_optimistic</code> value is set to <code>True</code> whenever the request references optimistic blocks (and vice-versa).</p>"},{"location":"sync/optimistic/#design-decision-rationale","title":"Design Decision Rationale","text":""},{"location":"sync/optimistic/#why-sync-optimistically","title":"Why sync optimistically?","text":"<p>Most execution engines use state sync as a default sync mechanism on Ethereum Mainnet  because executing blocks from genesis takes several weeks on commodity hardware.</p> <p>State sync requires the knowledge of the current head of the chain to converge eventually. If not constantly fed with the most recent head, state sync won't be able to complete because the recent state soon becomes unavailable due to state trie pruning.</p> <p>Optimistic block import (i.e. import when the execution engine cannot currently validate the payload) breaks a deadlock between the execution layer sync process and importing beacon blocks while the execution engine is syncing.</p> <p>Optimistic sync is also an optimal strategy for execution engines using block execution as a default sync mechanism (e.g. Erigon). Alternatively, a consensus engine may inform the execution engine with a payload obtained from a checkpoint block, then wait until the execution layer catches up with it and proceed in lock step after that. This alternative approach would keep user in limbo for several hours and would increase time of the sync process as batch sync has more opportunities for optimisation than the lock step.</p> <p>Aforementioned premises make optimistic sync a generalized solution for interaction between consensus and execution engines during the sync process.</p>"},{"location":"sync/optimistic/#why-safe_slots_to_import_optimistically","title":"Why <code>SAFE_SLOTS_TO_IMPORT_OPTIMISTICALLY</code>?","text":"<p>Nodes can only import an optimistic block if their justified checkpoint is verified or the block is older than <code>SAFE_SLOTS_TO_IMPORT_OPTIMISTICALLY</code>.</p> <p>These restraints are applied in order to mitigate an attack where a block which enables execution (a transition block) can reference a junk parent hash. This makes it impossible for honest nodes to build atop that block. If an attacker exploits a nuance in fork choice <code>filter_block_tree</code>, they can, in some rare cases, produce a junk block that out-competes all locally produced blocks for the head. This prevents a node from producing a chain of blocks, therefore breaking liveness.</p> <p>Thankfully, if 2/3rds of validators are not poisoned, they can justify an honest chain which will un-poison all other nodes.</p> <p>Notably, this attack only exists for optimistic nodes. Nodes which fully verify the transition block will reject a block with a junk parent hash. Therefore, liveness is unaffected if a vast majority of nodes have fully synced execution and consensus clients before and during the transition.</p> <p>Given all of this, we can say two things:</p> <ol> <li>BNs which are following the head during the transition shouldn't    optimistically import the transition block. If 1/3rd of validators    optimistically import the poison block, there will be no remaining nodes to    justify an honest chain.</li> <li>BNs which are syncing can optimistically import transition blocks. In    this case a justified chain already exists blocks. The poison block would be    quickly reverted and would have no effect on liveness.</li> </ol> <p>Astute readers will notice that (2) contains a glaring assumption about network liveness. This is necessary because a node cannot feasibly ascertain that the transition block is justified without importing that block and risking poisoning. Therefore, we use <code>SAFE_SLOTS_TO_IMPORT_OPTIMISTICALLY</code> to say something along the lines of: \"if the transition block is sufficiently old enough, then we can just assume that block is honest or there exists an honest justified chain to out-compete it.\"</p> <p>Note the use of \"feasibly\" in the previous paragraph. One can imagine mechanisms to check that a block is justified before importing it. For example, just keep processing blocks without adding them to fork choice.  However, there are still edge-cases here (e.g., when to halt and declare there was no justification?) and how to mitigate implementation complexity.  At this point, it's important to reflect on the attack and how likely it is to happen. It requires some rather contrived circumstances and it seems very unlikely to occur.  Therefore, we need to consider if adding complexity to avoid an unlikely attack increases or decreases our total risk. Presently, it appears that <code>SAFE_SLOTS_TO_IMPORT_OPTIMISTICALLY</code> sits in a sweet spot for this trade-off.</p>"},{"location":"sync/optimistic/#transitioning-from-valid-invalidated-or-invalidated-valid","title":"Transitioning from VALID -&gt; INVALIDATED or INVALIDATED -&gt; VALID","text":"<p>These operations are purposefully omitted. It is outside of the scope of the specification since it's only possible with a faulty EE.</p> <p>Such a scenario requires manual intervention.</p>"},{"location":"sync/optimistic/#what-about-light-clients","title":"What about Light Clients?","text":"<p>An alternative to optimistic sync is to run a light client inside/alongside beacon nodes that mitigates the need for optimistic sync by providing tip-of-chain blocks to the execution engine. However, light clients come with their own set of complexities. Relying on light clients may also restrict nodes from syncing from genesis, if they so desire.</p> <p>A notable thing about optimistic sync is that it's optional. Should an implementation decide to go the light-client route, then they can just ignore optimistic sync altogether.</p>"},{"location":"sync/optimistic/#what-if-terminal_block_hash-is-used","title":"What if <code>TERMINAL_BLOCK_HASH</code> is used?","text":"<p>If the terminal block hash override is used (i.e., <code>TERMINAL_BLOCK_HASH != Hash32()</code>), the <code>validate_merge_block</code> function will deterministically return <code>True</code> or <code>False</code>. Whilst it's not technically required retrospectively call <code>validate_merge_block</code> on a transition block that matches <code>TERMINAL_BLOCK_HASH</code> after an optimistic sync, doing so will have no effect. For simplicity, the optimistic sync specification does not define edge-case behaviour for when <code>TERMINAL_BLOCK_HASH</code> is used.</p>"}]}